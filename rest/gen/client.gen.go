// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package gen

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
)

// Defines values for GetFuturesAggregatesParamsSort.
const (
	WindowStartAsc  GetFuturesAggregatesParamsSort = "window_start.asc"
	WindowStartDesc GetFuturesAggregatesParamsSort = "window_start.desc"
)

// Defines values for GetFuturesVXContractsParamsType.
const (
	GetFuturesVXContractsParamsTypeCombo  GetFuturesVXContractsParamsType = "combo"
	GetFuturesVXContractsParamsTypeSingle GetFuturesVXContractsParamsType = "single"
)

// Defines values for GetFuturesVXContractsParamsTypeAnyOf.
const (
	GetFuturesVXContractsParamsTypeAnyOfCombo  GetFuturesVXContractsParamsTypeAnyOf = "combo"
	GetFuturesVXContractsParamsTypeAnyOfSingle GetFuturesVXContractsParamsTypeAnyOf = "single"
)

// Defines values for GetFuturesVXProductsParamsSector.
const (
	GetFuturesVXProductsParamsSectorAsia              GetFuturesVXProductsParamsSector = "asia"
	GetFuturesVXProductsParamsSectorBase              GetFuturesVXProductsParamsSector = "base"
	GetFuturesVXProductsParamsSectorBiofuels          GetFuturesVXProductsParamsSector = "biofuels"
	GetFuturesVXProductsParamsSectorCoal              GetFuturesVXProductsParamsSector = "coal"
	GetFuturesVXProductsParamsSectorCrossRates        GetFuturesVXProductsParamsSector = "cross_rates"
	GetFuturesVXProductsParamsSectorCrudeOil          GetFuturesVXProductsParamsSector = "crude_oil"
	GetFuturesVXProductsParamsSectorCustomIndex       GetFuturesVXProductsParamsSector = "custom_index"
	GetFuturesVXProductsParamsSectorDairy             GetFuturesVXProductsParamsSector = "dairy"
	GetFuturesVXProductsParamsSectorDjUbsCi           GetFuturesVXProductsParamsSector = "dj_ubs_ci"
	GetFuturesVXProductsParamsSectorElectricity       GetFuturesVXProductsParamsSector = "electricity"
	GetFuturesVXProductsParamsSectorEmissions         GetFuturesVXProductsParamsSector = "emissions"
	GetFuturesVXProductsParamsSectorEurope            GetFuturesVXProductsParamsSector = "europe"
	GetFuturesVXProductsParamsSectorFertilizer        GetFuturesVXProductsParamsSector = "fertilizer"
	GetFuturesVXProductsParamsSectorForestry          GetFuturesVXProductsParamsSector = "forestry"
	GetFuturesVXProductsParamsSectorGrainsAndOilseeds GetFuturesVXProductsParamsSector = "grains_and_oilseeds"
	GetFuturesVXProductsParamsSectorIntlIndex         GetFuturesVXProductsParamsSector = "intl_index"
	GetFuturesVXProductsParamsSectorLiqNatGasLng      GetFuturesVXProductsParamsSector = "liq_nat_gas_lng"
	GetFuturesVXProductsParamsSectorLivestock         GetFuturesVXProductsParamsSector = "livestock"
	GetFuturesVXProductsParamsSectorLongTermGov       GetFuturesVXProductsParamsSector = "long_term_gov"
	GetFuturesVXProductsParamsSectorLongTermNonGov    GetFuturesVXProductsParamsSector = "long_term_non_gov"
	GetFuturesVXProductsParamsSectorMajors            GetFuturesVXProductsParamsSector = "majors"
	GetFuturesVXProductsParamsSectorMinors            GetFuturesVXProductsParamsSector = "minors"
	GetFuturesVXProductsParamsSectorNatGas            GetFuturesVXProductsParamsSector = "nat_gas"
	GetFuturesVXProductsParamsSectorNatGasLiqPetro    GetFuturesVXProductsParamsSector = "nat_gas_liq_petro"
	GetFuturesVXProductsParamsSectorPrecious          GetFuturesVXProductsParamsSector = "precious"
	GetFuturesVXProductsParamsSectorRefinedProducts   GetFuturesVXProductsParamsSector = "refined_products"
	GetFuturesVXProductsParamsSectorSAndPGsci         GetFuturesVXProductsParamsSector = "s_and_p_gsci"
	GetFuturesVXProductsParamsSectorSelSectorIndex    GetFuturesVXProductsParamsSector = "sel_sector_index"
	GetFuturesVXProductsParamsSectorShortTermGov      GetFuturesVXProductsParamsSector = "short_term_gov"
	GetFuturesVXProductsParamsSectorShortTermNonGov   GetFuturesVXProductsParamsSector = "short_term_non_gov"
	GetFuturesVXProductsParamsSectorSofts             GetFuturesVXProductsParamsSector = "softs"
	GetFuturesVXProductsParamsSectorUs                GetFuturesVXProductsParamsSector = "us"
	GetFuturesVXProductsParamsSectorUsIndex           GetFuturesVXProductsParamsSector = "us_index"
	GetFuturesVXProductsParamsSectorWetBulk           GetFuturesVXProductsParamsSector = "wet_bulk"
)

// Defines values for GetFuturesVXProductsParamsSectorAnyOf.
const (
	GetFuturesVXProductsParamsSectorAnyOfAsia              GetFuturesVXProductsParamsSectorAnyOf = "asia"
	GetFuturesVXProductsParamsSectorAnyOfBase              GetFuturesVXProductsParamsSectorAnyOf = "base"
	GetFuturesVXProductsParamsSectorAnyOfBiofuels          GetFuturesVXProductsParamsSectorAnyOf = "biofuels"
	GetFuturesVXProductsParamsSectorAnyOfCoal              GetFuturesVXProductsParamsSectorAnyOf = "coal"
	GetFuturesVXProductsParamsSectorAnyOfCrossRates        GetFuturesVXProductsParamsSectorAnyOf = "cross_rates"
	GetFuturesVXProductsParamsSectorAnyOfCrudeOil          GetFuturesVXProductsParamsSectorAnyOf = "crude_oil"
	GetFuturesVXProductsParamsSectorAnyOfCustomIndex       GetFuturesVXProductsParamsSectorAnyOf = "custom_index"
	GetFuturesVXProductsParamsSectorAnyOfDairy             GetFuturesVXProductsParamsSectorAnyOf = "dairy"
	GetFuturesVXProductsParamsSectorAnyOfDjUbsCi           GetFuturesVXProductsParamsSectorAnyOf = "dj_ubs_ci"
	GetFuturesVXProductsParamsSectorAnyOfElectricity       GetFuturesVXProductsParamsSectorAnyOf = "electricity"
	GetFuturesVXProductsParamsSectorAnyOfEmissions         GetFuturesVXProductsParamsSectorAnyOf = "emissions"
	GetFuturesVXProductsParamsSectorAnyOfEurope            GetFuturesVXProductsParamsSectorAnyOf = "europe"
	GetFuturesVXProductsParamsSectorAnyOfFertilizer        GetFuturesVXProductsParamsSectorAnyOf = "fertilizer"
	GetFuturesVXProductsParamsSectorAnyOfForestry          GetFuturesVXProductsParamsSectorAnyOf = "forestry"
	GetFuturesVXProductsParamsSectorAnyOfGrainsAndOilseeds GetFuturesVXProductsParamsSectorAnyOf = "grains_and_oilseeds"
	GetFuturesVXProductsParamsSectorAnyOfIntlIndex         GetFuturesVXProductsParamsSectorAnyOf = "intl_index"
	GetFuturesVXProductsParamsSectorAnyOfLiqNatGasLng      GetFuturesVXProductsParamsSectorAnyOf = "liq_nat_gas_lng"
	GetFuturesVXProductsParamsSectorAnyOfLivestock         GetFuturesVXProductsParamsSectorAnyOf = "livestock"
	GetFuturesVXProductsParamsSectorAnyOfLongTermGov       GetFuturesVXProductsParamsSectorAnyOf = "long_term_gov"
	GetFuturesVXProductsParamsSectorAnyOfLongTermNonGov    GetFuturesVXProductsParamsSectorAnyOf = "long_term_non_gov"
	GetFuturesVXProductsParamsSectorAnyOfMajors            GetFuturesVXProductsParamsSectorAnyOf = "majors"
	GetFuturesVXProductsParamsSectorAnyOfMinors            GetFuturesVXProductsParamsSectorAnyOf = "minors"
	GetFuturesVXProductsParamsSectorAnyOfNatGas            GetFuturesVXProductsParamsSectorAnyOf = "nat_gas"
	GetFuturesVXProductsParamsSectorAnyOfNatGasLiqPetro    GetFuturesVXProductsParamsSectorAnyOf = "nat_gas_liq_petro"
	GetFuturesVXProductsParamsSectorAnyOfPrecious          GetFuturesVXProductsParamsSectorAnyOf = "precious"
	GetFuturesVXProductsParamsSectorAnyOfRefinedProducts   GetFuturesVXProductsParamsSectorAnyOf = "refined_products"
	GetFuturesVXProductsParamsSectorAnyOfSAndPGsci         GetFuturesVXProductsParamsSectorAnyOf = "s_and_p_gsci"
	GetFuturesVXProductsParamsSectorAnyOfSelSectorIndex    GetFuturesVXProductsParamsSectorAnyOf = "sel_sector_index"
	GetFuturesVXProductsParamsSectorAnyOfShortTermGov      GetFuturesVXProductsParamsSectorAnyOf = "short_term_gov"
	GetFuturesVXProductsParamsSectorAnyOfShortTermNonGov   GetFuturesVXProductsParamsSectorAnyOf = "short_term_non_gov"
	GetFuturesVXProductsParamsSectorAnyOfSofts             GetFuturesVXProductsParamsSectorAnyOf = "softs"
	GetFuturesVXProductsParamsSectorAnyOfUs                GetFuturesVXProductsParamsSectorAnyOf = "us"
	GetFuturesVXProductsParamsSectorAnyOfUsIndex           GetFuturesVXProductsParamsSectorAnyOf = "us_index"
	GetFuturesVXProductsParamsSectorAnyOfWetBulk           GetFuturesVXProductsParamsSectorAnyOf = "wet_bulk"
)

// Defines values for GetFuturesVXProductsParamsSubSector.
const (
	GetFuturesVXProductsParamsSubSectorAsian             GetFuturesVXProductsParamsSubSector = "asian"
	GetFuturesVXProductsParamsSubSectorCanadian          GetFuturesVXProductsParamsSubSector = "canadian"
	GetFuturesVXProductsParamsSubSectorCat               GetFuturesVXProductsParamsSubSector = "cat"
	GetFuturesVXProductsParamsSubSectorCoolingDegreeDays GetFuturesVXProductsParamsSubSector = "cooling_degree_days"
	GetFuturesVXProductsParamsSubSectorErcot             GetFuturesVXProductsParamsSubSector = "ercot"
	GetFuturesVXProductsParamsSubSectorEuropean          GetFuturesVXProductsParamsSubSector = "european"
	GetFuturesVXProductsParamsSubSectorGulf              GetFuturesVXProductsParamsSubSector = "gulf"
	GetFuturesVXProductsParamsSubSectorHeatingDegreeDays GetFuturesVXProductsParamsSubSector = "heating_degree_days"
	GetFuturesVXProductsParamsSubSectorIsoNe             GetFuturesVXProductsParamsSubSector = "iso_ne"
	GetFuturesVXProductsParamsSubSectorLargeCapIndex     GetFuturesVXProductsParamsSubSector = "large_cap_index"
	GetFuturesVXProductsParamsSubSectorMidCapIndex       GetFuturesVXProductsParamsSubSector = "mid_cap_index"
	GetFuturesVXProductsParamsSubSectorMiso              GetFuturesVXProductsParamsSubSector = "miso"
	GetFuturesVXProductsParamsSubSectorNorthAmerican     GetFuturesVXProductsParamsSubSector = "north_american"
	GetFuturesVXProductsParamsSubSectorNyiso             GetFuturesVXProductsParamsSubSector = "nyiso"
	GetFuturesVXProductsParamsSubSectorPjm               GetFuturesVXProductsParamsSubSector = "pjm"
	GetFuturesVXProductsParamsSubSectorSmallCapIndex     GetFuturesVXProductsParamsSubSector = "small_cap_index"
	GetFuturesVXProductsParamsSubSectorWest              GetFuturesVXProductsParamsSubSector = "west"
	GetFuturesVXProductsParamsSubSectorWesternPower      GetFuturesVXProductsParamsSubSector = "western_power"
)

// Defines values for GetFuturesVXProductsParamsSubSectorAnyOf.
const (
	GetFuturesVXProductsParamsSubSectorAnyOfAsian             GetFuturesVXProductsParamsSubSectorAnyOf = "asian"
	GetFuturesVXProductsParamsSubSectorAnyOfCanadian          GetFuturesVXProductsParamsSubSectorAnyOf = "canadian"
	GetFuturesVXProductsParamsSubSectorAnyOfCat               GetFuturesVXProductsParamsSubSectorAnyOf = "cat"
	GetFuturesVXProductsParamsSubSectorAnyOfCoolingDegreeDays GetFuturesVXProductsParamsSubSectorAnyOf = "cooling_degree_days"
	GetFuturesVXProductsParamsSubSectorAnyOfErcot             GetFuturesVXProductsParamsSubSectorAnyOf = "ercot"
	GetFuturesVXProductsParamsSubSectorAnyOfEuropean          GetFuturesVXProductsParamsSubSectorAnyOf = "european"
	GetFuturesVXProductsParamsSubSectorAnyOfGulf              GetFuturesVXProductsParamsSubSectorAnyOf = "gulf"
	GetFuturesVXProductsParamsSubSectorAnyOfHeatingDegreeDays GetFuturesVXProductsParamsSubSectorAnyOf = "heating_degree_days"
	GetFuturesVXProductsParamsSubSectorAnyOfIsoNe             GetFuturesVXProductsParamsSubSectorAnyOf = "iso_ne"
	GetFuturesVXProductsParamsSubSectorAnyOfLargeCapIndex     GetFuturesVXProductsParamsSubSectorAnyOf = "large_cap_index"
	GetFuturesVXProductsParamsSubSectorAnyOfMidCapIndex       GetFuturesVXProductsParamsSubSectorAnyOf = "mid_cap_index"
	GetFuturesVXProductsParamsSubSectorAnyOfMiso              GetFuturesVXProductsParamsSubSectorAnyOf = "miso"
	GetFuturesVXProductsParamsSubSectorAnyOfNorthAmerican     GetFuturesVXProductsParamsSubSectorAnyOf = "north_american"
	GetFuturesVXProductsParamsSubSectorAnyOfNyiso             GetFuturesVXProductsParamsSubSectorAnyOf = "nyiso"
	GetFuturesVXProductsParamsSubSectorAnyOfPjm               GetFuturesVXProductsParamsSubSectorAnyOf = "pjm"
	GetFuturesVXProductsParamsSubSectorAnyOfSmallCapIndex     GetFuturesVXProductsParamsSubSectorAnyOf = "small_cap_index"
	GetFuturesVXProductsParamsSubSectorAnyOfWest              GetFuturesVXProductsParamsSubSectorAnyOf = "west"
	GetFuturesVXProductsParamsSubSectorAnyOfWesternPower      GetFuturesVXProductsParamsSubSectorAnyOf = "western_power"
)

// Defines values for GetFuturesVXProductsParamsAssetClass.
const (
	GetFuturesVXProductsParamsAssetClassAltInvestment GetFuturesVXProductsParamsAssetClass = "alt_investment"
	GetFuturesVXProductsParamsAssetClassCommodity     GetFuturesVXProductsParamsAssetClass = "commodity"
	GetFuturesVXProductsParamsAssetClassFinancials    GetFuturesVXProductsParamsAssetClass = "financials"
)

// Defines values for GetFuturesVXProductsParamsAssetClassAnyOf.
const (
	GetFuturesVXProductsParamsAssetClassAnyOfAltInvestment GetFuturesVXProductsParamsAssetClassAnyOf = "alt_investment"
	GetFuturesVXProductsParamsAssetClassAnyOfCommodity     GetFuturesVXProductsParamsAssetClassAnyOf = "commodity"
	GetFuturesVXProductsParamsAssetClassAnyOfFinancials    GetFuturesVXProductsParamsAssetClassAnyOf = "financials"
)

// Defines values for GetFuturesVXProductsParamsAssetSubClass.
const (
	GetFuturesVXProductsParamsAssetSubClassAgricultural    GetFuturesVXProductsParamsAssetSubClass = "agricultural"
	GetFuturesVXProductsParamsAssetSubClassCommodityIndex  GetFuturesVXProductsParamsAssetSubClass = "commodity_index"
	GetFuturesVXProductsParamsAssetSubClassEnergy          GetFuturesVXProductsParamsAssetSubClass = "energy"
	GetFuturesVXProductsParamsAssetSubClassEquity          GetFuturesVXProductsParamsAssetSubClass = "equity"
	GetFuturesVXProductsParamsAssetSubClassForeignExchange GetFuturesVXProductsParamsAssetSubClass = "foreign_exchange"
	GetFuturesVXProductsParamsAssetSubClassFreight         GetFuturesVXProductsParamsAssetSubClass = "freight"
	GetFuturesVXProductsParamsAssetSubClassHousing         GetFuturesVXProductsParamsAssetSubClass = "housing"
	GetFuturesVXProductsParamsAssetSubClassInterestRate    GetFuturesVXProductsParamsAssetSubClass = "interest_rate"
	GetFuturesVXProductsParamsAssetSubClassMetals          GetFuturesVXProductsParamsAssetSubClass = "metals"
	GetFuturesVXProductsParamsAssetSubClassWeather         GetFuturesVXProductsParamsAssetSubClass = "weather"
)

// Defines values for GetFuturesVXProductsParamsAssetSubClassAnyOf.
const (
	GetFuturesVXProductsParamsAssetSubClassAnyOfAgricultural    GetFuturesVXProductsParamsAssetSubClassAnyOf = "agricultural"
	GetFuturesVXProductsParamsAssetSubClassAnyOfCommodityIndex  GetFuturesVXProductsParamsAssetSubClassAnyOf = "commodity_index"
	GetFuturesVXProductsParamsAssetSubClassAnyOfEnergy          GetFuturesVXProductsParamsAssetSubClassAnyOf = "energy"
	GetFuturesVXProductsParamsAssetSubClassAnyOfEquity          GetFuturesVXProductsParamsAssetSubClassAnyOf = "equity"
	GetFuturesVXProductsParamsAssetSubClassAnyOfForeignExchange GetFuturesVXProductsParamsAssetSubClassAnyOf = "foreign_exchange"
	GetFuturesVXProductsParamsAssetSubClassAnyOfFreight         GetFuturesVXProductsParamsAssetSubClassAnyOf = "freight"
	GetFuturesVXProductsParamsAssetSubClassAnyOfHousing         GetFuturesVXProductsParamsAssetSubClassAnyOf = "housing"
	GetFuturesVXProductsParamsAssetSubClassAnyOfInterestRate    GetFuturesVXProductsParamsAssetSubClassAnyOf = "interest_rate"
	GetFuturesVXProductsParamsAssetSubClassAnyOfMetals          GetFuturesVXProductsParamsAssetSubClassAnyOf = "metals"
	GetFuturesVXProductsParamsAssetSubClassAnyOfWeather         GetFuturesVXProductsParamsAssetSubClassAnyOf = "weather"
)

// Defines values for GetFuturesVXProductsParamsType.
const (
	GetFuturesVXProductsParamsTypeCombo  GetFuturesVXProductsParamsType = "combo"
	GetFuturesVXProductsParamsTypeSingle GetFuturesVXProductsParamsType = "single"
)

// Defines values for GetFuturesVXProductsParamsTypeAnyOf.
const (
	GetFuturesVXProductsParamsTypeAnyOfCombo  GetFuturesVXProductsParamsTypeAnyOf = "combo"
	GetFuturesVXProductsParamsTypeAnyOfSingle GetFuturesVXProductsParamsTypeAnyOf = "single"
)

// Defines values for GetFuturesQuotesParamsSort.
const (
	GetFuturesQuotesParamsSortTimestampAsc  GetFuturesQuotesParamsSort = "timestamp.asc"
	GetFuturesQuotesParamsSortTimestampDesc GetFuturesQuotesParamsSort = "timestamp.desc"
)

// Defines values for GetFuturesTradesParamsSort.
const (
	GetFuturesTradesParamsSortTimestampAsc  GetFuturesTradesParamsSort = "timestamp.asc"
	GetFuturesTradesParamsSortTimestampDesc GetFuturesTradesParamsSort = "timestamp.desc"
)

// Defines values for GetStocksFilings10KVXSectionsParamsSection.
const (
	GetStocksFilings10KVXSectionsParamsSectionBusiness    GetStocksFilings10KVXSectionsParamsSection = "business"
	GetStocksFilings10KVXSectionsParamsSectionRiskFactors GetStocksFilings10KVXSectionsParamsSection = "risk_factors"
)

// Defines values for GetStocksFilings10KVXSectionsParamsSectionAnyOf.
const (
	GetStocksFilings10KVXSectionsParamsSectionAnyOfBusiness    GetStocksFilings10KVXSectionsParamsSectionAnyOf = "business"
	GetStocksFilings10KVXSectionsParamsSectionAnyOfRiskFactors GetStocksFilings10KVXSectionsParamsSectionAnyOf = "risk_factors"
)

// Defines values for GetStocksV1DividendsParamsDistributionType.
const (
	GetStocksV1DividendsParamsDistributionTypeIrregular    GetStocksV1DividendsParamsDistributionType = "irregular"
	GetStocksV1DividendsParamsDistributionTypeRecurring    GetStocksV1DividendsParamsDistributionType = "recurring"
	GetStocksV1DividendsParamsDistributionTypeSpecial      GetStocksV1DividendsParamsDistributionType = "special"
	GetStocksV1DividendsParamsDistributionTypeSupplemental GetStocksV1DividendsParamsDistributionType = "supplemental"
	GetStocksV1DividendsParamsDistributionTypeUnknown      GetStocksV1DividendsParamsDistributionType = "unknown"
)

// Defines values for GetStocksV1DividendsParamsDistributionTypeAnyOf.
const (
	GetStocksV1DividendsParamsDistributionTypeAnyOfIrregular    GetStocksV1DividendsParamsDistributionTypeAnyOf = "irregular"
	GetStocksV1DividendsParamsDistributionTypeAnyOfRecurring    GetStocksV1DividendsParamsDistributionTypeAnyOf = "recurring"
	GetStocksV1DividendsParamsDistributionTypeAnyOfSpecial      GetStocksV1DividendsParamsDistributionTypeAnyOf = "special"
	GetStocksV1DividendsParamsDistributionTypeAnyOfSupplemental GetStocksV1DividendsParamsDistributionTypeAnyOf = "supplemental"
	GetStocksV1DividendsParamsDistributionTypeAnyOfUnknown      GetStocksV1DividendsParamsDistributionTypeAnyOf = "unknown"
)

// Defines values for GetStocksV1SplitsParamsAdjustmentType.
const (
	GetStocksV1SplitsParamsAdjustmentTypeForwardSplit  GetStocksV1SplitsParamsAdjustmentType = "forward_split"
	GetStocksV1SplitsParamsAdjustmentTypeReverseSplit  GetStocksV1SplitsParamsAdjustmentType = "reverse_split"
	GetStocksV1SplitsParamsAdjustmentTypeStockDividend GetStocksV1SplitsParamsAdjustmentType = "stock_dividend"
)

// Defines values for GetStocksV1SplitsParamsAdjustmentTypeAnyOf.
const (
	GetStocksV1SplitsParamsAdjustmentTypeAnyOfForwardSplit  GetStocksV1SplitsParamsAdjustmentTypeAnyOf = "forward_split"
	GetStocksV1SplitsParamsAdjustmentTypeAnyOfReverseSplit  GetStocksV1SplitsParamsAdjustmentTypeAnyOf = "reverse_split"
	GetStocksV1SplitsParamsAdjustmentTypeAnyOfStockDividend GetStocksV1SplitsParamsAdjustmentTypeAnyOf = "stock_dividend"
)

// Defines values for GetCurrencyConversionParamsPrecision.
const (
	GetCurrencyConversionParamsPrecisionN0 GetCurrencyConversionParamsPrecision = 0
	GetCurrencyConversionParamsPrecisionN1 GetCurrencyConversionParamsPrecision = 1
	GetCurrencyConversionParamsPrecisionN2 GetCurrencyConversionParamsPrecision = 2
	GetCurrencyConversionParamsPrecisionN3 GetCurrencyConversionParamsPrecision = 3
	GetCurrencyConversionParamsPrecisionN4 GetCurrencyConversionParamsPrecision = 4
)

// Defines values for GetCryptoEMAParamsTimespan.
const (
	GetCryptoEMAParamsTimespanDay     GetCryptoEMAParamsTimespan = "day"
	GetCryptoEMAParamsTimespanHour    GetCryptoEMAParamsTimespan = "hour"
	GetCryptoEMAParamsTimespanMinute  GetCryptoEMAParamsTimespan = "minute"
	GetCryptoEMAParamsTimespanMonth   GetCryptoEMAParamsTimespan = "month"
	GetCryptoEMAParamsTimespanQuarter GetCryptoEMAParamsTimespan = "quarter"
	GetCryptoEMAParamsTimespanWeek    GetCryptoEMAParamsTimespan = "week"
	GetCryptoEMAParamsTimespanYear    GetCryptoEMAParamsTimespan = "year"
)

// Defines values for GetCryptoEMAParamsSeriesType.
const (
	GetCryptoEMAParamsSeriesTypeClose GetCryptoEMAParamsSeriesType = "close"
	GetCryptoEMAParamsSeriesTypeHigh  GetCryptoEMAParamsSeriesType = "high"
	GetCryptoEMAParamsSeriesTypeLow   GetCryptoEMAParamsSeriesType = "low"
	GetCryptoEMAParamsSeriesTypeOpen  GetCryptoEMAParamsSeriesType = "open"
)

// Defines values for GetCryptoEMAParamsOrder.
const (
	GetCryptoEMAParamsOrderAsc  GetCryptoEMAParamsOrder = "asc"
	GetCryptoEMAParamsOrderDesc GetCryptoEMAParamsOrder = "desc"
)

// Defines values for GetForexEMAParamsTimespan.
const (
	GetForexEMAParamsTimespanDay     GetForexEMAParamsTimespan = "day"
	GetForexEMAParamsTimespanHour    GetForexEMAParamsTimespan = "hour"
	GetForexEMAParamsTimespanMinute  GetForexEMAParamsTimespan = "minute"
	GetForexEMAParamsTimespanMonth   GetForexEMAParamsTimespan = "month"
	GetForexEMAParamsTimespanQuarter GetForexEMAParamsTimespan = "quarter"
	GetForexEMAParamsTimespanWeek    GetForexEMAParamsTimespan = "week"
	GetForexEMAParamsTimespanYear    GetForexEMAParamsTimespan = "year"
)

// Defines values for GetForexEMAParamsSeriesType.
const (
	GetForexEMAParamsSeriesTypeClose GetForexEMAParamsSeriesType = "close"
	GetForexEMAParamsSeriesTypeHigh  GetForexEMAParamsSeriesType = "high"
	GetForexEMAParamsSeriesTypeLow   GetForexEMAParamsSeriesType = "low"
	GetForexEMAParamsSeriesTypeOpen  GetForexEMAParamsSeriesType = "open"
)

// Defines values for GetForexEMAParamsOrder.
const (
	GetForexEMAParamsOrderAsc  GetForexEMAParamsOrder = "asc"
	GetForexEMAParamsOrderDesc GetForexEMAParamsOrder = "desc"
)

// Defines values for GetIndicesEMAParamsTimespan.
const (
	GetIndicesEMAParamsTimespanDay     GetIndicesEMAParamsTimespan = "day"
	GetIndicesEMAParamsTimespanHour    GetIndicesEMAParamsTimespan = "hour"
	GetIndicesEMAParamsTimespanMinute  GetIndicesEMAParamsTimespan = "minute"
	GetIndicesEMAParamsTimespanMonth   GetIndicesEMAParamsTimespan = "month"
	GetIndicesEMAParamsTimespanQuarter GetIndicesEMAParamsTimespan = "quarter"
	GetIndicesEMAParamsTimespanWeek    GetIndicesEMAParamsTimespan = "week"
	GetIndicesEMAParamsTimespanYear    GetIndicesEMAParamsTimespan = "year"
)

// Defines values for GetIndicesEMAParamsSeriesType.
const (
	GetIndicesEMAParamsSeriesTypeClose GetIndicesEMAParamsSeriesType = "close"
	GetIndicesEMAParamsSeriesTypeHigh  GetIndicesEMAParamsSeriesType = "high"
	GetIndicesEMAParamsSeriesTypeLow   GetIndicesEMAParamsSeriesType = "low"
	GetIndicesEMAParamsSeriesTypeOpen  GetIndicesEMAParamsSeriesType = "open"
)

// Defines values for GetIndicesEMAParamsOrder.
const (
	GetIndicesEMAParamsOrderAsc  GetIndicesEMAParamsOrder = "asc"
	GetIndicesEMAParamsOrderDesc GetIndicesEMAParamsOrder = "desc"
)

// Defines values for GetOptionsEMAParamsTimespan.
const (
	GetOptionsEMAParamsTimespanDay     GetOptionsEMAParamsTimespan = "day"
	GetOptionsEMAParamsTimespanHour    GetOptionsEMAParamsTimespan = "hour"
	GetOptionsEMAParamsTimespanMinute  GetOptionsEMAParamsTimespan = "minute"
	GetOptionsEMAParamsTimespanMonth   GetOptionsEMAParamsTimespan = "month"
	GetOptionsEMAParamsTimespanQuarter GetOptionsEMAParamsTimespan = "quarter"
	GetOptionsEMAParamsTimespanWeek    GetOptionsEMAParamsTimespan = "week"
	GetOptionsEMAParamsTimespanYear    GetOptionsEMAParamsTimespan = "year"
)

// Defines values for GetOptionsEMAParamsSeriesType.
const (
	GetOptionsEMAParamsSeriesTypeClose GetOptionsEMAParamsSeriesType = "close"
	GetOptionsEMAParamsSeriesTypeHigh  GetOptionsEMAParamsSeriesType = "high"
	GetOptionsEMAParamsSeriesTypeLow   GetOptionsEMAParamsSeriesType = "low"
	GetOptionsEMAParamsSeriesTypeOpen  GetOptionsEMAParamsSeriesType = "open"
)

// Defines values for GetOptionsEMAParamsOrder.
const (
	GetOptionsEMAParamsOrderAsc  GetOptionsEMAParamsOrder = "asc"
	GetOptionsEMAParamsOrderDesc GetOptionsEMAParamsOrder = "desc"
)

// Defines values for GetStocksEMAParamsTimespan.
const (
	GetStocksEMAParamsTimespanDay     GetStocksEMAParamsTimespan = "day"
	GetStocksEMAParamsTimespanHour    GetStocksEMAParamsTimespan = "hour"
	GetStocksEMAParamsTimespanMinute  GetStocksEMAParamsTimespan = "minute"
	GetStocksEMAParamsTimespanMonth   GetStocksEMAParamsTimespan = "month"
	GetStocksEMAParamsTimespanQuarter GetStocksEMAParamsTimespan = "quarter"
	GetStocksEMAParamsTimespanWeek    GetStocksEMAParamsTimespan = "week"
	GetStocksEMAParamsTimespanYear    GetStocksEMAParamsTimespan = "year"
)

// Defines values for GetStocksEMAParamsSeriesType.
const (
	GetStocksEMAParamsSeriesTypeClose GetStocksEMAParamsSeriesType = "close"
	GetStocksEMAParamsSeriesTypeHigh  GetStocksEMAParamsSeriesType = "high"
	GetStocksEMAParamsSeriesTypeLow   GetStocksEMAParamsSeriesType = "low"
	GetStocksEMAParamsSeriesTypeOpen  GetStocksEMAParamsSeriesType = "open"
)

// Defines values for GetStocksEMAParamsOrder.
const (
	GetStocksEMAParamsOrderAsc  GetStocksEMAParamsOrder = "asc"
	GetStocksEMAParamsOrderDesc GetStocksEMAParamsOrder = "desc"
)

// Defines values for GetCryptoMACDParamsTimespan.
const (
	GetCryptoMACDParamsTimespanDay     GetCryptoMACDParamsTimespan = "day"
	GetCryptoMACDParamsTimespanHour    GetCryptoMACDParamsTimespan = "hour"
	GetCryptoMACDParamsTimespanMinute  GetCryptoMACDParamsTimespan = "minute"
	GetCryptoMACDParamsTimespanMonth   GetCryptoMACDParamsTimespan = "month"
	GetCryptoMACDParamsTimespanQuarter GetCryptoMACDParamsTimespan = "quarter"
	GetCryptoMACDParamsTimespanWeek    GetCryptoMACDParamsTimespan = "week"
	GetCryptoMACDParamsTimespanYear    GetCryptoMACDParamsTimespan = "year"
)

// Defines values for GetCryptoMACDParamsSeriesType.
const (
	GetCryptoMACDParamsSeriesTypeClose GetCryptoMACDParamsSeriesType = "close"
	GetCryptoMACDParamsSeriesTypeHigh  GetCryptoMACDParamsSeriesType = "high"
	GetCryptoMACDParamsSeriesTypeLow   GetCryptoMACDParamsSeriesType = "low"
	GetCryptoMACDParamsSeriesTypeOpen  GetCryptoMACDParamsSeriesType = "open"
)

// Defines values for GetCryptoMACDParamsOrder.
const (
	GetCryptoMACDParamsOrderAsc  GetCryptoMACDParamsOrder = "asc"
	GetCryptoMACDParamsOrderDesc GetCryptoMACDParamsOrder = "desc"
)

// Defines values for GetForexMACDParamsTimespan.
const (
	GetForexMACDParamsTimespanDay     GetForexMACDParamsTimespan = "day"
	GetForexMACDParamsTimespanHour    GetForexMACDParamsTimespan = "hour"
	GetForexMACDParamsTimespanMinute  GetForexMACDParamsTimespan = "minute"
	GetForexMACDParamsTimespanMonth   GetForexMACDParamsTimespan = "month"
	GetForexMACDParamsTimespanQuarter GetForexMACDParamsTimespan = "quarter"
	GetForexMACDParamsTimespanWeek    GetForexMACDParamsTimespan = "week"
	GetForexMACDParamsTimespanYear    GetForexMACDParamsTimespan = "year"
)

// Defines values for GetForexMACDParamsSeriesType.
const (
	GetForexMACDParamsSeriesTypeClose GetForexMACDParamsSeriesType = "close"
	GetForexMACDParamsSeriesTypeHigh  GetForexMACDParamsSeriesType = "high"
	GetForexMACDParamsSeriesTypeLow   GetForexMACDParamsSeriesType = "low"
	GetForexMACDParamsSeriesTypeOpen  GetForexMACDParamsSeriesType = "open"
)

// Defines values for GetForexMACDParamsOrder.
const (
	GetForexMACDParamsOrderAsc  GetForexMACDParamsOrder = "asc"
	GetForexMACDParamsOrderDesc GetForexMACDParamsOrder = "desc"
)

// Defines values for GetIndicesMACDParamsTimespan.
const (
	GetIndicesMACDParamsTimespanDay     GetIndicesMACDParamsTimespan = "day"
	GetIndicesMACDParamsTimespanHour    GetIndicesMACDParamsTimespan = "hour"
	GetIndicesMACDParamsTimespanMinute  GetIndicesMACDParamsTimespan = "minute"
	GetIndicesMACDParamsTimespanMonth   GetIndicesMACDParamsTimespan = "month"
	GetIndicesMACDParamsTimespanQuarter GetIndicesMACDParamsTimespan = "quarter"
	GetIndicesMACDParamsTimespanWeek    GetIndicesMACDParamsTimespan = "week"
	GetIndicesMACDParamsTimespanYear    GetIndicesMACDParamsTimespan = "year"
)

// Defines values for GetIndicesMACDParamsSeriesType.
const (
	GetIndicesMACDParamsSeriesTypeClose GetIndicesMACDParamsSeriesType = "close"
	GetIndicesMACDParamsSeriesTypeHigh  GetIndicesMACDParamsSeriesType = "high"
	GetIndicesMACDParamsSeriesTypeLow   GetIndicesMACDParamsSeriesType = "low"
	GetIndicesMACDParamsSeriesTypeOpen  GetIndicesMACDParamsSeriesType = "open"
)

// Defines values for GetIndicesMACDParamsOrder.
const (
	GetIndicesMACDParamsOrderAsc  GetIndicesMACDParamsOrder = "asc"
	GetIndicesMACDParamsOrderDesc GetIndicesMACDParamsOrder = "desc"
)

// Defines values for GetOptionsMACDParamsTimespan.
const (
	GetOptionsMACDParamsTimespanDay     GetOptionsMACDParamsTimespan = "day"
	GetOptionsMACDParamsTimespanHour    GetOptionsMACDParamsTimespan = "hour"
	GetOptionsMACDParamsTimespanMinute  GetOptionsMACDParamsTimespan = "minute"
	GetOptionsMACDParamsTimespanMonth   GetOptionsMACDParamsTimespan = "month"
	GetOptionsMACDParamsTimespanQuarter GetOptionsMACDParamsTimespan = "quarter"
	GetOptionsMACDParamsTimespanWeek    GetOptionsMACDParamsTimespan = "week"
	GetOptionsMACDParamsTimespanYear    GetOptionsMACDParamsTimespan = "year"
)

// Defines values for GetOptionsMACDParamsSeriesType.
const (
	GetOptionsMACDParamsSeriesTypeClose GetOptionsMACDParamsSeriesType = "close"
	GetOptionsMACDParamsSeriesTypeHigh  GetOptionsMACDParamsSeriesType = "high"
	GetOptionsMACDParamsSeriesTypeLow   GetOptionsMACDParamsSeriesType = "low"
	GetOptionsMACDParamsSeriesTypeOpen  GetOptionsMACDParamsSeriesType = "open"
)

// Defines values for GetOptionsMACDParamsOrder.
const (
	GetOptionsMACDParamsOrderAsc  GetOptionsMACDParamsOrder = "asc"
	GetOptionsMACDParamsOrderDesc GetOptionsMACDParamsOrder = "desc"
)

// Defines values for GetStocksMACDParamsTimespan.
const (
	GetStocksMACDParamsTimespanDay     GetStocksMACDParamsTimespan = "day"
	GetStocksMACDParamsTimespanHour    GetStocksMACDParamsTimespan = "hour"
	GetStocksMACDParamsTimespanMinute  GetStocksMACDParamsTimespan = "minute"
	GetStocksMACDParamsTimespanMonth   GetStocksMACDParamsTimespan = "month"
	GetStocksMACDParamsTimespanQuarter GetStocksMACDParamsTimespan = "quarter"
	GetStocksMACDParamsTimespanWeek    GetStocksMACDParamsTimespan = "week"
	GetStocksMACDParamsTimespanYear    GetStocksMACDParamsTimespan = "year"
)

// Defines values for GetStocksMACDParamsSeriesType.
const (
	GetStocksMACDParamsSeriesTypeClose GetStocksMACDParamsSeriesType = "close"
	GetStocksMACDParamsSeriesTypeHigh  GetStocksMACDParamsSeriesType = "high"
	GetStocksMACDParamsSeriesTypeLow   GetStocksMACDParamsSeriesType = "low"
	GetStocksMACDParamsSeriesTypeOpen  GetStocksMACDParamsSeriesType = "open"
)

// Defines values for GetStocksMACDParamsOrder.
const (
	GetStocksMACDParamsOrderAsc  GetStocksMACDParamsOrder = "asc"
	GetStocksMACDParamsOrderDesc GetStocksMACDParamsOrder = "desc"
)

// Defines values for GetCryptoRSIParamsTimespan.
const (
	GetCryptoRSIParamsTimespanDay     GetCryptoRSIParamsTimespan = "day"
	GetCryptoRSIParamsTimespanHour    GetCryptoRSIParamsTimespan = "hour"
	GetCryptoRSIParamsTimespanMinute  GetCryptoRSIParamsTimespan = "minute"
	GetCryptoRSIParamsTimespanMonth   GetCryptoRSIParamsTimespan = "month"
	GetCryptoRSIParamsTimespanQuarter GetCryptoRSIParamsTimespan = "quarter"
	GetCryptoRSIParamsTimespanWeek    GetCryptoRSIParamsTimespan = "week"
	GetCryptoRSIParamsTimespanYear    GetCryptoRSIParamsTimespan = "year"
)

// Defines values for GetCryptoRSIParamsSeriesType.
const (
	GetCryptoRSIParamsSeriesTypeClose GetCryptoRSIParamsSeriesType = "close"
	GetCryptoRSIParamsSeriesTypeHigh  GetCryptoRSIParamsSeriesType = "high"
	GetCryptoRSIParamsSeriesTypeLow   GetCryptoRSIParamsSeriesType = "low"
	GetCryptoRSIParamsSeriesTypeOpen  GetCryptoRSIParamsSeriesType = "open"
)

// Defines values for GetCryptoRSIParamsOrder.
const (
	GetCryptoRSIParamsOrderAsc  GetCryptoRSIParamsOrder = "asc"
	GetCryptoRSIParamsOrderDesc GetCryptoRSIParamsOrder = "desc"
)

// Defines values for GetForexRSIParamsTimespan.
const (
	GetForexRSIParamsTimespanDay     GetForexRSIParamsTimespan = "day"
	GetForexRSIParamsTimespanHour    GetForexRSIParamsTimespan = "hour"
	GetForexRSIParamsTimespanMinute  GetForexRSIParamsTimespan = "minute"
	GetForexRSIParamsTimespanMonth   GetForexRSIParamsTimespan = "month"
	GetForexRSIParamsTimespanQuarter GetForexRSIParamsTimespan = "quarter"
	GetForexRSIParamsTimespanWeek    GetForexRSIParamsTimespan = "week"
	GetForexRSIParamsTimespanYear    GetForexRSIParamsTimespan = "year"
)

// Defines values for GetForexRSIParamsSeriesType.
const (
	GetForexRSIParamsSeriesTypeClose GetForexRSIParamsSeriesType = "close"
	GetForexRSIParamsSeriesTypeHigh  GetForexRSIParamsSeriesType = "high"
	GetForexRSIParamsSeriesTypeLow   GetForexRSIParamsSeriesType = "low"
	GetForexRSIParamsSeriesTypeOpen  GetForexRSIParamsSeriesType = "open"
)

// Defines values for GetForexRSIParamsOrder.
const (
	GetForexRSIParamsOrderAsc  GetForexRSIParamsOrder = "asc"
	GetForexRSIParamsOrderDesc GetForexRSIParamsOrder = "desc"
)

// Defines values for GetIndicesRSIParamsTimespan.
const (
	GetIndicesRSIParamsTimespanDay     GetIndicesRSIParamsTimespan = "day"
	GetIndicesRSIParamsTimespanHour    GetIndicesRSIParamsTimespan = "hour"
	GetIndicesRSIParamsTimespanMinute  GetIndicesRSIParamsTimespan = "minute"
	GetIndicesRSIParamsTimespanMonth   GetIndicesRSIParamsTimespan = "month"
	GetIndicesRSIParamsTimespanQuarter GetIndicesRSIParamsTimespan = "quarter"
	GetIndicesRSIParamsTimespanWeek    GetIndicesRSIParamsTimespan = "week"
	GetIndicesRSIParamsTimespanYear    GetIndicesRSIParamsTimespan = "year"
)

// Defines values for GetIndicesRSIParamsSeriesType.
const (
	GetIndicesRSIParamsSeriesTypeClose GetIndicesRSIParamsSeriesType = "close"
	GetIndicesRSIParamsSeriesTypeHigh  GetIndicesRSIParamsSeriesType = "high"
	GetIndicesRSIParamsSeriesTypeLow   GetIndicesRSIParamsSeriesType = "low"
	GetIndicesRSIParamsSeriesTypeOpen  GetIndicesRSIParamsSeriesType = "open"
)

// Defines values for GetIndicesRSIParamsOrder.
const (
	GetIndicesRSIParamsOrderAsc  GetIndicesRSIParamsOrder = "asc"
	GetIndicesRSIParamsOrderDesc GetIndicesRSIParamsOrder = "desc"
)

// Defines values for GetOptionsRSIParamsTimespan.
const (
	GetOptionsRSIParamsTimespanDay     GetOptionsRSIParamsTimespan = "day"
	GetOptionsRSIParamsTimespanHour    GetOptionsRSIParamsTimespan = "hour"
	GetOptionsRSIParamsTimespanMinute  GetOptionsRSIParamsTimespan = "minute"
	GetOptionsRSIParamsTimespanMonth   GetOptionsRSIParamsTimespan = "month"
	GetOptionsRSIParamsTimespanQuarter GetOptionsRSIParamsTimespan = "quarter"
	GetOptionsRSIParamsTimespanWeek    GetOptionsRSIParamsTimespan = "week"
	GetOptionsRSIParamsTimespanYear    GetOptionsRSIParamsTimespan = "year"
)

// Defines values for GetOptionsRSIParamsSeriesType.
const (
	GetOptionsRSIParamsSeriesTypeClose GetOptionsRSIParamsSeriesType = "close"
	GetOptionsRSIParamsSeriesTypeHigh  GetOptionsRSIParamsSeriesType = "high"
	GetOptionsRSIParamsSeriesTypeLow   GetOptionsRSIParamsSeriesType = "low"
	GetOptionsRSIParamsSeriesTypeOpen  GetOptionsRSIParamsSeriesType = "open"
)

// Defines values for GetOptionsRSIParamsOrder.
const (
	GetOptionsRSIParamsOrderAsc  GetOptionsRSIParamsOrder = "asc"
	GetOptionsRSIParamsOrderDesc GetOptionsRSIParamsOrder = "desc"
)

// Defines values for GetStocksRSIParamsTimespan.
const (
	GetStocksRSIParamsTimespanDay     GetStocksRSIParamsTimespan = "day"
	GetStocksRSIParamsTimespanHour    GetStocksRSIParamsTimespan = "hour"
	GetStocksRSIParamsTimespanMinute  GetStocksRSIParamsTimespan = "minute"
	GetStocksRSIParamsTimespanMonth   GetStocksRSIParamsTimespan = "month"
	GetStocksRSIParamsTimespanQuarter GetStocksRSIParamsTimespan = "quarter"
	GetStocksRSIParamsTimespanWeek    GetStocksRSIParamsTimespan = "week"
	GetStocksRSIParamsTimespanYear    GetStocksRSIParamsTimespan = "year"
)

// Defines values for GetStocksRSIParamsSeriesType.
const (
	GetStocksRSIParamsSeriesTypeClose GetStocksRSIParamsSeriesType = "close"
	GetStocksRSIParamsSeriesTypeHigh  GetStocksRSIParamsSeriesType = "high"
	GetStocksRSIParamsSeriesTypeLow   GetStocksRSIParamsSeriesType = "low"
	GetStocksRSIParamsSeriesTypeOpen  GetStocksRSIParamsSeriesType = "open"
)

// Defines values for GetStocksRSIParamsOrder.
const (
	GetStocksRSIParamsOrderAsc  GetStocksRSIParamsOrder = "asc"
	GetStocksRSIParamsOrderDesc GetStocksRSIParamsOrder = "desc"
)

// Defines values for GetCryptoSMAParamsTimespan.
const (
	GetCryptoSMAParamsTimespanDay     GetCryptoSMAParamsTimespan = "day"
	GetCryptoSMAParamsTimespanHour    GetCryptoSMAParamsTimespan = "hour"
	GetCryptoSMAParamsTimespanMinute  GetCryptoSMAParamsTimespan = "minute"
	GetCryptoSMAParamsTimespanMonth   GetCryptoSMAParamsTimespan = "month"
	GetCryptoSMAParamsTimespanQuarter GetCryptoSMAParamsTimespan = "quarter"
	GetCryptoSMAParamsTimespanWeek    GetCryptoSMAParamsTimespan = "week"
	GetCryptoSMAParamsTimespanYear    GetCryptoSMAParamsTimespan = "year"
)

// Defines values for GetCryptoSMAParamsSeriesType.
const (
	GetCryptoSMAParamsSeriesTypeClose GetCryptoSMAParamsSeriesType = "close"
	GetCryptoSMAParamsSeriesTypeHigh  GetCryptoSMAParamsSeriesType = "high"
	GetCryptoSMAParamsSeriesTypeLow   GetCryptoSMAParamsSeriesType = "low"
	GetCryptoSMAParamsSeriesTypeOpen  GetCryptoSMAParamsSeriesType = "open"
)

// Defines values for GetCryptoSMAParamsOrder.
const (
	GetCryptoSMAParamsOrderAsc  GetCryptoSMAParamsOrder = "asc"
	GetCryptoSMAParamsOrderDesc GetCryptoSMAParamsOrder = "desc"
)

// Defines values for GetForexSMAParamsTimespan.
const (
	GetForexSMAParamsTimespanDay     GetForexSMAParamsTimespan = "day"
	GetForexSMAParamsTimespanHour    GetForexSMAParamsTimespan = "hour"
	GetForexSMAParamsTimespanMinute  GetForexSMAParamsTimespan = "minute"
	GetForexSMAParamsTimespanMonth   GetForexSMAParamsTimespan = "month"
	GetForexSMAParamsTimespanQuarter GetForexSMAParamsTimespan = "quarter"
	GetForexSMAParamsTimespanWeek    GetForexSMAParamsTimespan = "week"
	GetForexSMAParamsTimespanYear    GetForexSMAParamsTimespan = "year"
)

// Defines values for GetForexSMAParamsSeriesType.
const (
	GetForexSMAParamsSeriesTypeClose GetForexSMAParamsSeriesType = "close"
	GetForexSMAParamsSeriesTypeHigh  GetForexSMAParamsSeriesType = "high"
	GetForexSMAParamsSeriesTypeLow   GetForexSMAParamsSeriesType = "low"
	GetForexSMAParamsSeriesTypeOpen  GetForexSMAParamsSeriesType = "open"
)

// Defines values for GetForexSMAParamsOrder.
const (
	GetForexSMAParamsOrderAsc  GetForexSMAParamsOrder = "asc"
	GetForexSMAParamsOrderDesc GetForexSMAParamsOrder = "desc"
)

// Defines values for GetIndicesSMAParamsTimespan.
const (
	GetIndicesSMAParamsTimespanDay     GetIndicesSMAParamsTimespan = "day"
	GetIndicesSMAParamsTimespanHour    GetIndicesSMAParamsTimespan = "hour"
	GetIndicesSMAParamsTimespanMinute  GetIndicesSMAParamsTimespan = "minute"
	GetIndicesSMAParamsTimespanMonth   GetIndicesSMAParamsTimespan = "month"
	GetIndicesSMAParamsTimespanQuarter GetIndicesSMAParamsTimespan = "quarter"
	GetIndicesSMAParamsTimespanWeek    GetIndicesSMAParamsTimespan = "week"
	GetIndicesSMAParamsTimespanYear    GetIndicesSMAParamsTimespan = "year"
)

// Defines values for GetIndicesSMAParamsSeriesType.
const (
	GetIndicesSMAParamsSeriesTypeClose GetIndicesSMAParamsSeriesType = "close"
	GetIndicesSMAParamsSeriesTypeHigh  GetIndicesSMAParamsSeriesType = "high"
	GetIndicesSMAParamsSeriesTypeLow   GetIndicesSMAParamsSeriesType = "low"
	GetIndicesSMAParamsSeriesTypeOpen  GetIndicesSMAParamsSeriesType = "open"
)

// Defines values for GetIndicesSMAParamsOrder.
const (
	GetIndicesSMAParamsOrderAsc  GetIndicesSMAParamsOrder = "asc"
	GetIndicesSMAParamsOrderDesc GetIndicesSMAParamsOrder = "desc"
)

// Defines values for GetOptionsSMAParamsTimespan.
const (
	GetOptionsSMAParamsTimespanDay     GetOptionsSMAParamsTimespan = "day"
	GetOptionsSMAParamsTimespanHour    GetOptionsSMAParamsTimespan = "hour"
	GetOptionsSMAParamsTimespanMinute  GetOptionsSMAParamsTimespan = "minute"
	GetOptionsSMAParamsTimespanMonth   GetOptionsSMAParamsTimespan = "month"
	GetOptionsSMAParamsTimespanQuarter GetOptionsSMAParamsTimespan = "quarter"
	GetOptionsSMAParamsTimespanWeek    GetOptionsSMAParamsTimespan = "week"
	GetOptionsSMAParamsTimespanYear    GetOptionsSMAParamsTimespan = "year"
)

// Defines values for GetOptionsSMAParamsSeriesType.
const (
	GetOptionsSMAParamsSeriesTypeClose GetOptionsSMAParamsSeriesType = "close"
	GetOptionsSMAParamsSeriesTypeHigh  GetOptionsSMAParamsSeriesType = "high"
	GetOptionsSMAParamsSeriesTypeLow   GetOptionsSMAParamsSeriesType = "low"
	GetOptionsSMAParamsSeriesTypeOpen  GetOptionsSMAParamsSeriesType = "open"
)

// Defines values for GetOptionsSMAParamsOrder.
const (
	GetOptionsSMAParamsOrderAsc  GetOptionsSMAParamsOrder = "asc"
	GetOptionsSMAParamsOrderDesc GetOptionsSMAParamsOrder = "desc"
)

// Defines values for GetStocksSMAParamsTimespan.
const (
	GetStocksSMAParamsTimespanDay     GetStocksSMAParamsTimespan = "day"
	GetStocksSMAParamsTimespanHour    GetStocksSMAParamsTimespan = "hour"
	GetStocksSMAParamsTimespanMinute  GetStocksSMAParamsTimespan = "minute"
	GetStocksSMAParamsTimespanMonth   GetStocksSMAParamsTimespan = "month"
	GetStocksSMAParamsTimespanQuarter GetStocksSMAParamsTimespan = "quarter"
	GetStocksSMAParamsTimespanWeek    GetStocksSMAParamsTimespan = "week"
	GetStocksSMAParamsTimespanYear    GetStocksSMAParamsTimespan = "year"
)

// Defines values for GetStocksSMAParamsSeriesType.
const (
	GetStocksSMAParamsSeriesTypeClose GetStocksSMAParamsSeriesType = "close"
	GetStocksSMAParamsSeriesTypeHigh  GetStocksSMAParamsSeriesType = "high"
	GetStocksSMAParamsSeriesTypeLow   GetStocksSMAParamsSeriesType = "low"
	GetStocksSMAParamsSeriesTypeOpen  GetStocksSMAParamsSeriesType = "open"
)

// Defines values for GetStocksSMAParamsOrder.
const (
	GetStocksSMAParamsOrderAsc  GetStocksSMAParamsOrder = "asc"
	GetStocksSMAParamsOrderDesc GetStocksSMAParamsOrder = "desc"
)

// Defines values for GetV1ReferenceIposParamsIpoStatus.
const (
	GetV1ReferenceIposParamsIpoStatusDirectListingProcess GetV1ReferenceIposParamsIpoStatus = "direct_listing_process"
	GetV1ReferenceIposParamsIpoStatusHistory              GetV1ReferenceIposParamsIpoStatus = "history"
	GetV1ReferenceIposParamsIpoStatusNew                  GetV1ReferenceIposParamsIpoStatus = "new"
	GetV1ReferenceIposParamsIpoStatusPending              GetV1ReferenceIposParamsIpoStatus = "pending"
	GetV1ReferenceIposParamsIpoStatusPostponed            GetV1ReferenceIposParamsIpoStatus = "postponed"
	GetV1ReferenceIposParamsIpoStatusRumor                GetV1ReferenceIposParamsIpoStatus = "rumor"
	GetV1ReferenceIposParamsIpoStatusWithdrawn            GetV1ReferenceIposParamsIpoStatus = "withdrawn"
)

// Defines values for GetV1ReferenceIposParamsIpoStatusAnyOf.
const (
	GetV1ReferenceIposParamsIpoStatusAnyOfDirectListingProcess GetV1ReferenceIposParamsIpoStatusAnyOf = "direct_listing_process"
	GetV1ReferenceIposParamsIpoStatusAnyOfHistory              GetV1ReferenceIposParamsIpoStatusAnyOf = "history"
	GetV1ReferenceIposParamsIpoStatusAnyOfNew                  GetV1ReferenceIposParamsIpoStatusAnyOf = "new"
	GetV1ReferenceIposParamsIpoStatusAnyOfPending              GetV1ReferenceIposParamsIpoStatusAnyOf = "pending"
	GetV1ReferenceIposParamsIpoStatusAnyOfPostponed            GetV1ReferenceIposParamsIpoStatusAnyOf = "postponed"
	GetV1ReferenceIposParamsIpoStatusAnyOfRumor                GetV1ReferenceIposParamsIpoStatusAnyOf = "rumor"
	GetV1ReferenceIposParamsIpoStatusAnyOfWithdrawn            GetV1ReferenceIposParamsIpoStatusAnyOf = "withdrawn"
)

// Defines values for GetCryptoAggregatesParamsTimespan.
const (
	GetCryptoAggregatesParamsTimespanDay     GetCryptoAggregatesParamsTimespan = "day"
	GetCryptoAggregatesParamsTimespanHour    GetCryptoAggregatesParamsTimespan = "hour"
	GetCryptoAggregatesParamsTimespanMinute  GetCryptoAggregatesParamsTimespan = "minute"
	GetCryptoAggregatesParamsTimespanMonth   GetCryptoAggregatesParamsTimespan = "month"
	GetCryptoAggregatesParamsTimespanQuarter GetCryptoAggregatesParamsTimespan = "quarter"
	GetCryptoAggregatesParamsTimespanSecond  GetCryptoAggregatesParamsTimespan = "second"
	GetCryptoAggregatesParamsTimespanWeek    GetCryptoAggregatesParamsTimespan = "week"
	GetCryptoAggregatesParamsTimespanYear    GetCryptoAggregatesParamsTimespan = "year"
)

// Defines values for GetForexAggregatesParamsTimespan.
const (
	GetForexAggregatesParamsTimespanDay     GetForexAggregatesParamsTimespan = "day"
	GetForexAggregatesParamsTimespanHour    GetForexAggregatesParamsTimespan = "hour"
	GetForexAggregatesParamsTimespanMinute  GetForexAggregatesParamsTimespan = "minute"
	GetForexAggregatesParamsTimespanMonth   GetForexAggregatesParamsTimespan = "month"
	GetForexAggregatesParamsTimespanQuarter GetForexAggregatesParamsTimespan = "quarter"
	GetForexAggregatesParamsTimespanSecond  GetForexAggregatesParamsTimespan = "second"
	GetForexAggregatesParamsTimespanWeek    GetForexAggregatesParamsTimespan = "week"
	GetForexAggregatesParamsTimespanYear    GetForexAggregatesParamsTimespan = "year"
)

// Defines values for GetIndicesAggregatesParamsTimespan.
const (
	GetIndicesAggregatesParamsTimespanDay     GetIndicesAggregatesParamsTimespan = "day"
	GetIndicesAggregatesParamsTimespanHour    GetIndicesAggregatesParamsTimespan = "hour"
	GetIndicesAggregatesParamsTimespanMinute  GetIndicesAggregatesParamsTimespan = "minute"
	GetIndicesAggregatesParamsTimespanMonth   GetIndicesAggregatesParamsTimespan = "month"
	GetIndicesAggregatesParamsTimespanQuarter GetIndicesAggregatesParamsTimespan = "quarter"
	GetIndicesAggregatesParamsTimespanSecond  GetIndicesAggregatesParamsTimespan = "second"
	GetIndicesAggregatesParamsTimespanWeek    GetIndicesAggregatesParamsTimespan = "week"
	GetIndicesAggregatesParamsTimespanYear    GetIndicesAggregatesParamsTimespan = "year"
)

// Defines values for GetOptionsAggregatesParamsTimespan.
const (
	GetOptionsAggregatesParamsTimespanDay     GetOptionsAggregatesParamsTimespan = "day"
	GetOptionsAggregatesParamsTimespanHour    GetOptionsAggregatesParamsTimespan = "hour"
	GetOptionsAggregatesParamsTimespanMinute  GetOptionsAggregatesParamsTimespan = "minute"
	GetOptionsAggregatesParamsTimespanMonth   GetOptionsAggregatesParamsTimespan = "month"
	GetOptionsAggregatesParamsTimespanQuarter GetOptionsAggregatesParamsTimespan = "quarter"
	GetOptionsAggregatesParamsTimespanSecond  GetOptionsAggregatesParamsTimespan = "second"
	GetOptionsAggregatesParamsTimespanWeek    GetOptionsAggregatesParamsTimespan = "week"
	GetOptionsAggregatesParamsTimespanYear    GetOptionsAggregatesParamsTimespan = "year"
)

// Defines values for GetStocksAggregatesParamsTimespan.
const (
	Day     GetStocksAggregatesParamsTimespan = "day"
	Hour    GetStocksAggregatesParamsTimespan = "hour"
	Minute  GetStocksAggregatesParamsTimespan = "minute"
	Month   GetStocksAggregatesParamsTimespan = "month"
	Quarter GetStocksAggregatesParamsTimespan = "quarter"
	Second  GetStocksAggregatesParamsTimespan = "second"
	Week    GetStocksAggregatesParamsTimespan = "week"
	Year    GetStocksAggregatesParamsTimespan = "year"
)

// Defines values for ListNewsParamsOrder.
const (
	ListNewsParamsOrderAsc  ListNewsParamsOrder = "asc"
	ListNewsParamsOrderDesc ListNewsParamsOrder = "desc"
)

// Defines values for ListNewsParamsSort.
const (
	PublishedUtc ListNewsParamsSort = "published_utc"
)

// Defines values for GetCryptoSnapshotDirectionParamsDirection.
const (
	GetCryptoSnapshotDirectionParamsDirectionGainers GetCryptoSnapshotDirectionParamsDirection = "gainers"
	GetCryptoSnapshotDirectionParamsDirectionLosers  GetCryptoSnapshotDirectionParamsDirection = "losers"
)

// Defines values for GetForexSnapshotDirectionParamsDirection.
const (
	GetForexSnapshotDirectionParamsDirectionGainers GetForexSnapshotDirectionParamsDirection = "gainers"
	GetForexSnapshotDirectionParamsDirectionLosers  GetForexSnapshotDirectionParamsDirection = "losers"
)

// Defines values for GetStocksSnapshotDirectionParamsDirection.
const (
	Gainers GetStocksSnapshotDirectionParamsDirection = "gainers"
	Losers  GetStocksSnapshotDirectionParamsDirection = "losers"
)

// Defines values for GetForexQuotesParamsOrder.
const (
	GetForexQuotesParamsOrderAsc  GetForexQuotesParamsOrder = "asc"
	GetForexQuotesParamsOrderDesc GetForexQuotesParamsOrder = "desc"
)

// Defines values for GetForexQuotesParamsSort.
const (
	GetForexQuotesParamsSortTimestamp GetForexQuotesParamsSort = "timestamp"
)

// Defines values for GetOptionsQuotesParamsOrder.
const (
	GetOptionsQuotesParamsOrderAsc  GetOptionsQuotesParamsOrder = "asc"
	GetOptionsQuotesParamsOrderDesc GetOptionsQuotesParamsOrder = "desc"
)

// Defines values for GetOptionsQuotesParamsSort.
const (
	GetOptionsQuotesParamsSortTimestamp GetOptionsQuotesParamsSort = "timestamp"
)

// Defines values for GetStocksQuotesParamsOrder.
const (
	GetStocksQuotesParamsOrderAsc  GetStocksQuotesParamsOrder = "asc"
	GetStocksQuotesParamsOrderDesc GetStocksQuotesParamsOrder = "desc"
)

// Defines values for GetStocksQuotesParamsSort.
const (
	GetStocksQuotesParamsSortTimestamp GetStocksQuotesParamsSort = "timestamp"
)

// Defines values for ListConditionsParamsAssetClass.
const (
	ListConditionsParamsAssetClassCrypto  ListConditionsParamsAssetClass = "crypto"
	ListConditionsParamsAssetClassFx      ListConditionsParamsAssetClass = "fx"
	ListConditionsParamsAssetClassOptions ListConditionsParamsAssetClass = "options"
	ListConditionsParamsAssetClassStocks  ListConditionsParamsAssetClass = "stocks"
)

// Defines values for ListConditionsParamsDataType.
const (
	Bbo   ListConditionsParamsDataType = "bbo"
	Nbbo  ListConditionsParamsDataType = "nbbo"
	Trade ListConditionsParamsDataType = "trade"
)

// Defines values for ListConditionsParamsSip.
const (
	CTA  ListConditionsParamsSip = "CTA"
	OPRA ListConditionsParamsSip = "OPRA"
	UTP  ListConditionsParamsSip = "UTP"
)

// Defines values for ListConditionsParamsOrder.
const (
	ListConditionsParamsOrderAsc  ListConditionsParamsOrder = "asc"
	ListConditionsParamsOrderDesc ListConditionsParamsOrder = "desc"
)

// Defines values for ListConditionsParamsSort.
const (
	ListConditionsParamsSortAssetClass ListConditionsParamsSort = "asset_class"
	ListConditionsParamsSortDataTypes  ListConditionsParamsSort = "data_types"
	ListConditionsParamsSortId         ListConditionsParamsSort = "id"
	ListConditionsParamsSortLegacy     ListConditionsParamsSort = "legacy"
	ListConditionsParamsSortName       ListConditionsParamsSort = "name"
	ListConditionsParamsSortType       ListConditionsParamsSort = "type"
)

// Defines values for ListDividendsParamsFrequency.
const (
	ListDividendsParamsFrequencyN0  ListDividendsParamsFrequency = 0
	ListDividendsParamsFrequencyN1  ListDividendsParamsFrequency = 1
	ListDividendsParamsFrequencyN12 ListDividendsParamsFrequency = 12
	ListDividendsParamsFrequencyN2  ListDividendsParamsFrequency = 2
	ListDividendsParamsFrequencyN24 ListDividendsParamsFrequency = 24
	ListDividendsParamsFrequencyN4  ListDividendsParamsFrequency = 4
	ListDividendsParamsFrequencyN52 ListDividendsParamsFrequency = 52
)

// Defines values for ListDividendsParamsDividendType.
const (
	ListDividendsParamsDividendTypeCD ListDividendsParamsDividendType = "CD"
	ListDividendsParamsDividendTypeLT ListDividendsParamsDividendType = "LT"
	ListDividendsParamsDividendTypeSC ListDividendsParamsDividendType = "SC"
	ListDividendsParamsDividendTypeST ListDividendsParamsDividendType = "ST"
)

// Defines values for ListDividendsParamsOrder.
const (
	ListDividendsParamsOrderAsc  ListDividendsParamsOrder = "asc"
	ListDividendsParamsOrderDesc ListDividendsParamsOrder = "desc"
)

// Defines values for ListDividendsParamsSort.
const (
	ListDividendsParamsSortCashAmount      ListDividendsParamsSort = "cash_amount"
	ListDividendsParamsSortDeclarationDate ListDividendsParamsSort = "declaration_date"
	ListDividendsParamsSortExDividendDate  ListDividendsParamsSort = "ex_dividend_date"
	ListDividendsParamsSortPayDate         ListDividendsParamsSort = "pay_date"
	ListDividendsParamsSortRecordDate      ListDividendsParamsSort = "record_date"
	ListDividendsParamsSortTicker          ListDividendsParamsSort = "ticker"
)

// Defines values for ListExchangesParamsAssetClass.
const (
	ListExchangesParamsAssetClassCrypto  ListExchangesParamsAssetClass = "crypto"
	ListExchangesParamsAssetClassFutures ListExchangesParamsAssetClass = "futures"
	ListExchangesParamsAssetClassFx      ListExchangesParamsAssetClass = "fx"
	ListExchangesParamsAssetClassOptions ListExchangesParamsAssetClass = "options"
	ListExchangesParamsAssetClassStocks  ListExchangesParamsAssetClass = "stocks"
)

// Defines values for ListExchangesParamsLocale.
const (
	ListExchangesParamsLocaleGlobal ListExchangesParamsLocale = "global"
	ListExchangesParamsLocaleUs     ListExchangesParamsLocale = "us"
)

// Defines values for ListOptionsContractsParamsContractType.
const (
	ListOptionsContractsParamsContractTypeCall ListOptionsContractsParamsContractType = "call"
	ListOptionsContractsParamsContractTypePut  ListOptionsContractsParamsContractType = "put"
)

// Defines values for ListOptionsContractsParamsOrder.
const (
	ListOptionsContractsParamsOrderAsc  ListOptionsContractsParamsOrder = "asc"
	ListOptionsContractsParamsOrderDesc ListOptionsContractsParamsOrder = "desc"
)

// Defines values for ListOptionsContractsParamsSort.
const (
	ListOptionsContractsParamsSortExpirationDate   ListOptionsContractsParamsSort = "expiration_date"
	ListOptionsContractsParamsSortStrikePrice      ListOptionsContractsParamsSort = "strike_price"
	ListOptionsContractsParamsSortTicker           ListOptionsContractsParamsSort = "ticker"
	ListOptionsContractsParamsSortUnderlyingTicker ListOptionsContractsParamsSort = "underlying_ticker"
)

// Defines values for ListStockSplitsParamsOrder.
const (
	ListStockSplitsParamsOrderAsc  ListStockSplitsParamsOrder = "asc"
	ListStockSplitsParamsOrderDesc ListStockSplitsParamsOrder = "desc"
)

// Defines values for ListStockSplitsParamsSort.
const (
	ListStockSplitsParamsSortExecutionDate ListStockSplitsParamsSort = "execution_date"
	ListStockSplitsParamsSortTicker        ListStockSplitsParamsSort = "ticker"
)

// Defines values for ListTickersParamsType.
const (
	ListTickersParamsTypeADRC    ListTickersParamsType = "ADRC"
	ListTickersParamsTypeADRP    ListTickersParamsType = "ADRP"
	ListTickersParamsTypeADRR    ListTickersParamsType = "ADRR"
	ListTickersParamsTypeADRW    ListTickersParamsType = "ADRW"
	ListTickersParamsTypeAGEN    ListTickersParamsType = "AGEN"
	ListTickersParamsTypeBASKET  ListTickersParamsType = "BASKET"
	ListTickersParamsTypeBOND    ListTickersParamsType = "BOND"
	ListTickersParamsTypeCS      ListTickersParamsType = "CS"
	ListTickersParamsTypeEQLK    ListTickersParamsType = "EQLK"
	ListTickersParamsTypeETF     ListTickersParamsType = "ETF"
	ListTickersParamsTypeETN     ListTickersParamsType = "ETN"
	ListTickersParamsTypeFUND    ListTickersParamsType = "FUND"
	ListTickersParamsTypeGDR     ListTickersParamsType = "GDR"
	ListTickersParamsTypeINDEX   ListTickersParamsType = "INDEX"
	ListTickersParamsTypeLT      ListTickersParamsType = "LT"
	ListTickersParamsTypeNYRS    ListTickersParamsType = "NYRS"
	ListTickersParamsTypeOS      ListTickersParamsType = "OS"
	ListTickersParamsTypeOTHER   ListTickersParamsType = "OTHER"
	ListTickersParamsTypePFD     ListTickersParamsType = "PFD"
	ListTickersParamsTypeRIGHT   ListTickersParamsType = "RIGHT"
	ListTickersParamsTypeSP      ListTickersParamsType = "SP"
	ListTickersParamsTypeUNIT    ListTickersParamsType = "UNIT"
	ListTickersParamsTypeWARRANT ListTickersParamsType = "WARRANT"
)

// Defines values for ListTickersParamsMarket.
const (
	ListTickersParamsMarketCrypto  ListTickersParamsMarket = "crypto"
	ListTickersParamsMarketFx      ListTickersParamsMarket = "fx"
	ListTickersParamsMarketIndices ListTickersParamsMarket = "indices"
	ListTickersParamsMarketOtc     ListTickersParamsMarket = "otc"
	ListTickersParamsMarketStocks  ListTickersParamsMarket = "stocks"
)

// Defines values for ListTickersParamsOrder.
const (
	ListTickersParamsOrderAsc  ListTickersParamsOrder = "asc"
	ListTickersParamsOrderDesc ListTickersParamsOrder = "desc"
)

// Defines values for ListTickersParamsSort.
const (
	ListTickersParamsSortBaseCurrencyName   ListTickersParamsSort = "base_currency_name"
	ListTickersParamsSortBaseCurrencySymbol ListTickersParamsSort = "base_currency_symbol"
	ListTickersParamsSortCik                ListTickersParamsSort = "cik"
	ListTickersParamsSortCompositeFigi      ListTickersParamsSort = "composite_figi"
	ListTickersParamsSortCurrencyName       ListTickersParamsSort = "currency_name"
	ListTickersParamsSortCurrencySymbol     ListTickersParamsSort = "currency_symbol"
	ListTickersParamsSortDelistedUtc        ListTickersParamsSort = "delisted_utc"
	ListTickersParamsSortLastUpdatedUtc     ListTickersParamsSort = "last_updated_utc"
	ListTickersParamsSortLocale             ListTickersParamsSort = "locale"
	ListTickersParamsSortMarket             ListTickersParamsSort = "market"
	ListTickersParamsSortName               ListTickersParamsSort = "name"
	ListTickersParamsSortPrimaryExchange    ListTickersParamsSort = "primary_exchange"
	ListTickersParamsSortShareClassFigi     ListTickersParamsSort = "share_class_figi"
	ListTickersParamsSortTicker             ListTickersParamsSort = "ticker"
	ListTickersParamsSortType               ListTickersParamsSort = "type"
)

// Defines values for ListTickerTypesParamsAssetClass.
const (
	ListTickerTypesParamsAssetClassCrypto  ListTickerTypesParamsAssetClass = "crypto"
	ListTickerTypesParamsAssetClassFx      ListTickerTypesParamsAssetClass = "fx"
	ListTickerTypesParamsAssetClassIndices ListTickerTypesParamsAssetClass = "indices"
	ListTickerTypesParamsAssetClassOptions ListTickerTypesParamsAssetClass = "options"
	ListTickerTypesParamsAssetClassStocks  ListTickerTypesParamsAssetClass = "stocks"
)

// Defines values for ListTickerTypesParamsLocale.
const (
	ListTickerTypesParamsLocaleGlobal ListTickerTypesParamsLocale = "global"
	ListTickerTypesParamsLocaleUs     ListTickerTypesParamsLocale = "us"
)

// Defines values for GetSnapshotsParamsType.
const (
	Crypto  GetSnapshotsParamsType = "crypto"
	Fx      GetSnapshotsParamsType = "fx"
	Indices GetSnapshotsParamsType = "indices"
	Options GetSnapshotsParamsType = "options"
	Stocks  GetSnapshotsParamsType = "stocks"
)

// Defines values for GetSnapshotsParamsOrder.
const (
	GetSnapshotsParamsOrderAsc  GetSnapshotsParamsOrder = "asc"
	GetSnapshotsParamsOrderDesc GetSnapshotsParamsOrder = "desc"
)

// Defines values for GetSnapshotsParamsSort.
const (
	GetSnapshotsParamsSortTicker GetSnapshotsParamsSort = "ticker"
)

// Defines values for GetIndicesSnapshotParamsOrder.
const (
	GetIndicesSnapshotParamsOrderAsc  GetIndicesSnapshotParamsOrder = "asc"
	GetIndicesSnapshotParamsOrderDesc GetIndicesSnapshotParamsOrder = "desc"
)

// Defines values for GetIndicesSnapshotParamsSort.
const (
	GetIndicesSnapshotParamsSortTicker GetIndicesSnapshotParamsSort = "ticker"
)

// Defines values for GetOptionsChainParamsContractType.
const (
	GetOptionsChainParamsContractTypeCall GetOptionsChainParamsContractType = "call"
	GetOptionsChainParamsContractTypePut  GetOptionsChainParamsContractType = "put"
)

// Defines values for GetOptionsChainParamsOrder.
const (
	GetOptionsChainParamsOrderAsc  GetOptionsChainParamsOrder = "asc"
	GetOptionsChainParamsOrderDesc GetOptionsChainParamsOrder = "desc"
)

// Defines values for GetOptionsChainParamsSort.
const (
	GetOptionsChainParamsSortExpirationDate GetOptionsChainParamsSort = "expiration_date"
	GetOptionsChainParamsSortStrikePrice    GetOptionsChainParamsSort = "strike_price"
	GetOptionsChainParamsSortTicker         GetOptionsChainParamsSort = "ticker"
)

// Defines values for GetCryptoTradesParamsOrder.
const (
	GetCryptoTradesParamsOrderAsc  GetCryptoTradesParamsOrder = "asc"
	GetCryptoTradesParamsOrderDesc GetCryptoTradesParamsOrder = "desc"
)

// Defines values for GetCryptoTradesParamsSort.
const (
	GetCryptoTradesParamsSortTimestamp GetCryptoTradesParamsSort = "timestamp"
)

// Defines values for GetOptionsTradesParamsOrder.
const (
	GetOptionsTradesParamsOrderAsc  GetOptionsTradesParamsOrder = "asc"
	GetOptionsTradesParamsOrderDesc GetOptionsTradesParamsOrder = "desc"
)

// Defines values for GetOptionsTradesParamsSort.
const (
	GetOptionsTradesParamsSortTimestamp GetOptionsTradesParamsSort = "timestamp"
)

// Defines values for GetStocksTradesParamsOrder.
const (
	GetStocksTradesParamsOrderAsc  GetStocksTradesParamsOrder = "asc"
	GetStocksTradesParamsOrderDesc GetStocksTradesParamsOrder = "desc"
)

// Defines values for GetStocksTradesParamsSort.
const (
	GetStocksTradesParamsSortTimestamp GetStocksTradesParamsSort = "timestamp"
)

// Defines values for ListFinancialsParamsTimeframe.
const (
	Annual    ListFinancialsParamsTimeframe = "annual"
	Quarterly ListFinancialsParamsTimeframe = "quarterly"
	Ttm       ListFinancialsParamsTimeframe = "ttm"
)

// Defines values for ListFinancialsParamsOrder.
const (
	ListFinancialsParamsOrderAsc  ListFinancialsParamsOrder = "asc"
	ListFinancialsParamsOrderDesc ListFinancialsParamsOrder = "desc"
)

// Defines values for ListFinancialsParamsSort.
const (
	FilingDate         ListFinancialsParamsSort = "filing_date"
	PeriodOfReportDate ListFinancialsParamsSort = "period_of_report_date"
)

// Defines values for ListIPOsParamsIpoStatus.
const (
	DirectListingProcess ListIPOsParamsIpoStatus = "direct_listing_process"
	History              ListIPOsParamsIpoStatus = "history"
	New                  ListIPOsParamsIpoStatus = "new"
	Pending              ListIPOsParamsIpoStatus = "pending"
	Postponed            ListIPOsParamsIpoStatus = "postponed"
	Rumor                ListIPOsParamsIpoStatus = "rumor"
	Withdrawn            ListIPOsParamsIpoStatus = "withdrawn"
)

// Defines values for ListIPOsParamsOrder.
const (
	Asc  ListIPOsParamsOrder = "asc"
	Desc ListIPOsParamsOrder = "desc"
)

// Defines values for ListIPOsParamsSort.
const (
	AnnouncedDate       ListIPOsParamsSort = "announced_date"
	CurrencyCode        ListIPOsParamsSort = "currency_code"
	FinalIssuePrice     ListIPOsParamsSort = "final_issue_price"
	HighestOfferPrice   ListIPOsParamsSort = "highest_offer_price"
	IpoStatus           ListIPOsParamsSort = "ipo_status"
	Isin                ListIPOsParamsSort = "isin"
	IssuerName          ListIPOsParamsSort = "issuer_name"
	LastUpdated         ListIPOsParamsSort = "last_updated"
	ListingDate         ListIPOsParamsSort = "listing_date"
	LotSize             ListIPOsParamsSort = "lot_size"
	LowestOfferPrice    ListIPOsParamsSort = "lowest_offer_price"
	MaxSharesOffered    ListIPOsParamsSort = "max_shares_offered"
	MinSharesOffered    ListIPOsParamsSort = "min_shares_offered"
	PrimaryExchange     ListIPOsParamsSort = "primary_exchange"
	SecurityDescription ListIPOsParamsSort = "security_description"
	SecurityType        ListIPOsParamsSort = "security_type"
	SharesOutstanding   ListIPOsParamsSort = "shares_outstanding"
	Ticker              ListIPOsParamsSort = "ticker"
	TotalOfferSize      ListIPOsParamsSort = "total_offer_size"
	UsCode              ListIPOsParamsSort = "us_code"
)

// GetBenzingaV1AnalystInsightsParams defines parameters for GetBenzingaV1AnalystInsights.
type GetBenzingaV1AnalystInsightsParams struct {
	// Date The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Ticker The stock symbol of the company being rated.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdated *string `form:"last_updated,omitempty" json:"last_updated,omitempty"`

	// LastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGt *string `form:"last_updated.gt,omitempty" json:"last_updated.gt,omitempty"`

	// LastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGte *string `form:"last_updated.gte,omitempty" json:"last_updated.gte,omitempty"`

	// LastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLt *string `form:"last_updated.lt,omitempty" json:"last_updated.lt,omitempty"`

	// LastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLte *string `form:"last_updated.lte,omitempty" json:"last_updated.lte,omitempty"`

	// Firm The name of the research firm or investment bank issuing the rating.
	Firm *string `form:"firm,omitempty" json:"firm,omitempty"`

	// FirmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FirmAnyOf *string `form:"firm.any_of,omitempty" json:"firm.any_of,omitempty"`

	// FirmGt Filter greater than the value.
	FirmGt *string `form:"firm.gt,omitempty" json:"firm.gt,omitempty"`

	// FirmGte Filter greater than or equal to the value.
	FirmGte *string `form:"firm.gte,omitempty" json:"firm.gte,omitempty"`

	// FirmLt Filter less than the value.
	FirmLt *string `form:"firm.lt,omitempty" json:"firm.lt,omitempty"`

	// FirmLte Filter less than or equal to the value.
	FirmLte *string `form:"firm.lte,omitempty" json:"firm.lte,omitempty"`

	// RatingAction The description of the change in rating from the firm's last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
	RatingAction *string `form:"rating_action,omitempty" json:"rating_action,omitempty"`

	// RatingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	RatingActionAnyOf *string `form:"rating_action.any_of,omitempty" json:"rating_action.any_of,omitempty"`

	// RatingActionGt Filter greater than the value.
	RatingActionGt *string `form:"rating_action.gt,omitempty" json:"rating_action.gt,omitempty"`

	// RatingActionGte Filter greater than or equal to the value.
	RatingActionGte *string `form:"rating_action.gte,omitempty" json:"rating_action.gte,omitempty"`

	// RatingActionLt Filter less than the value.
	RatingActionLt *string `form:"rating_action.lt,omitempty" json:"rating_action.lt,omitempty"`

	// RatingActionLte Filter less than or equal to the value.
	RatingActionLte *string `form:"rating_action.lte,omitempty" json:"rating_action.lte,omitempty"`

	// BenzingaFirmId The identifer used by Benzinga for the firm record.
	BenzingaFirmId *string `form:"benzinga_firm_id,omitempty" json:"benzinga_firm_id,omitempty"`

	// BenzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaFirmIdAnyOf *string `form:"benzinga_firm_id.any_of,omitempty" json:"benzinga_firm_id.any_of,omitempty"`

	// BenzingaFirmIdGt Filter greater than the value.
	BenzingaFirmIdGt *string `form:"benzinga_firm_id.gt,omitempty" json:"benzinga_firm_id.gt,omitempty"`

	// BenzingaFirmIdGte Filter greater than or equal to the value.
	BenzingaFirmIdGte *string `form:"benzinga_firm_id.gte,omitempty" json:"benzinga_firm_id.gte,omitempty"`

	// BenzingaFirmIdLt Filter less than the value.
	BenzingaFirmIdLt *string `form:"benzinga_firm_id.lt,omitempty" json:"benzinga_firm_id.lt,omitempty"`

	// BenzingaFirmIdLte Filter less than or equal to the value.
	BenzingaFirmIdLte *string `form:"benzinga_firm_id.lte,omitempty" json:"benzinga_firm_id.lte,omitempty"`

	// BenzingaRatingId The identifier used by Benzinga for the rating record.
	BenzingaRatingId *string `form:"benzinga_rating_id,omitempty" json:"benzinga_rating_id,omitempty"`

	// BenzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaRatingIdAnyOf *string `form:"benzinga_rating_id.any_of,omitempty" json:"benzinga_rating_id.any_of,omitempty"`

	// BenzingaRatingIdGt Filter greater than the value.
	BenzingaRatingIdGt *string `form:"benzinga_rating_id.gt,omitempty" json:"benzinga_rating_id.gt,omitempty"`

	// BenzingaRatingIdGte Filter greater than or equal to the value.
	BenzingaRatingIdGte *string `form:"benzinga_rating_id.gte,omitempty" json:"benzinga_rating_id.gte,omitempty"`

	// BenzingaRatingIdLt Filter less than the value.
	BenzingaRatingIdLt *string `form:"benzinga_rating_id.lt,omitempty" json:"benzinga_rating_id.lt,omitempty"`

	// BenzingaRatingIdLte Filter less than or equal to the value.
	BenzingaRatingIdLte *string `form:"benzinga_rating_id.lte,omitempty" json:"benzinga_rating_id.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'last_updated' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV1AnalystsParams defines parameters for GetBenzingaV1Analysts.
type GetBenzingaV1AnalystsParams struct {
	// BenzingaId The identifier used by Benzinga for this record.
	BenzingaId *string `form:"benzinga_id,omitempty" json:"benzinga_id,omitempty"`

	// BenzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaIdAnyOf *string `form:"benzinga_id.any_of,omitempty" json:"benzinga_id.any_of,omitempty"`

	// BenzingaIdGt Filter greater than the value.
	BenzingaIdGt *string `form:"benzinga_id.gt,omitempty" json:"benzinga_id.gt,omitempty"`

	// BenzingaIdGte Filter greater than or equal to the value.
	BenzingaIdGte *string `form:"benzinga_id.gte,omitempty" json:"benzinga_id.gte,omitempty"`

	// BenzingaIdLt Filter less than the value.
	BenzingaIdLt *string `form:"benzinga_id.lt,omitempty" json:"benzinga_id.lt,omitempty"`

	// BenzingaIdLte Filter less than or equal to the value.
	BenzingaIdLte *string `form:"benzinga_id.lte,omitempty" json:"benzinga_id.lte,omitempty"`

	// BenzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank.
	BenzingaFirmId *string `form:"benzinga_firm_id,omitempty" json:"benzinga_firm_id,omitempty"`

	// BenzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaFirmIdAnyOf *string `form:"benzinga_firm_id.any_of,omitempty" json:"benzinga_firm_id.any_of,omitempty"`

	// BenzingaFirmIdGt Filter greater than the value.
	BenzingaFirmIdGt *string `form:"benzinga_firm_id.gt,omitempty" json:"benzinga_firm_id.gt,omitempty"`

	// BenzingaFirmIdGte Filter greater than or equal to the value.
	BenzingaFirmIdGte *string `form:"benzinga_firm_id.gte,omitempty" json:"benzinga_firm_id.gte,omitempty"`

	// BenzingaFirmIdLt Filter less than the value.
	BenzingaFirmIdLt *string `form:"benzinga_firm_id.lt,omitempty" json:"benzinga_firm_id.lt,omitempty"`

	// BenzingaFirmIdLte Filter less than or equal to the value.
	BenzingaFirmIdLte *string `form:"benzinga_firm_id.lte,omitempty" json:"benzinga_firm_id.lte,omitempty"`

	// FirmName The name of the research firm or investment bank issuing the ratings.
	FirmName *string `form:"firm_name,omitempty" json:"firm_name,omitempty"`

	// FirmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FirmNameAnyOf *string `form:"firm_name.any_of,omitempty" json:"firm_name.any_of,omitempty"`

	// FirmNameGt Filter greater than the value.
	FirmNameGt *string `form:"firm_name.gt,omitempty" json:"firm_name.gt,omitempty"`

	// FirmNameGte Filter greater than or equal to the value.
	FirmNameGte *string `form:"firm_name.gte,omitempty" json:"firm_name.gte,omitempty"`

	// FirmNameLt Filter less than the value.
	FirmNameLt *string `form:"firm_name.lt,omitempty" json:"firm_name.lt,omitempty"`

	// FirmNameLte Filter less than or equal to the value.
	FirmNameLte *string `form:"firm_name.lte,omitempty" json:"firm_name.lte,omitempty"`

	// FullName The full name of the analyst associated with the ratings.
	FullName *string `form:"full_name,omitempty" json:"full_name,omitempty"`

	// FullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FullNameAnyOf *string `form:"full_name.any_of,omitempty" json:"full_name.any_of,omitempty"`

	// FullNameGt Filter greater than the value.
	FullNameGt *string `form:"full_name.gt,omitempty" json:"full_name.gt,omitempty"`

	// FullNameGte Filter greater than or equal to the value.
	FullNameGte *string `form:"full_name.gte,omitempty" json:"full_name.gte,omitempty"`

	// FullNameLt Filter less than the value.
	FullNameLt *string `form:"full_name.lt,omitempty" json:"full_name.lt,omitempty"`

	// FullNameLte Filter less than or equal to the value.
	FullNameLte *string `form:"full_name.lte,omitempty" json:"full_name.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'full_name' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV1BullsBearsSayParams defines parameters for GetBenzingaV1BullsBearsSay.
type GetBenzingaV1BullsBearsSayParams struct {
	// Ticker The stock ticker symbol for the company associated with the bull and bear case summaries.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// BenzingaId The unique identifier used by Benzinga for this bull/bear case record.
	BenzingaId *string `form:"benzinga_id,omitempty" json:"benzinga_id,omitempty"`

	// BenzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaIdAnyOf *string `form:"benzinga_id.any_of,omitempty" json:"benzinga_id.any_of,omitempty"`

	// BenzingaIdGt Filter greater than the value.
	BenzingaIdGt *string `form:"benzinga_id.gt,omitempty" json:"benzinga_id.gt,omitempty"`

	// BenzingaIdGte Filter greater than or equal to the value.
	BenzingaIdGte *string `form:"benzinga_id.gte,omitempty" json:"benzinga_id.gte,omitempty"`

	// BenzingaIdLt Filter less than the value.
	BenzingaIdLt *string `form:"benzinga_id.lt,omitempty" json:"benzinga_id.lt,omitempty"`

	// BenzingaIdLte Filter less than or equal to the value.
	BenzingaIdLte *string `form:"benzinga_id.lte,omitempty" json:"benzinga_id.lte,omitempty"`

	// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the bull/bear case was last updated in the system. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdated *string `form:"last_updated,omitempty" json:"last_updated,omitempty"`

	// LastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGt *string `form:"last_updated.gt,omitempty" json:"last_updated.gt,omitempty"`

	// LastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGte *string `form:"last_updated.gte,omitempty" json:"last_updated.gte,omitempty"`

	// LastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLt *string `form:"last_updated.lt,omitempty" json:"last_updated.lt,omitempty"`

	// LastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLte *string `form:"last_updated.lte,omitempty" json:"last_updated.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV1ConsensusRatingsParams defines parameters for GetBenzingaV1ConsensusRatings.
type GetBenzingaV1ConsensusRatingsParams struct {
	// Date The date range to aggregate analyst ratings over. For example, date.gte=2024-10-01 and date.lt=2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBenzingaV1EarningsParams defines parameters for GetBenzingaV1Earnings.
type GetBenzingaV1EarningsParams struct {
	// Date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Ticker The stock symbol of the company reporting earnings.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
	Importance *int64 `form:"importance,omitempty" json:"importance,omitempty"`

	// ImportanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
	ImportanceAnyOf *string `form:"importance.any_of,omitempty" json:"importance.any_of,omitempty"`

	// ImportanceGt Filter greater than the value. Value must be an integer.
	ImportanceGt *int64 `form:"importance.gt,omitempty" json:"importance.gt,omitempty"`

	// ImportanceGte Filter greater than or equal to the value. Value must be an integer.
	ImportanceGte *int64 `form:"importance.gte,omitempty" json:"importance.gte,omitempty"`

	// ImportanceLt Filter less than the value. Value must be an integer.
	ImportanceLt *int64 `form:"importance.lt,omitempty" json:"importance.lt,omitempty"`

	// ImportanceLte Filter less than or equal to the value. Value must be an integer.
	ImportanceLte *int64 `form:"importance.lte,omitempty" json:"importance.lte,omitempty"`

	// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdated *string `form:"last_updated,omitempty" json:"last_updated,omitempty"`

	// LastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedAnyOf *string `form:"last_updated.any_of,omitempty" json:"last_updated.any_of,omitempty"`

	// LastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGt *string `form:"last_updated.gt,omitempty" json:"last_updated.gt,omitempty"`

	// LastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGte *string `form:"last_updated.gte,omitempty" json:"last_updated.gte,omitempty"`

	// LastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLt *string `form:"last_updated.lt,omitempty" json:"last_updated.lt,omitempty"`

	// LastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLte *string `form:"last_updated.lte,omitempty" json:"last_updated.lte,omitempty"`

	// DateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
	DateStatus *string `form:"date_status,omitempty" json:"date_status,omitempty"`

	// DateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateStatusAnyOf *string `form:"date_status.any_of,omitempty" json:"date_status.any_of,omitempty"`

	// DateStatusGt Filter greater than the value.
	DateStatusGt *string `form:"date_status.gt,omitempty" json:"date_status.gt,omitempty"`

	// DateStatusGte Filter greater than or equal to the value.
	DateStatusGte *string `form:"date_status.gte,omitempty" json:"date_status.gte,omitempty"`

	// DateStatusLt Filter less than the value.
	DateStatusLt *string `form:"date_status.lt,omitempty" json:"date_status.lt,omitempty"`

	// DateStatusLte Filter less than or equal to the value.
	DateStatusLte *string `form:"date_status.lte,omitempty" json:"date_status.lte,omitempty"`

	// EpsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number.
	EpsSurprisePercent *float64 `form:"eps_surprise_percent,omitempty" json:"eps_surprise_percent,omitempty"`

	// EpsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
	EpsSurprisePercentAnyOf *string `form:"eps_surprise_percent.any_of,omitempty" json:"eps_surprise_percent.any_of,omitempty"`

	// EpsSurprisePercentGt Filter greater than the value. Value must be a floating point number.
	EpsSurprisePercentGt *float64 `form:"eps_surprise_percent.gt,omitempty" json:"eps_surprise_percent.gt,omitempty"`

	// EpsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number.
	EpsSurprisePercentGte *float64 `form:"eps_surprise_percent.gte,omitempty" json:"eps_surprise_percent.gte,omitempty"`

	// EpsSurprisePercentLt Filter less than the value. Value must be a floating point number.
	EpsSurprisePercentLt *float64 `form:"eps_surprise_percent.lt,omitempty" json:"eps_surprise_percent.lt,omitempty"`

	// EpsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number.
	EpsSurprisePercentLte *float64 `form:"eps_surprise_percent.lte,omitempty" json:"eps_surprise_percent.lte,omitempty"`

	// RevenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number.
	RevenueSurprisePercent *float64 `form:"revenue_surprise_percent,omitempty" json:"revenue_surprise_percent,omitempty"`

	// RevenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
	RevenueSurprisePercentAnyOf *string `form:"revenue_surprise_percent.any_of,omitempty" json:"revenue_surprise_percent.any_of,omitempty"`

	// RevenueSurprisePercentGt Filter greater than the value. Value must be a floating point number.
	RevenueSurprisePercentGt *float64 `form:"revenue_surprise_percent.gt,omitempty" json:"revenue_surprise_percent.gt,omitempty"`

	// RevenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number.
	RevenueSurprisePercentGte *float64 `form:"revenue_surprise_percent.gte,omitempty" json:"revenue_surprise_percent.gte,omitempty"`

	// RevenueSurprisePercentLt Filter less than the value. Value must be a floating point number.
	RevenueSurprisePercentLt *float64 `form:"revenue_surprise_percent.lt,omitempty" json:"revenue_surprise_percent.lt,omitempty"`

	// RevenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number.
	RevenueSurprisePercentLte *float64 `form:"revenue_surprise_percent.lte,omitempty" json:"revenue_surprise_percent.lte,omitempty"`

	// FiscalYear The fiscal year in which the earnings period falls. Value must be an integer.
	FiscalYear *int64 `form:"fiscal_year,omitempty" json:"fiscal_year,omitempty"`

	// FiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
	FiscalYearAnyOf *string `form:"fiscal_year.any_of,omitempty" json:"fiscal_year.any_of,omitempty"`

	// FiscalYearGt Filter greater than the value. Value must be an integer.
	FiscalYearGt *int64 `form:"fiscal_year.gt,omitempty" json:"fiscal_year.gt,omitempty"`

	// FiscalYearGte Filter greater than or equal to the value. Value must be an integer.
	FiscalYearGte *int64 `form:"fiscal_year.gte,omitempty" json:"fiscal_year.gte,omitempty"`

	// FiscalYearLt Filter less than the value. Value must be an integer.
	FiscalYearLt *int64 `form:"fiscal_year.lt,omitempty" json:"fiscal_year.lt,omitempty"`

	// FiscalYearLte Filter less than or equal to the value. Value must be an integer.
	FiscalYearLte *int64 `form:"fiscal_year.lte,omitempty" json:"fiscal_year.lte,omitempty"`

	// FiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
	FiscalPeriod *string `form:"fiscal_period,omitempty" json:"fiscal_period,omitempty"`

	// FiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FiscalPeriodAnyOf *string `form:"fiscal_period.any_of,omitempty" json:"fiscal_period.any_of,omitempty"`

	// FiscalPeriodGt Filter greater than the value.
	FiscalPeriodGt *string `form:"fiscal_period.gt,omitempty" json:"fiscal_period.gt,omitempty"`

	// FiscalPeriodGte Filter greater than or equal to the value.
	FiscalPeriodGte *string `form:"fiscal_period.gte,omitempty" json:"fiscal_period.gte,omitempty"`

	// FiscalPeriodLt Filter less than the value.
	FiscalPeriodLt *string `form:"fiscal_period.lt,omitempty" json:"fiscal_period.lt,omitempty"`

	// FiscalPeriodLte Filter less than or equal to the value.
	FiscalPeriodLte *string `form:"fiscal_period.lte,omitempty" json:"fiscal_period.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'last_updated' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV1FirmsParams defines parameters for GetBenzingaV1Firms.
type GetBenzingaV1FirmsParams struct {
	// BenzingaId The identifer used by Benzinga for this record.
	BenzingaId *string `form:"benzinga_id,omitempty" json:"benzinga_id,omitempty"`

	// BenzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaIdAnyOf *string `form:"benzinga_id.any_of,omitempty" json:"benzinga_id.any_of,omitempty"`

	// BenzingaIdGt Filter greater than the value.
	BenzingaIdGt *string `form:"benzinga_id.gt,omitempty" json:"benzinga_id.gt,omitempty"`

	// BenzingaIdGte Filter greater than or equal to the value.
	BenzingaIdGte *string `form:"benzinga_id.gte,omitempty" json:"benzinga_id.gte,omitempty"`

	// BenzingaIdLt Filter less than the value.
	BenzingaIdLt *string `form:"benzinga_id.lt,omitempty" json:"benzinga_id.lt,omitempty"`

	// BenzingaIdLte Filter less than or equal to the value.
	BenzingaIdLte *string `form:"benzinga_id.lte,omitempty" json:"benzinga_id.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'name' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV1GuidanceParams defines parameters for GetBenzingaV1Guidance.
type GetBenzingaV1GuidanceParams struct {
	// Date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Ticker The stock symbol of the company issuing guidance.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are 'primary' (the emphasized figure) and 'secondary' (a supporting or alternate figure)
	Positioning *string `form:"positioning,omitempty" json:"positioning,omitempty"`

	// PositioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	PositioningAnyOf *string `form:"positioning.any_of,omitempty" json:"positioning.any_of,omitempty"`

	// PositioningGt Filter greater than the value.
	PositioningGt *string `form:"positioning.gt,omitempty" json:"positioning.gt,omitempty"`

	// PositioningGte Filter greater than or equal to the value.
	PositioningGte *string `form:"positioning.gte,omitempty" json:"positioning.gte,omitempty"`

	// PositioningLt Filter less than the value.
	PositioningLt *string `form:"positioning.lt,omitempty" json:"positioning.lt,omitempty"`

	// PositioningLte Filter less than or equal to the value.
	PositioningLte *string `form:"positioning.lte,omitempty" json:"positioning.lte,omitempty"`

	// Importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
	Importance *int64 `form:"importance,omitempty" json:"importance,omitempty"`

	// ImportanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
	ImportanceAnyOf *string `form:"importance.any_of,omitempty" json:"importance.any_of,omitempty"`

	// ImportanceGt Filter greater than the value. Value must be an integer.
	ImportanceGt *int64 `form:"importance.gt,omitempty" json:"importance.gt,omitempty"`

	// ImportanceGte Filter greater than or equal to the value. Value must be an integer.
	ImportanceGte *int64 `form:"importance.gte,omitempty" json:"importance.gte,omitempty"`

	// ImportanceLt Filter less than the value. Value must be an integer.
	ImportanceLt *int64 `form:"importance.lt,omitempty" json:"importance.lt,omitempty"`

	// ImportanceLte Filter less than or equal to the value. Value must be an integer.
	ImportanceLte *int64 `form:"importance.lte,omitempty" json:"importance.lte,omitempty"`

	// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
	LastUpdated *string `form:"last_updated,omitempty" json:"last_updated,omitempty"`

	// LastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	LastUpdatedAnyOf *string `form:"last_updated.any_of,omitempty" json:"last_updated.any_of,omitempty"`

	// LastUpdatedGt Filter greater than the value.
	LastUpdatedGt *string `form:"last_updated.gt,omitempty" json:"last_updated.gt,omitempty"`

	// LastUpdatedGte Filter greater than or equal to the value.
	LastUpdatedGte *string `form:"last_updated.gte,omitempty" json:"last_updated.gte,omitempty"`

	// LastUpdatedLt Filter less than the value.
	LastUpdatedLt *string `form:"last_updated.lt,omitempty" json:"last_updated.lt,omitempty"`

	// LastUpdatedLte Filter less than or equal to the value.
	LastUpdatedLte *string `form:"last_updated.lte,omitempty" json:"last_updated.lte,omitempty"`

	// FiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
	FiscalYear *int64 `form:"fiscal_year,omitempty" json:"fiscal_year,omitempty"`

	// FiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
	FiscalYearAnyOf *string `form:"fiscal_year.any_of,omitempty" json:"fiscal_year.any_of,omitempty"`

	// FiscalYearGt Filter greater than the value. Value must be an integer.
	FiscalYearGt *int64 `form:"fiscal_year.gt,omitempty" json:"fiscal_year.gt,omitempty"`

	// FiscalYearGte Filter greater than or equal to the value. Value must be an integer.
	FiscalYearGte *int64 `form:"fiscal_year.gte,omitempty" json:"fiscal_year.gte,omitempty"`

	// FiscalYearLt Filter less than the value. Value must be an integer.
	FiscalYearLt *int64 `form:"fiscal_year.lt,omitempty" json:"fiscal_year.lt,omitempty"`

	// FiscalYearLte Filter less than or equal to the value. Value must be an integer.
	FiscalYearLte *int64 `form:"fiscal_year.lte,omitempty" json:"fiscal_year.lte,omitempty"`

	// FiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
	FiscalPeriod *string `form:"fiscal_period,omitempty" json:"fiscal_period,omitempty"`

	// FiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FiscalPeriodAnyOf *string `form:"fiscal_period.any_of,omitempty" json:"fiscal_period.any_of,omitempty"`

	// FiscalPeriodGt Filter greater than the value.
	FiscalPeriodGt *string `form:"fiscal_period.gt,omitempty" json:"fiscal_period.gt,omitempty"`

	// FiscalPeriodGte Filter greater than or equal to the value.
	FiscalPeriodGte *string `form:"fiscal_period.gte,omitempty" json:"fiscal_period.gte,omitempty"`

	// FiscalPeriodLt Filter less than the value.
	FiscalPeriodLt *string `form:"fiscal_period.lt,omitempty" json:"fiscal_period.lt,omitempty"`

	// FiscalPeriodLte Filter less than or equal to the value.
	FiscalPeriodLte *string `form:"fiscal_period.lte,omitempty" json:"fiscal_period.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV1RatingsParams defines parameters for GetBenzingaV1Ratings.
type GetBenzingaV1RatingsParams struct {
	// Date The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Ticker The stock symbol of the company being rated.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
	Importance *int64 `form:"importance,omitempty" json:"importance,omitempty"`

	// ImportanceGt Filter greater than the value. Value must be an integer.
	ImportanceGt *int64 `form:"importance.gt,omitempty" json:"importance.gt,omitempty"`

	// ImportanceGte Filter greater than or equal to the value. Value must be an integer.
	ImportanceGte *int64 `form:"importance.gte,omitempty" json:"importance.gte,omitempty"`

	// ImportanceLt Filter less than the value. Value must be an integer.
	ImportanceLt *int64 `form:"importance.lt,omitempty" json:"importance.lt,omitempty"`

	// ImportanceLte Filter less than or equal to the value. Value must be an integer.
	ImportanceLte *int64 `form:"importance.lte,omitempty" json:"importance.lte,omitempty"`

	// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdated *string `form:"last_updated,omitempty" json:"last_updated,omitempty"`

	// LastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGt *string `form:"last_updated.gt,omitempty" json:"last_updated.gt,omitempty"`

	// LastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedGte *string `form:"last_updated.gte,omitempty" json:"last_updated.gte,omitempty"`

	// LastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLt *string `form:"last_updated.lt,omitempty" json:"last_updated.lt,omitempty"`

	// LastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	LastUpdatedLte *string `form:"last_updated.lte,omitempty" json:"last_updated.lte,omitempty"`

	// RatingAction The description of the change in rating from the firm's last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
	RatingAction *string `form:"rating_action,omitempty" json:"rating_action,omitempty"`

	// RatingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	RatingActionAnyOf *string `form:"rating_action.any_of,omitempty" json:"rating_action.any_of,omitempty"`

	// RatingActionGt Filter greater than the value.
	RatingActionGt *string `form:"rating_action.gt,omitempty" json:"rating_action.gt,omitempty"`

	// RatingActionGte Filter greater than or equal to the value.
	RatingActionGte *string `form:"rating_action.gte,omitempty" json:"rating_action.gte,omitempty"`

	// RatingActionLt Filter less than the value.
	RatingActionLt *string `form:"rating_action.lt,omitempty" json:"rating_action.lt,omitempty"`

	// RatingActionLte Filter less than or equal to the value.
	RatingActionLte *string `form:"rating_action.lte,omitempty" json:"rating_action.lte,omitempty"`

	// PriceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
	PriceTargetAction *string `form:"price_target_action,omitempty" json:"price_target_action,omitempty"`

	// PriceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	PriceTargetActionAnyOf *string `form:"price_target_action.any_of,omitempty" json:"price_target_action.any_of,omitempty"`

	// PriceTargetActionGt Filter greater than the value.
	PriceTargetActionGt *string `form:"price_target_action.gt,omitempty" json:"price_target_action.gt,omitempty"`

	// PriceTargetActionGte Filter greater than or equal to the value.
	PriceTargetActionGte *string `form:"price_target_action.gte,omitempty" json:"price_target_action.gte,omitempty"`

	// PriceTargetActionLt Filter less than the value.
	PriceTargetActionLt *string `form:"price_target_action.lt,omitempty" json:"price_target_action.lt,omitempty"`

	// PriceTargetActionLte Filter less than or equal to the value.
	PriceTargetActionLte *string `form:"price_target_action.lte,omitempty" json:"price_target_action.lte,omitempty"`

	// BenzingaId The identifer used by Benzinga for this record.
	BenzingaId *string `form:"benzinga_id,omitempty" json:"benzinga_id,omitempty"`

	// BenzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaIdAnyOf *string `form:"benzinga_id.any_of,omitempty" json:"benzinga_id.any_of,omitempty"`

	// BenzingaIdGt Filter greater than the value.
	BenzingaIdGt *string `form:"benzinga_id.gt,omitempty" json:"benzinga_id.gt,omitempty"`

	// BenzingaIdGte Filter greater than or equal to the value.
	BenzingaIdGte *string `form:"benzinga_id.gte,omitempty" json:"benzinga_id.gte,omitempty"`

	// BenzingaIdLt Filter less than the value.
	BenzingaIdLt *string `form:"benzinga_id.lt,omitempty" json:"benzinga_id.lt,omitempty"`

	// BenzingaIdLte Filter less than or equal to the value.
	BenzingaIdLte *string `form:"benzinga_id.lte,omitempty" json:"benzinga_id.lte,omitempty"`

	// BenzingaAnalystId The identifer used by Benzinga for this analyst.
	BenzingaAnalystId *string `form:"benzinga_analyst_id,omitempty" json:"benzinga_analyst_id,omitempty"`

	// BenzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaAnalystIdAnyOf *string `form:"benzinga_analyst_id.any_of,omitempty" json:"benzinga_analyst_id.any_of,omitempty"`

	// BenzingaAnalystIdGt Filter greater than the value.
	BenzingaAnalystIdGt *string `form:"benzinga_analyst_id.gt,omitempty" json:"benzinga_analyst_id.gt,omitempty"`

	// BenzingaAnalystIdGte Filter greater than or equal to the value.
	BenzingaAnalystIdGte *string `form:"benzinga_analyst_id.gte,omitempty" json:"benzinga_analyst_id.gte,omitempty"`

	// BenzingaAnalystIdLt Filter less than the value.
	BenzingaAnalystIdLt *string `form:"benzinga_analyst_id.lt,omitempty" json:"benzinga_analyst_id.lt,omitempty"`

	// BenzingaAnalystIdLte Filter less than or equal to the value.
	BenzingaAnalystIdLte *string `form:"benzinga_analyst_id.lte,omitempty" json:"benzinga_analyst_id.lte,omitempty"`

	// BenzingaFirmId The identifer used by Benzinga for this firm.
	BenzingaFirmId *string `form:"benzinga_firm_id,omitempty" json:"benzinga_firm_id,omitempty"`

	// BenzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	BenzingaFirmIdAnyOf *string `form:"benzinga_firm_id.any_of,omitempty" json:"benzinga_firm_id.any_of,omitempty"`

	// BenzingaFirmIdGt Filter greater than the value.
	BenzingaFirmIdGt *string `form:"benzinga_firm_id.gt,omitempty" json:"benzinga_firm_id.gt,omitempty"`

	// BenzingaFirmIdGte Filter greater than or equal to the value.
	BenzingaFirmIdGte *string `form:"benzinga_firm_id.gte,omitempty" json:"benzinga_firm_id.gte,omitempty"`

	// BenzingaFirmIdLt Filter less than the value.
	BenzingaFirmIdLt *string `form:"benzinga_firm_id.lt,omitempty" json:"benzinga_firm_id.lt,omitempty"`

	// BenzingaFirmIdLte Filter less than or equal to the value.
	BenzingaFirmIdLte *string `form:"benzinga_firm_id.lte,omitempty" json:"benzinga_firm_id.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'last_updated' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBenzingaV2NewsParams defines parameters for GetBenzingaV2News.
type GetBenzingaV2NewsParams struct {
	// Published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	Published *string `form:"published,omitempty" json:"published,omitempty"`

	// PublishedGt Filter greater than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	PublishedGt *string `form:"published.gt,omitempty" json:"published.gt,omitempty"`

	// PublishedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	PublishedGte *string `form:"published.gte,omitempty" json:"published.gte,omitempty"`

	// PublishedLt Filter less than the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	PublishedLt *string `form:"published.lt,omitempty" json:"published.lt,omitempty"`

	// PublishedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	PublishedLte *string `form:"published.lte,omitempty" json:"published.lte,omitempty"`

	// Channels Filter for arrays that contain the value.
	Channels *string `form:"channels,omitempty" json:"channels,omitempty"`

	// ChannelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	ChannelsAllOf *string `form:"channels.all_of,omitempty" json:"channels.all_of,omitempty"`

	// ChannelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	ChannelsAnyOf *string `form:"channels.any_of,omitempty" json:"channels.any_of,omitempty"`

	// Tags Filter for arrays that contain the value.
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`

	// TagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	TagsAllOf *string `form:"tags.all_of,omitempty" json:"tags.all_of,omitempty"`

	// TagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	TagsAnyOf *string `form:"tags.any_of,omitempty" json:"tags.any_of,omitempty"`

	// Author The name of the journalist or entity that authored the news article.
	Author *string `form:"author,omitempty" json:"author,omitempty"`

	// AuthorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	AuthorAnyOf *string `form:"author.any_of,omitempty" json:"author.any_of,omitempty"`

	// AuthorGt Filter greater than the value.
	AuthorGt *string `form:"author.gt,omitempty" json:"author.gt,omitempty"`

	// AuthorGte Filter greater than or equal to the value.
	AuthorGte *string `form:"author.gte,omitempty" json:"author.gte,omitempty"`

	// AuthorLt Filter less than the value.
	AuthorLt *string `form:"author.lt,omitempty" json:"author.lt,omitempty"`

	// AuthorLte Filter less than or equal to the value.
	AuthorLte *string `form:"author.lte,omitempty" json:"author.lte,omitempty"`

	// Stocks Filter for arrays that contain the value.
	Stocks *string `form:"stocks,omitempty" json:"stocks,omitempty"`

	// StocksAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	StocksAllOf *string `form:"stocks.all_of,omitempty" json:"stocks.all_of,omitempty"`

	// StocksAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	StocksAnyOf *string `form:"stocks.any_of,omitempty" json:"stocks.any_of,omitempty"`

	// Tickers Filter for arrays that contain the value.
	Tickers *string `form:"tickers,omitempty" json:"tickers,omitempty"`

	// TickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	TickersAllOf *string `form:"tickers.all_of,omitempty" json:"tickers.all_of,omitempty"`

	// TickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	TickersAnyOf *string `form:"tickers.any_of,omitempty" json:"tickers.any_of,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'published' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetCryptoV1ExchangesParams defines parameters for GetCryptoV1Exchanges.
type GetCryptoV1ExchangesParams struct {
	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetEtfGlobalV1AnalyticsParams defines parameters for GetEtfGlobalV1Analytics.
type GetEtfGlobalV1AnalyticsParams struct {
	// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
	CompositeTicker *string `form:"composite_ticker,omitempty" json:"composite_ticker,omitempty"`

	// CompositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CompositeTickerAnyOf *string `form:"composite_ticker.any_of,omitempty" json:"composite_ticker.any_of,omitempty"`

	// CompositeTickerGt Filter greater than the value.
	CompositeTickerGt *string `form:"composite_ticker.gt,omitempty" json:"composite_ticker.gt,omitempty"`

	// CompositeTickerGte Filter greater than or equal to the value.
	CompositeTickerGte *string `form:"composite_ticker.gte,omitempty" json:"composite_ticker.gte,omitempty"`

	// CompositeTickerLt Filter less than the value.
	CompositeTickerLt *string `form:"composite_ticker.lt,omitempty" json:"composite_ticker.lt,omitempty"`

	// CompositeTickerLte Filter less than or equal to the value.
	CompositeTickerLte *string `form:"composite_ticker.lte,omitempty" json:"composite_ticker.lte,omitempty"`

	// ProcessedDate The date showing when ETF Global received and processed the data. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDate *string `form:"processed_date,omitempty" json:"processed_date,omitempty"`

	// ProcessedDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGt *string `form:"processed_date.gt,omitempty" json:"processed_date.gt,omitempty"`

	// ProcessedDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGte *string `form:"processed_date.gte,omitempty" json:"processed_date.gte,omitempty"`

	// ProcessedDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLt *string `form:"processed_date.lt,omitempty" json:"processed_date.lt,omitempty"`

	// ProcessedDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLte *string `form:"processed_date.lte,omitempty" json:"processed_date.lte,omitempty"`

	// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDate *string `form:"effective_date,omitempty" json:"effective_date,omitempty"`

	// EffectiveDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGt *string `form:"effective_date.gt,omitempty" json:"effective_date.gt,omitempty"`

	// EffectiveDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGte *string `form:"effective_date.gte,omitempty" json:"effective_date.gte,omitempty"`

	// EffectiveDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLt *string `form:"effective_date.lt,omitempty" json:"effective_date.lt,omitempty"`

	// EffectiveDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLte *string `form:"effective_date.lte,omitempty" json:"effective_date.lte,omitempty"`

	// RiskTotalScore ETF Global's proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number.
	RiskTotalScore *float64 `form:"risk_total_score,omitempty" json:"risk_total_score,omitempty"`

	// RiskTotalScoreGt Filter greater than the value. Value must be a floating point number.
	RiskTotalScoreGt *float64 `form:"risk_total_score.gt,omitempty" json:"risk_total_score.gt,omitempty"`

	// RiskTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number.
	RiskTotalScoreGte *float64 `form:"risk_total_score.gte,omitempty" json:"risk_total_score.gte,omitempty"`

	// RiskTotalScoreLt Filter less than the value. Value must be a floating point number.
	RiskTotalScoreLt *float64 `form:"risk_total_score.lt,omitempty" json:"risk_total_score.lt,omitempty"`

	// RiskTotalScoreLte Filter less than or equal to the value. Value must be a floating point number.
	RiskTotalScoreLte *float64 `form:"risk_total_score.lte,omitempty" json:"risk_total_score.lte,omitempty"`

	// RewardScore ETF Global's proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number.
	RewardScore *float64 `form:"reward_score,omitempty" json:"reward_score,omitempty"`

	// RewardScoreGt Filter greater than the value. Value must be a floating point number.
	RewardScoreGt *float64 `form:"reward_score.gt,omitempty" json:"reward_score.gt,omitempty"`

	// RewardScoreGte Filter greater than or equal to the value. Value must be a floating point number.
	RewardScoreGte *float64 `form:"reward_score.gte,omitempty" json:"reward_score.gte,omitempty"`

	// RewardScoreLt Filter less than the value. Value must be a floating point number.
	RewardScoreLt *float64 `form:"reward_score.lt,omitempty" json:"reward_score.lt,omitempty"`

	// RewardScoreLte Filter less than or equal to the value. Value must be a floating point number.
	RewardScoreLte *float64 `form:"reward_score.lte,omitempty" json:"reward_score.lte,omitempty"`

	// QuantTotalScore ETF Global's comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number.
	QuantTotalScore *float64 `form:"quant_total_score,omitempty" json:"quant_total_score,omitempty"`

	// QuantTotalScoreGt Filter greater than the value. Value must be a floating point number.
	QuantTotalScoreGt *float64 `form:"quant_total_score.gt,omitempty" json:"quant_total_score.gt,omitempty"`

	// QuantTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantTotalScoreGte *float64 `form:"quant_total_score.gte,omitempty" json:"quant_total_score.gte,omitempty"`

	// QuantTotalScoreLt Filter less than the value. Value must be a floating point number.
	QuantTotalScoreLt *float64 `form:"quant_total_score.lt,omitempty" json:"quant_total_score.lt,omitempty"`

	// QuantTotalScoreLte Filter less than or equal to the value. Value must be a floating point number.
	QuantTotalScoreLte *float64 `form:"quant_total_score.lte,omitempty" json:"quant_total_score.lte,omitempty"`

	// QuantGrade Letter grade summarizing the ETF's overall quantitative assessment, where A = 71-100, B = 56-70, etc.
	QuantGrade *string `form:"quant_grade,omitempty" json:"quant_grade,omitempty"`

	// QuantGradeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	QuantGradeAnyOf *string `form:"quant_grade.any_of,omitempty" json:"quant_grade.any_of,omitempty"`

	// QuantGradeGt Filter greater than the value.
	QuantGradeGt *string `form:"quant_grade.gt,omitempty" json:"quant_grade.gt,omitempty"`

	// QuantGradeGte Filter greater than or equal to the value.
	QuantGradeGte *string `form:"quant_grade.gte,omitempty" json:"quant_grade.gte,omitempty"`

	// QuantGradeLt Filter less than the value.
	QuantGradeLt *string `form:"quant_grade.lt,omitempty" json:"quant_grade.lt,omitempty"`

	// QuantGradeLte Filter less than or equal to the value.
	QuantGradeLte *string `form:"quant_grade.lte,omitempty" json:"quant_grade.lte,omitempty"`

	// QuantCompositeTechnical Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number.
	QuantCompositeTechnical *float64 `form:"quant_composite_technical,omitempty" json:"quant_composite_technical,omitempty"`

	// QuantCompositeTechnicalGt Filter greater than the value. Value must be a floating point number.
	QuantCompositeTechnicalGt *float64 `form:"quant_composite_technical.gt,omitempty" json:"quant_composite_technical.gt,omitempty"`

	// QuantCompositeTechnicalGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantCompositeTechnicalGte *float64 `form:"quant_composite_technical.gte,omitempty" json:"quant_composite_technical.gte,omitempty"`

	// QuantCompositeTechnicalLt Filter less than the value. Value must be a floating point number.
	QuantCompositeTechnicalLt *float64 `form:"quant_composite_technical.lt,omitempty" json:"quant_composite_technical.lt,omitempty"`

	// QuantCompositeTechnicalLte Filter less than or equal to the value. Value must be a floating point number.
	QuantCompositeTechnicalLte *float64 `form:"quant_composite_technical.lte,omitempty" json:"quant_composite_technical.lte,omitempty"`

	// QuantCompositeSentiment Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number.
	QuantCompositeSentiment *float64 `form:"quant_composite_sentiment,omitempty" json:"quant_composite_sentiment,omitempty"`

	// QuantCompositeSentimentGt Filter greater than the value. Value must be a floating point number.
	QuantCompositeSentimentGt *float64 `form:"quant_composite_sentiment.gt,omitempty" json:"quant_composite_sentiment.gt,omitempty"`

	// QuantCompositeSentimentGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantCompositeSentimentGte *float64 `form:"quant_composite_sentiment.gte,omitempty" json:"quant_composite_sentiment.gte,omitempty"`

	// QuantCompositeSentimentLt Filter less than the value. Value must be a floating point number.
	QuantCompositeSentimentLt *float64 `form:"quant_composite_sentiment.lt,omitempty" json:"quant_composite_sentiment.lt,omitempty"`

	// QuantCompositeSentimentLte Filter less than or equal to the value. Value must be a floating point number.
	QuantCompositeSentimentLte *float64 `form:"quant_composite_sentiment.lte,omitempty" json:"quant_composite_sentiment.lte,omitempty"`

	// QuantCompositeBehavioral Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number.
	QuantCompositeBehavioral *float64 `form:"quant_composite_behavioral,omitempty" json:"quant_composite_behavioral,omitempty"`

	// QuantCompositeBehavioralGt Filter greater than the value. Value must be a floating point number.
	QuantCompositeBehavioralGt *float64 `form:"quant_composite_behavioral.gt,omitempty" json:"quant_composite_behavioral.gt,omitempty"`

	// QuantCompositeBehavioralGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantCompositeBehavioralGte *float64 `form:"quant_composite_behavioral.gte,omitempty" json:"quant_composite_behavioral.gte,omitempty"`

	// QuantCompositeBehavioralLt Filter less than the value. Value must be a floating point number.
	QuantCompositeBehavioralLt *float64 `form:"quant_composite_behavioral.lt,omitempty" json:"quant_composite_behavioral.lt,omitempty"`

	// QuantCompositeBehavioralLte Filter less than or equal to the value. Value must be a floating point number.
	QuantCompositeBehavioralLte *float64 `form:"quant_composite_behavioral.lte,omitempty" json:"quant_composite_behavioral.lte,omitempty"`

	// QuantCompositeFundamental Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number.
	QuantCompositeFundamental *float64 `form:"quant_composite_fundamental,omitempty" json:"quant_composite_fundamental,omitempty"`

	// QuantCompositeFundamentalGt Filter greater than the value. Value must be a floating point number.
	QuantCompositeFundamentalGt *float64 `form:"quant_composite_fundamental.gt,omitempty" json:"quant_composite_fundamental.gt,omitempty"`

	// QuantCompositeFundamentalGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantCompositeFundamentalGte *float64 `form:"quant_composite_fundamental.gte,omitempty" json:"quant_composite_fundamental.gte,omitempty"`

	// QuantCompositeFundamentalLt Filter less than the value. Value must be a floating point number.
	QuantCompositeFundamentalLt *float64 `form:"quant_composite_fundamental.lt,omitempty" json:"quant_composite_fundamental.lt,omitempty"`

	// QuantCompositeFundamentalLte Filter less than or equal to the value. Value must be a floating point number.
	QuantCompositeFundamentalLte *float64 `form:"quant_composite_fundamental.lte,omitempty" json:"quant_composite_fundamental.lte,omitempty"`

	// QuantCompositeGlobal Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number.
	QuantCompositeGlobal *float64 `form:"quant_composite_global,omitempty" json:"quant_composite_global,omitempty"`

	// QuantCompositeGlobalGt Filter greater than the value. Value must be a floating point number.
	QuantCompositeGlobalGt *float64 `form:"quant_composite_global.gt,omitempty" json:"quant_composite_global.gt,omitempty"`

	// QuantCompositeGlobalGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantCompositeGlobalGte *float64 `form:"quant_composite_global.gte,omitempty" json:"quant_composite_global.gte,omitempty"`

	// QuantCompositeGlobalLt Filter less than the value. Value must be a floating point number.
	QuantCompositeGlobalLt *float64 `form:"quant_composite_global.lt,omitempty" json:"quant_composite_global.lt,omitempty"`

	// QuantCompositeGlobalLte Filter less than or equal to the value. Value must be a floating point number.
	QuantCompositeGlobalLte *float64 `form:"quant_composite_global.lte,omitempty" json:"quant_composite_global.lte,omitempty"`

	// QuantCompositeQuality Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number.
	QuantCompositeQuality *float64 `form:"quant_composite_quality,omitempty" json:"quant_composite_quality,omitempty"`

	// QuantCompositeQualityGt Filter greater than the value. Value must be a floating point number.
	QuantCompositeQualityGt *float64 `form:"quant_composite_quality.gt,omitempty" json:"quant_composite_quality.gt,omitempty"`

	// QuantCompositeQualityGte Filter greater than or equal to the value. Value must be a floating point number.
	QuantCompositeQualityGte *float64 `form:"quant_composite_quality.gte,omitempty" json:"quant_composite_quality.gte,omitempty"`

	// QuantCompositeQualityLt Filter less than the value. Value must be a floating point number.
	QuantCompositeQualityLt *float64 `form:"quant_composite_quality.lt,omitempty" json:"quant_composite_quality.lt,omitempty"`

	// QuantCompositeQualityLte Filter less than or equal to the value. Value must be a floating point number.
	QuantCompositeQualityLte *float64 `form:"quant_composite_quality.lte,omitempty" json:"quant_composite_quality.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'composite_ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetEtfGlobalV1ConstituentsParams defines parameters for GetEtfGlobalV1Constituents.
type GetEtfGlobalV1ConstituentsParams struct {
	// CompositeTicker The stock ticker symbol of the ETF that holds these constituent securities.
	CompositeTicker *string `form:"composite_ticker,omitempty" json:"composite_ticker,omitempty"`

	// CompositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CompositeTickerAnyOf *string `form:"composite_ticker.any_of,omitempty" json:"composite_ticker.any_of,omitempty"`

	// CompositeTickerGt Filter greater than the value.
	CompositeTickerGt *string `form:"composite_ticker.gt,omitempty" json:"composite_ticker.gt,omitempty"`

	// CompositeTickerGte Filter greater than or equal to the value.
	CompositeTickerGte *string `form:"composite_ticker.gte,omitempty" json:"composite_ticker.gte,omitempty"`

	// CompositeTickerLt Filter less than the value.
	CompositeTickerLt *string `form:"composite_ticker.lt,omitempty" json:"composite_ticker.lt,omitempty"`

	// CompositeTickerLte Filter less than or equal to the value.
	CompositeTickerLte *string `form:"composite_ticker.lte,omitempty" json:"composite_ticker.lte,omitempty"`

	// ConstituentTicker The stock ticker symbol of the individual security held within the ETF.
	ConstituentTicker *string `form:"constituent_ticker,omitempty" json:"constituent_ticker,omitempty"`

	// ConstituentTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ConstituentTickerAnyOf *string `form:"constituent_ticker.any_of,omitempty" json:"constituent_ticker.any_of,omitempty"`

	// ConstituentTickerGt Filter greater than the value.
	ConstituentTickerGt *string `form:"constituent_ticker.gt,omitempty" json:"constituent_ticker.gt,omitempty"`

	// ConstituentTickerGte Filter greater than or equal to the value.
	ConstituentTickerGte *string `form:"constituent_ticker.gte,omitempty" json:"constituent_ticker.gte,omitempty"`

	// ConstituentTickerLt Filter less than the value.
	ConstituentTickerLt *string `form:"constituent_ticker.lt,omitempty" json:"constituent_ticker.lt,omitempty"`

	// ConstituentTickerLte Filter less than or equal to the value.
	ConstituentTickerLte *string `form:"constituent_ticker.lte,omitempty" json:"constituent_ticker.lte,omitempty"`

	// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDate *string `form:"effective_date,omitempty" json:"effective_date,omitempty"`

	// EffectiveDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGt *string `form:"effective_date.gt,omitempty" json:"effective_date.gt,omitempty"`

	// EffectiveDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGte *string `form:"effective_date.gte,omitempty" json:"effective_date.gte,omitempty"`

	// EffectiveDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLt *string `form:"effective_date.lt,omitempty" json:"effective_date.lt,omitempty"`

	// EffectiveDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLte *string `form:"effective_date.lte,omitempty" json:"effective_date.lte,omitempty"`

	// ProcessedDate The date showing when ETF Global received and processed the data. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDate *string `form:"processed_date,omitempty" json:"processed_date,omitempty"`

	// ProcessedDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGt *string `form:"processed_date.gt,omitempty" json:"processed_date.gt,omitempty"`

	// ProcessedDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGte *string `form:"processed_date.gte,omitempty" json:"processed_date.gte,omitempty"`

	// ProcessedDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLt *string `form:"processed_date.lt,omitempty" json:"processed_date.lt,omitempty"`

	// ProcessedDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLte *string `form:"processed_date.lte,omitempty" json:"processed_date.lte,omitempty"`

	// UsCode A unique identifier code for the constituent security in US markets.
	UsCode *string `form:"us_code,omitempty" json:"us_code,omitempty"`

	// UsCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	UsCodeAnyOf *string `form:"us_code.any_of,omitempty" json:"us_code.any_of,omitempty"`

	// UsCodeGt Filter greater than the value.
	UsCodeGt *string `form:"us_code.gt,omitempty" json:"us_code.gt,omitempty"`

	// UsCodeGte Filter greater than or equal to the value.
	UsCodeGte *string `form:"us_code.gte,omitempty" json:"us_code.gte,omitempty"`

	// UsCodeLt Filter less than the value.
	UsCodeLt *string `form:"us_code.lt,omitempty" json:"us_code.lt,omitempty"`

	// UsCodeLte Filter less than or equal to the value.
	UsCodeLte *string `form:"us_code.lte,omitempty" json:"us_code.lte,omitempty"`

	// Isin The International Securities Identification Number, a global standard for identifying securities.
	Isin *string `form:"isin,omitempty" json:"isin,omitempty"`

	// IsinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	IsinAnyOf *string `form:"isin.any_of,omitempty" json:"isin.any_of,omitempty"`

	// IsinGt Filter greater than the value.
	IsinGt *string `form:"isin.gt,omitempty" json:"isin.gt,omitempty"`

	// IsinGte Filter greater than or equal to the value.
	IsinGte *string `form:"isin.gte,omitempty" json:"isin.gte,omitempty"`

	// IsinLt Filter less than the value.
	IsinLt *string `form:"isin.lt,omitempty" json:"isin.lt,omitempty"`

	// IsinLte Filter less than or equal to the value.
	IsinLte *string `form:"isin.lte,omitempty" json:"isin.lte,omitempty"`

	// Figi The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
	Figi *string `form:"figi,omitempty" json:"figi,omitempty"`

	// FigiAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FigiAnyOf *string `form:"figi.any_of,omitempty" json:"figi.any_of,omitempty"`

	// FigiGt Filter greater than the value.
	FigiGt *string `form:"figi.gt,omitempty" json:"figi.gt,omitempty"`

	// FigiGte Filter greater than or equal to the value.
	FigiGte *string `form:"figi.gte,omitempty" json:"figi.gte,omitempty"`

	// FigiLt Filter less than the value.
	FigiLt *string `form:"figi.lt,omitempty" json:"figi.lt,omitempty"`

	// FigiLte Filter less than or equal to the value.
	FigiLte *string `form:"figi.lte,omitempty" json:"figi.lte,omitempty"`

	// Sedol The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
	Sedol *string `form:"sedol,omitempty" json:"sedol,omitempty"`

	// SedolAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SedolAnyOf *string `form:"sedol.any_of,omitempty" json:"sedol.any_of,omitempty"`

	// SedolGt Filter greater than the value.
	SedolGt *string `form:"sedol.gt,omitempty" json:"sedol.gt,omitempty"`

	// SedolGte Filter greater than or equal to the value.
	SedolGte *string `form:"sedol.gte,omitempty" json:"sedol.gte,omitempty"`

	// SedolLt Filter less than the value.
	SedolLt *string `form:"sedol.lt,omitempty" json:"sedol.lt,omitempty"`

	// SedolLte Filter less than or equal to the value.
	SedolLte *string `form:"sedol.lte,omitempty" json:"sedol.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'composite_ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetEtfGlobalV1FundFlowsParams defines parameters for GetEtfGlobalV1FundFlows.
type GetEtfGlobalV1FundFlowsParams struct {
	// ProcessedDate The date showing when ETF Global received and processed the data. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDate *string `form:"processed_date,omitempty" json:"processed_date,omitempty"`

	// ProcessedDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGt *string `form:"processed_date.gt,omitempty" json:"processed_date.gt,omitempty"`

	// ProcessedDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGte *string `form:"processed_date.gte,omitempty" json:"processed_date.gte,omitempty"`

	// ProcessedDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLt *string `form:"processed_date.lt,omitempty" json:"processed_date.lt,omitempty"`

	// ProcessedDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLte *string `form:"processed_date.lte,omitempty" json:"processed_date.lte,omitempty"`

	// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDate *string `form:"effective_date,omitempty" json:"effective_date,omitempty"`

	// EffectiveDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGt *string `form:"effective_date.gt,omitempty" json:"effective_date.gt,omitempty"`

	// EffectiveDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGte *string `form:"effective_date.gte,omitempty" json:"effective_date.gte,omitempty"`

	// EffectiveDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLt *string `form:"effective_date.lt,omitempty" json:"effective_date.lt,omitempty"`

	// EffectiveDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLte *string `form:"effective_date.lte,omitempty" json:"effective_date.lte,omitempty"`

	// CompositeTicker The stock ticker symbol used to identify this ETF on exchanges.
	CompositeTicker *string `form:"composite_ticker,omitempty" json:"composite_ticker,omitempty"`

	// CompositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CompositeTickerAnyOf *string `form:"composite_ticker.any_of,omitempty" json:"composite_ticker.any_of,omitempty"`

	// CompositeTickerGt Filter greater than the value.
	CompositeTickerGt *string `form:"composite_ticker.gt,omitempty" json:"composite_ticker.gt,omitempty"`

	// CompositeTickerGte Filter greater than or equal to the value.
	CompositeTickerGte *string `form:"composite_ticker.gte,omitempty" json:"composite_ticker.gte,omitempty"`

	// CompositeTickerLt Filter less than the value.
	CompositeTickerLt *string `form:"composite_ticker.lt,omitempty" json:"composite_ticker.lt,omitempty"`

	// CompositeTickerLte Filter less than or equal to the value.
	CompositeTickerLte *string `form:"composite_ticker.lte,omitempty" json:"composite_ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'composite_ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetEtfGlobalV1ProfilesParams defines parameters for GetEtfGlobalV1Profiles.
type GetEtfGlobalV1ProfilesParams struct {
	// ProcessedDate The date showing when ETF Global received and processed the data. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDate *string `form:"processed_date,omitempty" json:"processed_date,omitempty"`

	// ProcessedDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGt *string `form:"processed_date.gt,omitempty" json:"processed_date.gt,omitempty"`

	// ProcessedDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGte *string `form:"processed_date.gte,omitempty" json:"processed_date.gte,omitempty"`

	// ProcessedDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLt *string `form:"processed_date.lt,omitempty" json:"processed_date.lt,omitempty"`

	// ProcessedDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLte *string `form:"processed_date.lte,omitempty" json:"processed_date.lte,omitempty"`

	// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDate *string `form:"effective_date,omitempty" json:"effective_date,omitempty"`

	// EffectiveDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGt *string `form:"effective_date.gt,omitempty" json:"effective_date.gt,omitempty"`

	// EffectiveDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGte *string `form:"effective_date.gte,omitempty" json:"effective_date.gte,omitempty"`

	// EffectiveDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLt *string `form:"effective_date.lt,omitempty" json:"effective_date.lt,omitempty"`

	// EffectiveDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLte *string `form:"effective_date.lte,omitempty" json:"effective_date.lte,omitempty"`

	// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
	CompositeTicker *string `form:"composite_ticker,omitempty" json:"composite_ticker,omitempty"`

	// CompositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CompositeTickerAnyOf *string `form:"composite_ticker.any_of,omitempty" json:"composite_ticker.any_of,omitempty"`

	// CompositeTickerGt Filter greater than the value.
	CompositeTickerGt *string `form:"composite_ticker.gt,omitempty" json:"composite_ticker.gt,omitempty"`

	// CompositeTickerGte Filter greater than or equal to the value.
	CompositeTickerGte *string `form:"composite_ticker.gte,omitempty" json:"composite_ticker.gte,omitempty"`

	// CompositeTickerLt Filter less than the value.
	CompositeTickerLt *string `form:"composite_ticker.lt,omitempty" json:"composite_ticker.lt,omitempty"`

	// CompositeTickerLte Filter less than or equal to the value.
	CompositeTickerLte *string `form:"composite_ticker.lte,omitempty" json:"composite_ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'composite_ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetEtfGlobalV1TaxonomiesParams defines parameters for GetEtfGlobalV1Taxonomies.
type GetEtfGlobalV1TaxonomiesParams struct {
	// ProcessedDate The date showing when ETF Global received and processed the data. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDate *string `form:"processed_date,omitempty" json:"processed_date,omitempty"`

	// ProcessedDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGt *string `form:"processed_date.gt,omitempty" json:"processed_date.gt,omitempty"`

	// ProcessedDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateGte *string `form:"processed_date.gte,omitempty" json:"processed_date.gte,omitempty"`

	// ProcessedDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLt *string `form:"processed_date.lt,omitempty" json:"processed_date.lt,omitempty"`

	// ProcessedDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ProcessedDateLte *string `form:"processed_date.lte,omitempty" json:"processed_date.lte,omitempty"`

	// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDate *string `form:"effective_date,omitempty" json:"effective_date,omitempty"`

	// EffectiveDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGt *string `form:"effective_date.gt,omitempty" json:"effective_date.gt,omitempty"`

	// EffectiveDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateGte *string `form:"effective_date.gte,omitempty" json:"effective_date.gte,omitempty"`

	// EffectiveDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLt *string `form:"effective_date.lt,omitempty" json:"effective_date.lt,omitempty"`

	// EffectiveDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	EffectiveDateLte *string `form:"effective_date.lte,omitempty" json:"effective_date.lte,omitempty"`

	// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
	CompositeTicker *string `form:"composite_ticker,omitempty" json:"composite_ticker,omitempty"`

	// CompositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CompositeTickerAnyOf *string `form:"composite_ticker.any_of,omitempty" json:"composite_ticker.any_of,omitempty"`

	// CompositeTickerGt Filter greater than the value.
	CompositeTickerGt *string `form:"composite_ticker.gt,omitempty" json:"composite_ticker.gt,omitempty"`

	// CompositeTickerGte Filter greater than or equal to the value.
	CompositeTickerGte *string `form:"composite_ticker.gte,omitempty" json:"composite_ticker.gte,omitempty"`

	// CompositeTickerLt Filter less than the value.
	CompositeTickerLt *string `form:"composite_ticker.lt,omitempty" json:"composite_ticker.lt,omitempty"`

	// CompositeTickerLte Filter less than or equal to the value.
	CompositeTickerLte *string `form:"composite_ticker.lte,omitempty" json:"composite_ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'composite_ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFedV1InflationParams defines parameters for GetFedV1Inflation.
type GetFedV1InflationParams struct {
	// Date Calendar date of the observation (YYYYMMDD).
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFedV1InflationExpectationsParams defines parameters for GetFedV1InflationExpectations.
type GetFedV1InflationExpectationsParams struct {
	// Date Calendar date of the observation (YYYYMMDD).
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFedV1LaborMarketParams defines parameters for GetFedV1LaborMarket.
type GetFedV1LaborMarketParams struct {
	// Date Calendar date of the observation (YYYY-MM-DD).
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFedV1TreasuryYieldsParams defines parameters for GetFedV1TreasuryYields.
type GetFedV1TreasuryYieldsParams struct {
	// Date Calendar date of the yield observation (YYYY-MM-DD).
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetForexV1ExchangesParams defines parameters for GetForexV1Exchanges.
type GetForexV1ExchangesParams struct {
	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFuturesAggregatesParams defines parameters for GetFuturesAggregates.
type GetFuturesAggregatesParams struct {
	// Resolution This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window.
	// For example: 15mins, 30secs, 12hours, or 7days.
	// There are maximum allowable candle sizes. For example, you can request "1min" to "59mins", but after that you will need to use "1hr". If you make a request for a candle size that is not supported, we will return a 400 "Bad Request - resolution value is not allowed."
	Resolution *string `form:"resolution,omitempty" json:"resolution,omitempty"`

	// WindowStart Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp).
	// How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:
	//   - `window_start.gte`  greater than or equal to
	//   - `window_start.gt`  greater than
	//   - `window_start.lte`  less than or equal to
	//   - `window_start.lt`  less than
	//
	// Examples 1. Most recent minute candles
	//    `/vX/aggs/ESU5?resolution=1min&limit=5`
	//
	// 2. Daily candle for August 5, 2025
	//    `/vX/aggs/ESU5?resolution=1day&window_start=2025-08-05`
	//
	// 3. Daily candles from July 131, 2025
	//    `/vX/aggs/ESU5?resolution=1day&window_start.gte=2025-07-01&window_start.lte=2025-07-31`
	//
	// 4. 1,000 one-second candles after a specific timestamp
	//    `/vX/aggs/ESU5?resolution=1sec&window_start.gt=1751409877000000000&limit=1000`
	WindowStart *string `form:"window_start,omitempty" json:"window_start,omitempty"`

	// Limit The number of results to return per page (default=1000, maximum=50000, minimum=1).
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// WindowStartGte Range by window_start.
	WindowStartGte *string `form:"window_start.gte,omitempty" json:"window_start.gte,omitempty"`

	// WindowStartGt Range by window_start.
	WindowStartGt *string `form:"window_start.gt,omitempty" json:"window_start.gt,omitempty"`

	// WindowStartLte Range by window_start.
	WindowStartLte *string `form:"window_start.lte,omitempty" json:"window_start.lte,omitempty"`

	// WindowStartLt Range by window_start.
	WindowStartLt *string `form:"window_start.lt,omitempty" json:"window_start.lt,omitempty"`

	// Sort Sort results by field and direction using dotted notation (e.g., 'ticker.asc', 'name.desc').
	Sort *GetFuturesAggregatesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesAggregatesParamsSort defines parameters for GetFuturesAggregates.
type GetFuturesAggregatesParamsSort string

// GetFuturesVXContractsParams defines parameters for GetFuturesVXContracts.
type GetFuturesVXContractsParams struct {
	// Date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about contracts for the specified day. Value must be formatted 'yyyy-mm-dd'.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// ProductCode The identifier for the contract's product.
	ProductCode *string `form:"product_code,omitempty" json:"product_code,omitempty"`

	// ProductCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ProductCodeAnyOf *string `form:"product_code.any_of,omitempty" json:"product_code.any_of,omitempty"`

	// ProductCodeGt Filter greater than the value.
	ProductCodeGt *string `form:"product_code.gt,omitempty" json:"product_code.gt,omitempty"`

	// ProductCodeGte Filter greater than or equal to the value.
	ProductCodeGte *string `form:"product_code.gte,omitempty" json:"product_code.gte,omitempty"`

	// ProductCodeLt Filter less than the value.
	ProductCodeLt *string `form:"product_code.lt,omitempty" json:"product_code.lt,omitempty"`

	// ProductCodeLte Filter less than or equal to the value.
	ProductCodeLte *string `form:"product_code.lte,omitempty" json:"product_code.lte,omitempty"`

	// Ticker The ticker for the contract.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Active Whether or not a given contract was tradeable at the given point in time. Active is true when (first_trade_date <= date >= last_trade_date) and false otherwise.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Type The type of contract, one of 'single' or 'combo'. Leaving this filter blank will query for both 'single' and 'combo' types.
	Type *GetFuturesVXContractsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// TypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TypeAnyOf *GetFuturesVXContractsParamsTypeAnyOf `form:"type.any_of,omitempty" json:"type.any_of,omitempty"`

	// FirstTradeDate The first day on which the contract was tradeable. Value must be formatted 'yyyy-mm-dd'.
	FirstTradeDate *string `form:"first_trade_date,omitempty" json:"first_trade_date,omitempty"`

	// FirstTradeDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	FirstTradeDateGt *string `form:"first_trade_date.gt,omitempty" json:"first_trade_date.gt,omitempty"`

	// FirstTradeDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FirstTradeDateGte *string `form:"first_trade_date.gte,omitempty" json:"first_trade_date.gte,omitempty"`

	// FirstTradeDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	FirstTradeDateLt *string `form:"first_trade_date.lt,omitempty" json:"first_trade_date.lt,omitempty"`

	// FirstTradeDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FirstTradeDateLte *string `form:"first_trade_date.lte,omitempty" json:"first_trade_date.lte,omitempty"`

	// LastTradeDate The last day on which the contract was tradeable. Value must be formatted 'yyyy-mm-dd'.
	LastTradeDate *string `form:"last_trade_date,omitempty" json:"last_trade_date,omitempty"`

	// LastTradeDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	LastTradeDateGt *string `form:"last_trade_date.gt,omitempty" json:"last_trade_date.gt,omitempty"`

	// LastTradeDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	LastTradeDateGte *string `form:"last_trade_date.gte,omitempty" json:"last_trade_date.gte,omitempty"`

	// LastTradeDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	LastTradeDateLt *string `form:"last_trade_date.lt,omitempty" json:"last_trade_date.lt,omitempty"`

	// LastTradeDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	LastTradeDateLte *string `form:"last_trade_date.lte,omitempty" json:"last_trade_date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '1000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'product_code' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesVXContractsParamsType defines parameters for GetFuturesVXContracts.
type GetFuturesVXContractsParamsType string

// GetFuturesVXContractsParamsTypeAnyOf defines parameters for GetFuturesVXContracts.
type GetFuturesVXContractsParamsTypeAnyOf string

// GetFuturesVXExchangesParams defines parameters for GetFuturesVXExchanges.
type GetFuturesVXExchangesParams struct {
	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFuturesVXMarketStatusParams defines parameters for GetFuturesVXMarketStatus.
type GetFuturesVXMarketStatusParams struct {
	// ProductCode The product code of the futures contracts for which you want statuses.
	ProductCode *string `form:"product_code,omitempty" json:"product_code,omitempty"`

	// ProductCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ProductCodeAnyOf *string `form:"product_code.any_of,omitempty" json:"product_code.any_of,omitempty"`

	// ProductCodeGt Filter greater than the value.
	ProductCodeGt *string `form:"product_code.gt,omitempty" json:"product_code.gt,omitempty"`

	// ProductCodeGte Filter greater than or equal to the value.
	ProductCodeGte *string `form:"product_code.gte,omitempty" json:"product_code.gte,omitempty"`

	// ProductCodeLt Filter less than the value.
	ProductCodeLt *string `form:"product_code.lt,omitempty" json:"product_code.lt,omitempty"`

	// ProductCodeLte Filter less than or equal to the value.
	ProductCodeLte *string `form:"product_code.lte,omitempty" json:"product_code.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFuturesVXProductsParams defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParams struct {
	// Name The full name of the product.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	NameAnyOf *string `form:"name.any_of,omitempty" json:"name.any_of,omitempty"`

	// NameGt Filter greater than the value.
	NameGt *string `form:"name.gt,omitempty" json:"name.gt,omitempty"`

	// NameGte Filter greater than or equal to the value.
	NameGte *string `form:"name.gte,omitempty" json:"name.gte,omitempty"`

	// NameLt Filter less than the value.
	NameLt *string `form:"name.lt,omitempty" json:"name.lt,omitempty"`

	// NameLte Filter less than or equal to the value.
	NameLte *string `form:"name.lte,omitempty" json:"name.lte,omitempty"`

	// ProductCode The identifier for the product.
	ProductCode *string `form:"product_code,omitempty" json:"product_code,omitempty"`

	// ProductCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ProductCodeAnyOf *string `form:"product_code.any_of,omitempty" json:"product_code.any_of,omitempty"`

	// ProductCodeGt Filter greater than the value.
	ProductCodeGt *string `form:"product_code.gt,omitempty" json:"product_code.gt,omitempty"`

	// ProductCodeGte Filter greater than or equal to the value.
	ProductCodeGte *string `form:"product_code.gte,omitempty" json:"product_code.gte,omitempty"`

	// ProductCodeLt Filter less than the value.
	ProductCodeLt *string `form:"product_code.lt,omitempty" json:"product_code.lt,omitempty"`

	// ProductCodeLte Filter less than or equal to the value.
	ProductCodeLte *string `form:"product_code.lte,omitempty" json:"product_code.lte,omitempty"`

	// Date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day. Value must be formatted 'yyyy-mm-dd'.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// TradingVenue The trading venue (MIC) for the exchange on which this product's contracts trade.
	TradingVenue *string `form:"trading_venue,omitempty" json:"trading_venue,omitempty"`

	// TradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TradingVenueAnyOf *string `form:"trading_venue.any_of,omitempty" json:"trading_venue.any_of,omitempty"`

	// TradingVenueGt Filter greater than the value.
	TradingVenueGt *string `form:"trading_venue.gt,omitempty" json:"trading_venue.gt,omitempty"`

	// TradingVenueGte Filter greater than or equal to the value.
	TradingVenueGte *string `form:"trading_venue.gte,omitempty" json:"trading_venue.gte,omitempty"`

	// TradingVenueLt Filter less than the value.
	TradingVenueLt *string `form:"trading_venue.lt,omitempty" json:"trading_venue.lt,omitempty"`

	// TradingVenueLte Filter less than or equal to the value.
	TradingVenueLte *string `form:"trading_venue.lte,omitempty" json:"trading_venue.lte,omitempty"`

	// Sector The sector to which the product belongs.
	Sector *GetFuturesVXProductsParamsSector `form:"sector,omitempty" json:"sector,omitempty"`

	// SectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SectorAnyOf *GetFuturesVXProductsParamsSectorAnyOf `form:"sector.any_of,omitempty" json:"sector.any_of,omitempty"`

	// SubSector The sub-sector to which the product belongs.
	SubSector *GetFuturesVXProductsParamsSubSector `form:"sub_sector,omitempty" json:"sub_sector,omitempty"`

	// SubSectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SubSectorAnyOf *GetFuturesVXProductsParamsSubSectorAnyOf `form:"sub_sector.any_of,omitempty" json:"sub_sector.any_of,omitempty"`

	// AssetClass The asset class to which the product belongs.
	AssetClass *GetFuturesVXProductsParamsAssetClass `form:"asset_class,omitempty" json:"asset_class,omitempty"`

	// AssetClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	AssetClassAnyOf *GetFuturesVXProductsParamsAssetClassAnyOf `form:"asset_class.any_of,omitempty" json:"asset_class.any_of,omitempty"`

	// AssetSubClass The asset sub-class to which the product belongs.
	AssetSubClass *GetFuturesVXProductsParamsAssetSubClass `form:"asset_sub_class,omitempty" json:"asset_sub_class,omitempty"`

	// AssetSubClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	AssetSubClassAnyOf *GetFuturesVXProductsParamsAssetSubClassAnyOf `form:"asset_sub_class.any_of,omitempty" json:"asset_sub_class.any_of,omitempty"`

	// Type The type of product, one of 'single' or 'combo'. Leaving this filter blank will query for both 'single' and 'combo' types.
	Type *GetFuturesVXProductsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// TypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TypeAnyOf *GetFuturesVXProductsParamsTypeAnyOf `form:"type.any_of,omitempty" json:"type.any_of,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesVXProductsParamsSector defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsSector string

// GetFuturesVXProductsParamsSectorAnyOf defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsSectorAnyOf string

// GetFuturesVXProductsParamsSubSector defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsSubSector string

// GetFuturesVXProductsParamsSubSectorAnyOf defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsSubSectorAnyOf string

// GetFuturesVXProductsParamsAssetClass defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsAssetClass string

// GetFuturesVXProductsParamsAssetClassAnyOf defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsAssetClassAnyOf string

// GetFuturesVXProductsParamsAssetSubClass defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsAssetSubClass string

// GetFuturesVXProductsParamsAssetSubClassAnyOf defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsAssetSubClassAnyOf string

// GetFuturesVXProductsParamsType defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsType string

// GetFuturesVXProductsParamsTypeAnyOf defines parameters for GetFuturesVXProducts.
type GetFuturesVXProductsParamsTypeAnyOf string

// GetFuturesVXQuotesNewParams defines parameters for GetFuturesVXQuotesNew.
type GetFuturesVXQuotesNewParams struct {
	// Timestamp The nanosecond accuracy Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGt Filter greater than the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampGte Filter greater than or equal to the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampLt Filter less than the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// TimestampLte Filter less than or equal to the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// SessionEndDate The trade date representing the session end date for this quote. Used for partitioning and filtering quotes by trading session.
	SessionEndDate *string `form:"session_end_date,omitempty" json:"session_end_date,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '49999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'timestamp' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesQuotesParams defines parameters for GetFuturesQuotes.
type GetFuturesQuotesParams struct {
	// Timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
	SessionEndDate *string `form:"session_end_date,omitempty" json:"session_end_date,omitempty"`

	// Limit The number of results to return per page (default=1000, maximum=50000, minimum=1).
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// SessionEndDateGte Range by session_end_date.
	SessionEndDateGte *string `form:"session_end_date.gte,omitempty" json:"session_end_date.gte,omitempty"`

	// SessionEndDateGt Range by session_end_date.
	SessionEndDateGt *string `form:"session_end_date.gt,omitempty" json:"session_end_date.gt,omitempty"`

	// SessionEndDateLte Range by session_end_date.
	SessionEndDateLte *string `form:"session_end_date.lte,omitempty" json:"session_end_date.lte,omitempty"`

	// SessionEndDateLt Range by session_end_date.
	SessionEndDateLt *string `form:"session_end_date.lt,omitempty" json:"session_end_date.lt,omitempty"`

	// Sort Sort results by field and direction using dotted notation (e.g., 'ticker.asc', 'name.desc').
	Sort *GetFuturesQuotesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesQuotesParamsSort defines parameters for GetFuturesQuotes.
type GetFuturesQuotesParamsSort string

// GetFuturesVXSchedulesParams defines parameters for GetFuturesVXSchedules.
type GetFuturesVXSchedulesParams struct {
	// ProductCode The product code of the futures contract.
	ProductCode *string `form:"product_code,omitempty" json:"product_code,omitempty"`

	// ProductCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ProductCodeAnyOf *string `form:"product_code.any_of,omitempty" json:"product_code.any_of,omitempty"`

	// ProductCodeGt Filter greater than the value.
	ProductCodeGt *string `form:"product_code.gt,omitempty" json:"product_code.gt,omitempty"`

	// ProductCodeGte Filter greater than or equal to the value.
	ProductCodeGte *string `form:"product_code.gte,omitempty" json:"product_code.gte,omitempty"`

	// ProductCodeLt Filter less than the value.
	ProductCodeLt *string `form:"product_code.lt,omitempty" json:"product_code.lt,omitempty"`

	// ProductCodeLte Filter less than or equal to the value.
	ProductCodeLte *string `form:"product_code.lte,omitempty" json:"product_code.lte,omitempty"`

	// SessionEndDate The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to 'today' in Central Time. e.g. If a request is made from Pacific Time on '2025-01-01' at 11:00 pm with no 'session_end_date' a default value of `2025-01-02` will be used.
	SessionEndDate *string `form:"session_end_date,omitempty" json:"session_end_date,omitempty"`

	// SessionEndDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SessionEndDateAnyOf *string `form:"session_end_date.any_of,omitempty" json:"session_end_date.any_of,omitempty"`

	// SessionEndDateGt Filter greater than the value.
	SessionEndDateGt *string `form:"session_end_date.gt,omitempty" json:"session_end_date.gt,omitempty"`

	// SessionEndDateGte Filter greater than or equal to the value.
	SessionEndDateGte *string `form:"session_end_date.gte,omitempty" json:"session_end_date.gte,omitempty"`

	// SessionEndDateLt Filter less than the value.
	SessionEndDateLt *string `form:"session_end_date.lt,omitempty" json:"session_end_date.lt,omitempty"`

	// SessionEndDateLte Filter less than or equal to the value.
	SessionEndDateLte *string `form:"session_end_date.lte,omitempty" json:"session_end_date.lte,omitempty"`

	// TradingVenue The trading venue (MIC) for the exchange on which this schedule's product trades.
	TradingVenue *string `form:"trading_venue,omitempty" json:"trading_venue,omitempty"`

	// TradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TradingVenueAnyOf *string `form:"trading_venue.any_of,omitempty" json:"trading_venue.any_of,omitempty"`

	// TradingVenueGt Filter greater than the value.
	TradingVenueGt *string `form:"trading_venue.gt,omitempty" json:"trading_venue.gt,omitempty"`

	// TradingVenueGte Filter greater than or equal to the value.
	TradingVenueGte *string `form:"trading_venue.gte,omitempty" json:"trading_venue.gte,omitempty"`

	// TradingVenueLt Filter less than the value.
	TradingVenueLt *string `form:"trading_venue.lt,omitempty" json:"trading_venue.lt,omitempty"`

	// TradingVenueLte Filter less than or equal to the value.
	TradingVenueLte *string `form:"trading_venue.lte,omitempty" json:"trading_venue.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '10' if not specified. The maximum allowed limit is '1000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'product_code' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesVXSnapshotParams defines parameters for GetFuturesVXSnapshot.
type GetFuturesVXSnapshotParams struct {
	// ProductCode The code for the contracts' underlying product.
	ProductCode *string `form:"product_code,omitempty" json:"product_code,omitempty"`

	// ProductCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ProductCodeAnyOf *string `form:"product_code.any_of,omitempty" json:"product_code.any_of,omitempty"`

	// ProductCodeGt Filter greater than the value.
	ProductCodeGt *string `form:"product_code.gt,omitempty" json:"product_code.gt,omitempty"`

	// ProductCodeGte Filter greater than or equal to the value.
	ProductCodeGte *string `form:"product_code.gte,omitempty" json:"product_code.gte,omitempty"`

	// ProductCodeLt Filter less than the value.
	ProductCodeLt *string `form:"product_code.lt,omitempty" json:"product_code.lt,omitempty"`

	// ProductCodeLte Filter less than or equal to the value.
	ProductCodeLte *string `form:"product_code.lte,omitempty" json:"product_code.lte,omitempty"`

	// Ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&P 500 E-mini contract).
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesVXSnapshotNativeParams defines parameters for GetFuturesVXSnapshotNative.
type GetFuturesVXSnapshotNativeParams struct {
	// ProductCode The code for the contracts' underlying product.
	ProductCode *string `form:"product_code,omitempty" json:"product_code,omitempty"`

	// ProductCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	ProductCodeAnyOf *string `form:"product_code.any_of,omitempty" json:"product_code.any_of,omitempty"`

	// ProductCodeGt Filter greater than the value.
	ProductCodeGt *string `form:"product_code.gt,omitempty" json:"product_code.gt,omitempty"`

	// ProductCodeGte Filter greater than or equal to the value.
	ProductCodeGte *string `form:"product_code.gte,omitempty" json:"product_code.gte,omitempty"`

	// ProductCodeLt Filter less than the value.
	ProductCodeLt *string `form:"product_code.lt,omitempty" json:"product_code.lt,omitempty"`

	// ProductCodeLte Filter less than or equal to the value.
	ProductCodeLte *string `form:"product_code.lte,omitempty" json:"product_code.lte,omitempty"`

	// Ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&P 500 E-mini contract).
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesVXTradesNewParams defines parameters for GetFuturesVXTradesNew.
type GetFuturesVXTradesNewParams struct {
	// Timestamp The time when the trade was generated at the exchange to nanosecond precision. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGt Filter greater than the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampGte Filter greater than or equal to the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampLt Filter less than the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// TimestampLte Filter less than or equal to the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// SessionEndDate The trade date representing the session end date for this trade. Used for partitioning and filtering trades by trading session.
	SessionEndDate *string `form:"session_end_date,omitempty" json:"session_end_date,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '10' if not specified. The maximum allowed limit is '49999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'timestamp' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesTradesParams defines parameters for GetFuturesTrades.
type GetFuturesTradesParams struct {
	// Timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
	SessionEndDate *string `form:"session_end_date,omitempty" json:"session_end_date,omitempty"`

	// Limit The number of results to return per page (default=1000, maximum=50000, minimum=1).
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// SessionEndDateGte Range by session_end_date.
	SessionEndDateGte *string `form:"session_end_date.gte,omitempty" json:"session_end_date.gte,omitempty"`

	// SessionEndDateGt Range by session_end_date.
	SessionEndDateGt *string `form:"session_end_date.gt,omitempty" json:"session_end_date.gt,omitempty"`

	// SessionEndDateLte Range by session_end_date.
	SessionEndDateLte *string `form:"session_end_date.lte,omitempty" json:"session_end_date.lte,omitempty"`

	// SessionEndDateLt Range by session_end_date.
	SessionEndDateLt *string `form:"session_end_date.lt,omitempty" json:"session_end_date.lt,omitempty"`

	// Sort Sort results by field and direction using dotted notation (e.g., 'ticker.asc', 'name.desc').
	Sort *GetFuturesTradesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetFuturesTradesParamsSort defines parameters for GetFuturesTrades.
type GetFuturesTradesParamsSort string

// GetOptionsV1ExchangesParams defines parameters for GetOptionsV1Exchanges.
type GetOptionsV1ExchangesParams struct {
	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetStocksFilings10KVXSectionsParams defines parameters for GetStocksFilings10KVXSections.
type GetStocksFilings10KVXSectionsParams struct {
	// Cik SEC Central Index Key (10 digits, zero-padded).
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// Ticker Stock ticker symbol for the company.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Section Standardized section identifier from the filing (e.g. 'business', 'risk_factors', etc.).
	Section *GetStocksFilings10KVXSectionsParamsSection `form:"section,omitempty" json:"section,omitempty"`

	// SectionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SectionAnyOf *GetStocksFilings10KVXSectionsParamsSectionAnyOf `form:"section.any_of,omitempty" json:"section.any_of,omitempty"`

	// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). Value must be formatted 'yyyy-mm-dd'.
	FilingDate *string `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// FilingDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGt *string `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGte *string `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLt *string `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// FilingDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLte *string `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// PeriodEnd Period end date that the filing relates to (formatted as YYYY-MM-DD). Value must be formatted 'yyyy-mm-dd'.
	PeriodEnd *string `form:"period_end,omitempty" json:"period_end,omitempty"`

	// PeriodEndGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGt *string `form:"period_end.gt,omitempty" json:"period_end.gt,omitempty"`

	// PeriodEndGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGte *string `form:"period_end.gte,omitempty" json:"period_end.gte,omitempty"`

	// PeriodEndLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLt *string `form:"period_end.lt,omitempty" json:"period_end.lt,omitempty"`

	// PeriodEndLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLte *string `form:"period_end.lte,omitempty" json:"period_end.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '9999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'period_end' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksFilings10KVXSectionsParamsSection defines parameters for GetStocksFilings10KVXSections.
type GetStocksFilings10KVXSectionsParamsSection string

// GetStocksFilings10KVXSectionsParamsSectionAnyOf defines parameters for GetStocksFilings10KVXSections.
type GetStocksFilings10KVXSectionsParamsSectionAnyOf string

// GetStocksFilingsVXIndexParams defines parameters for GetStocksFilingsVXIndex.
type GetStocksFilingsVXIndexParams struct {
	// Cik SEC Central Index Key (CIK) identifying the filing entity.
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// Ticker Stock ticker symbol for the filing entity, if available.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// FormType SEC form type (e.g., '10-K', '10-Q', '8-K', 'S-1', '4', etc.).
	FormType *string `form:"form_type,omitempty" json:"form_type,omitempty"`

	// FormTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FormTypeAnyOf *string `form:"form_type.any_of,omitempty" json:"form_type.any_of,omitempty"`

	// FormTypeGt Filter greater than the value.
	FormTypeGt *string `form:"form_type.gt,omitempty" json:"form_type.gt,omitempty"`

	// FormTypeGte Filter greater than or equal to the value.
	FormTypeGte *string `form:"form_type.gte,omitempty" json:"form_type.gte,omitempty"`

	// FormTypeLt Filter less than the value.
	FormTypeLt *string `form:"form_type.lt,omitempty" json:"form_type.lt,omitempty"`

	// FormTypeLte Filter less than or equal to the value.
	FormTypeLte *string `form:"form_type.lte,omitempty" json:"form_type.lte,omitempty"`

	// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). Value must be formatted 'yyyy-mm-dd'.
	FilingDate *string `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// FilingDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGt *string `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGte *string `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLt *string `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// FilingDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLte *string `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '1000' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'filing_date' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksFilingsVXRiskFactorsParams defines parameters for GetStocksFilingsVXRiskFactors.
type GetStocksFilingsVXRiskFactorsParams struct {
	// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
	FilingDate *string `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// FilingDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	FilingDateAnyOf *string `form:"filing_date.any_of,omitempty" json:"filing_date.any_of,omitempty"`

	// FilingDateGt Filter greater than the value.
	FilingDateGt *string `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateGte Filter greater than or equal to the value.
	FilingDateGte *string `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateLt Filter less than the value.
	FilingDateLt *string `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// FilingDateLte Filter less than or equal to the value.
	FilingDateLte *string `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// Ticker Stock ticker symbol for the company.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Cik SEC Central Index Key (10 digits, zero-padded).
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '49999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'filing_date' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksFinancialsV1BalanceSheetsParams defines parameters for GetStocksFinancialsV1BalanceSheets.
type GetStocksFinancialsV1BalanceSheetsParams struct {
	// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a company's CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// Tickers Filter for arrays that contain the value.
	Tickers *string `form:"tickers,omitempty" json:"tickers,omitempty"`

	// TickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	TickersAllOf *string `form:"tickers.all_of,omitempty" json:"tickers.all_of,omitempty"`

	// TickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	TickersAnyOf *string `form:"tickers.any_of,omitempty" json:"tickers.any_of,omitempty"`

	// PeriodEnd The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted 'yyyy-mm-dd'.
	PeriodEnd *string `form:"period_end,omitempty" json:"period_end,omitempty"`

	// PeriodEndGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGt *string `form:"period_end.gt,omitempty" json:"period_end.gt,omitempty"`

	// PeriodEndGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGte *string `form:"period_end.gte,omitempty" json:"period_end.gte,omitempty"`

	// PeriodEndLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLt *string `form:"period_end.lt,omitempty" json:"period_end.lt,omitempty"`

	// PeriodEndLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLte *string `form:"period_end.lte,omitempty" json:"period_end.lte,omitempty"`

	// FilingDate The date when the financial statement was filed with the SEC. Value must be formatted 'yyyy-mm-dd'.
	FilingDate *string `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// FilingDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGt *string `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGte *string `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLt *string `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// FilingDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLte *string `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// FiscalYear The fiscal year for the reporting period. Value must be a floating point number.
	FiscalYear *float64 `form:"fiscal_year,omitempty" json:"fiscal_year,omitempty"`

	// FiscalYearGt Filter greater than the value. Value must be a floating point number.
	FiscalYearGt *float64 `form:"fiscal_year.gt,omitempty" json:"fiscal_year.gt,omitempty"`

	// FiscalYearGte Filter greater than or equal to the value. Value must be a floating point number.
	FiscalYearGte *float64 `form:"fiscal_year.gte,omitempty" json:"fiscal_year.gte,omitempty"`

	// FiscalYearLt Filter less than the value. Value must be a floating point number.
	FiscalYearLt *float64 `form:"fiscal_year.lt,omitempty" json:"fiscal_year.lt,omitempty"`

	// FiscalYearLte Filter less than or equal to the value. Value must be a floating point number.
	FiscalYearLte *float64 `form:"fiscal_year.lte,omitempty" json:"fiscal_year.lte,omitempty"`

	// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
	FiscalQuarter *float64 `form:"fiscal_quarter,omitempty" json:"fiscal_quarter,omitempty"`

	// FiscalQuarterGt Filter greater than the value. Value must be a floating point number.
	FiscalQuarterGt *float64 `form:"fiscal_quarter.gt,omitempty" json:"fiscal_quarter.gt,omitempty"`

	// FiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number.
	FiscalQuarterGte *float64 `form:"fiscal_quarter.gte,omitempty" json:"fiscal_quarter.gte,omitempty"`

	// FiscalQuarterLt Filter less than the value. Value must be a floating point number.
	FiscalQuarterLt *float64 `form:"fiscal_quarter.lt,omitempty" json:"fiscal_quarter.lt,omitempty"`

	// FiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number.
	FiscalQuarterLte *float64 `form:"fiscal_quarter.lte,omitempty" json:"fiscal_quarter.lte,omitempty"`

	// Timeframe The reporting period type. Possible values include: quarterly, annual.
	Timeframe *string `form:"timeframe,omitempty" json:"timeframe,omitempty"`

	// TimeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TimeframeAnyOf *string `form:"timeframe.any_of,omitempty" json:"timeframe.any_of,omitempty"`

	// TimeframeGt Filter greater than the value.
	TimeframeGt *string `form:"timeframe.gt,omitempty" json:"timeframe.gt,omitempty"`

	// TimeframeGte Filter greater than or equal to the value.
	TimeframeGte *string `form:"timeframe.gte,omitempty" json:"timeframe.gte,omitempty"`

	// TimeframeLt Filter less than the value.
	TimeframeLt *string `form:"timeframe.lt,omitempty" json:"timeframe.lt,omitempty"`

	// TimeframeLte Filter less than or equal to the value.
	TimeframeLte *string `form:"timeframe.lte,omitempty" json:"timeframe.lte,omitempty"`

	// MaxTicker Filter equal to the value.
	MaxTicker *string `form:"max_ticker,omitempty" json:"max_ticker,omitempty"`

	// MaxTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	MaxTickerAnyOf *string `form:"max_ticker.any_of,omitempty" json:"max_ticker.any_of,omitempty"`

	// MaxTickerGt Filter greater than the value.
	MaxTickerGt *string `form:"max_ticker.gt,omitempty" json:"max_ticker.gt,omitempty"`

	// MaxTickerGte Filter greater than or equal to the value.
	MaxTickerGte *string `form:"max_ticker.gte,omitempty" json:"max_ticker.gte,omitempty"`

	// MaxTickerLt Filter less than the value.
	MaxTickerLt *string `form:"max_ticker.lt,omitempty" json:"max_ticker.lt,omitempty"`

	// MaxTickerLte Filter less than or equal to the value.
	MaxTickerLte *string `form:"max_ticker.lte,omitempty" json:"max_ticker.lte,omitempty"`

	// MinTicker Filter equal to the value.
	MinTicker *string `form:"min_ticker,omitempty" json:"min_ticker,omitempty"`

	// MinTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	MinTickerAnyOf *string `form:"min_ticker.any_of,omitempty" json:"min_ticker.any_of,omitempty"`

	// MinTickerGt Filter greater than the value.
	MinTickerGt *string `form:"min_ticker.gt,omitempty" json:"min_ticker.gt,omitempty"`

	// MinTickerGte Filter greater than or equal to the value.
	MinTickerGte *string `form:"min_ticker.gte,omitempty" json:"min_ticker.gte,omitempty"`

	// MinTickerLt Filter less than the value.
	MinTickerLt *string `form:"min_ticker.lt,omitempty" json:"min_ticker.lt,omitempty"`

	// MinTickerLte Filter less than or equal to the value.
	MinTickerLte *string `form:"min_ticker.lte,omitempty" json:"min_ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'period_end' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksFinancialsV1CashFlowStatementsParams defines parameters for GetStocksFinancialsV1CashFlowStatements.
type GetStocksFinancialsV1CashFlowStatementsParams struct {
	// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// PeriodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted 'yyyy-mm-dd'.
	PeriodEnd *string `form:"period_end,omitempty" json:"period_end,omitempty"`

	// PeriodEndGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGt *string `form:"period_end.gt,omitempty" json:"period_end.gt,omitempty"`

	// PeriodEndGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGte *string `form:"period_end.gte,omitempty" json:"period_end.gte,omitempty"`

	// PeriodEndLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLt *string `form:"period_end.lt,omitempty" json:"period_end.lt,omitempty"`

	// PeriodEndLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLte *string `form:"period_end.lte,omitempty" json:"period_end.lte,omitempty"`

	// FilingDate The date when the financial statement was filed with the SEC. Value must be formatted 'yyyy-mm-dd'.
	FilingDate *string `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// FilingDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGt *string `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGte *string `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLt *string `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// FilingDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLte *string `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// Tickers Filter for arrays that contain the value.
	Tickers *string `form:"tickers,omitempty" json:"tickers,omitempty"`

	// TickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	TickersAllOf *string `form:"tickers.all_of,omitempty" json:"tickers.all_of,omitempty"`

	// TickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	TickersAnyOf *string `form:"tickers.any_of,omitempty" json:"tickers.any_of,omitempty"`

	// FiscalYear The fiscal year for the reporting period. Value must be a floating point number.
	FiscalYear *float64 `form:"fiscal_year,omitempty" json:"fiscal_year,omitempty"`

	// FiscalYearGt Filter greater than the value. Value must be a floating point number.
	FiscalYearGt *float64 `form:"fiscal_year.gt,omitempty" json:"fiscal_year.gt,omitempty"`

	// FiscalYearGte Filter greater than or equal to the value. Value must be a floating point number.
	FiscalYearGte *float64 `form:"fiscal_year.gte,omitempty" json:"fiscal_year.gte,omitempty"`

	// FiscalYearLt Filter less than the value. Value must be a floating point number.
	FiscalYearLt *float64 `form:"fiscal_year.lt,omitempty" json:"fiscal_year.lt,omitempty"`

	// FiscalYearLte Filter less than or equal to the value. Value must be a floating point number.
	FiscalYearLte *float64 `form:"fiscal_year.lte,omitempty" json:"fiscal_year.lte,omitempty"`

	// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
	FiscalQuarter *float64 `form:"fiscal_quarter,omitempty" json:"fiscal_quarter,omitempty"`

	// FiscalQuarterGt Filter greater than the value. Value must be a floating point number.
	FiscalQuarterGt *float64 `form:"fiscal_quarter.gt,omitempty" json:"fiscal_quarter.gt,omitempty"`

	// FiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number.
	FiscalQuarterGte *float64 `form:"fiscal_quarter.gte,omitempty" json:"fiscal_quarter.gte,omitempty"`

	// FiscalQuarterLt Filter less than the value. Value must be a floating point number.
	FiscalQuarterLt *float64 `form:"fiscal_quarter.lt,omitempty" json:"fiscal_quarter.lt,omitempty"`

	// FiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number.
	FiscalQuarterLte *float64 `form:"fiscal_quarter.lte,omitempty" json:"fiscal_quarter.lte,omitempty"`

	// Timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
	Timeframe *string `form:"timeframe,omitempty" json:"timeframe,omitempty"`

	// TimeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TimeframeAnyOf *string `form:"timeframe.any_of,omitempty" json:"timeframe.any_of,omitempty"`

	// TimeframeGt Filter greater than the value.
	TimeframeGt *string `form:"timeframe.gt,omitempty" json:"timeframe.gt,omitempty"`

	// TimeframeGte Filter greater than or equal to the value.
	TimeframeGte *string `form:"timeframe.gte,omitempty" json:"timeframe.gte,omitempty"`

	// TimeframeLt Filter less than the value.
	TimeframeLt *string `form:"timeframe.lt,omitempty" json:"timeframe.lt,omitempty"`

	// TimeframeLte Filter less than or equal to the value.
	TimeframeLte *string `form:"timeframe.lte,omitempty" json:"timeframe.lte,omitempty"`

	// MaxTicker Filter equal to the value.
	MaxTicker *string `form:"max_ticker,omitempty" json:"max_ticker,omitempty"`

	// MaxTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	MaxTickerAnyOf *string `form:"max_ticker.any_of,omitempty" json:"max_ticker.any_of,omitempty"`

	// MaxTickerGt Filter greater than the value.
	MaxTickerGt *string `form:"max_ticker.gt,omitempty" json:"max_ticker.gt,omitempty"`

	// MaxTickerGte Filter greater than or equal to the value.
	MaxTickerGte *string `form:"max_ticker.gte,omitempty" json:"max_ticker.gte,omitempty"`

	// MaxTickerLt Filter less than the value.
	MaxTickerLt *string `form:"max_ticker.lt,omitempty" json:"max_ticker.lt,omitempty"`

	// MaxTickerLte Filter less than or equal to the value.
	MaxTickerLte *string `form:"max_ticker.lte,omitempty" json:"max_ticker.lte,omitempty"`

	// MinTicker Filter equal to the value.
	MinTicker *string `form:"min_ticker,omitempty" json:"min_ticker,omitempty"`

	// MinTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	MinTickerAnyOf *string `form:"min_ticker.any_of,omitempty" json:"min_ticker.any_of,omitempty"`

	// MinTickerGt Filter greater than the value.
	MinTickerGt *string `form:"min_ticker.gt,omitempty" json:"min_ticker.gt,omitempty"`

	// MinTickerGte Filter greater than or equal to the value.
	MinTickerGte *string `form:"min_ticker.gte,omitempty" json:"min_ticker.gte,omitempty"`

	// MinTickerLt Filter less than the value.
	MinTickerLt *string `form:"min_ticker.lt,omitempty" json:"min_ticker.lt,omitempty"`

	// MinTickerLte Filter less than or equal to the value.
	MinTickerLte *string `form:"min_ticker.lte,omitempty" json:"min_ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'period_end' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksFinancialsV1IncomeStatementsParams defines parameters for GetStocksFinancialsV1IncomeStatements.
type GetStocksFinancialsV1IncomeStatementsParams struct {
	// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// Tickers Filter for arrays that contain the value.
	Tickers *string `form:"tickers,omitempty" json:"tickers,omitempty"`

	// TickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
	TickersAllOf *string `form:"tickers.all_of,omitempty" json:"tickers.all_of,omitempty"`

	// TickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
	TickersAnyOf *string `form:"tickers.any_of,omitempty" json:"tickers.any_of,omitempty"`

	// PeriodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted 'yyyy-mm-dd'.
	PeriodEnd *string `form:"period_end,omitempty" json:"period_end,omitempty"`

	// PeriodEndGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGt *string `form:"period_end.gt,omitempty" json:"period_end.gt,omitempty"`

	// PeriodEndGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndGte *string `form:"period_end.gte,omitempty" json:"period_end.gte,omitempty"`

	// PeriodEndLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLt *string `form:"period_end.lt,omitempty" json:"period_end.lt,omitempty"`

	// PeriodEndLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	PeriodEndLte *string `form:"period_end.lte,omitempty" json:"period_end.lte,omitempty"`

	// FilingDate The date when the financial statement was filed with the SEC. Value must be formatted 'yyyy-mm-dd'.
	FilingDate *string `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// FilingDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGt *string `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateGte *string `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLt *string `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// FilingDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	FilingDateLte *string `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// FiscalYear The fiscal year for the reporting period. Value must be a floating point number.
	FiscalYear *float64 `form:"fiscal_year,omitempty" json:"fiscal_year,omitempty"`

	// FiscalYearGt Filter greater than the value. Value must be a floating point number.
	FiscalYearGt *float64 `form:"fiscal_year.gt,omitempty" json:"fiscal_year.gt,omitempty"`

	// FiscalYearGte Filter greater than or equal to the value. Value must be a floating point number.
	FiscalYearGte *float64 `form:"fiscal_year.gte,omitempty" json:"fiscal_year.gte,omitempty"`

	// FiscalYearLt Filter less than the value. Value must be a floating point number.
	FiscalYearLt *float64 `form:"fiscal_year.lt,omitempty" json:"fiscal_year.lt,omitempty"`

	// FiscalYearLte Filter less than or equal to the value. Value must be a floating point number.
	FiscalYearLte *float64 `form:"fiscal_year.lte,omitempty" json:"fiscal_year.lte,omitempty"`

	// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
	FiscalQuarter *float64 `form:"fiscal_quarter,omitempty" json:"fiscal_quarter,omitempty"`

	// FiscalQuarterGt Filter greater than the value. Value must be a floating point number.
	FiscalQuarterGt *float64 `form:"fiscal_quarter.gt,omitempty" json:"fiscal_quarter.gt,omitempty"`

	// FiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number.
	FiscalQuarterGte *float64 `form:"fiscal_quarter.gte,omitempty" json:"fiscal_quarter.gte,omitempty"`

	// FiscalQuarterLt Filter less than the value. Value must be a floating point number.
	FiscalQuarterLt *float64 `form:"fiscal_quarter.lt,omitempty" json:"fiscal_quarter.lt,omitempty"`

	// FiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number.
	FiscalQuarterLte *float64 `form:"fiscal_quarter.lte,omitempty" json:"fiscal_quarter.lte,omitempty"`

	// Timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
	Timeframe *string `form:"timeframe,omitempty" json:"timeframe,omitempty"`

	// TimeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TimeframeAnyOf *string `form:"timeframe.any_of,omitempty" json:"timeframe.any_of,omitempty"`

	// TimeframeGt Filter greater than the value.
	TimeframeGt *string `form:"timeframe.gt,omitempty" json:"timeframe.gt,omitempty"`

	// TimeframeGte Filter greater than or equal to the value.
	TimeframeGte *string `form:"timeframe.gte,omitempty" json:"timeframe.gte,omitempty"`

	// TimeframeLt Filter less than the value.
	TimeframeLt *string `form:"timeframe.lt,omitempty" json:"timeframe.lt,omitempty"`

	// TimeframeLte Filter less than or equal to the value.
	TimeframeLte *string `form:"timeframe.lte,omitempty" json:"timeframe.lte,omitempty"`

	// MaxTicker Filter equal to the value.
	MaxTicker *string `form:"max_ticker,omitempty" json:"max_ticker,omitempty"`

	// MaxTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	MaxTickerAnyOf *string `form:"max_ticker.any_of,omitempty" json:"max_ticker.any_of,omitempty"`

	// MaxTickerGt Filter greater than the value.
	MaxTickerGt *string `form:"max_ticker.gt,omitempty" json:"max_ticker.gt,omitempty"`

	// MaxTickerGte Filter greater than or equal to the value.
	MaxTickerGte *string `form:"max_ticker.gte,omitempty" json:"max_ticker.gte,omitempty"`

	// MaxTickerLt Filter less than the value.
	MaxTickerLt *string `form:"max_ticker.lt,omitempty" json:"max_ticker.lt,omitempty"`

	// MaxTickerLte Filter less than or equal to the value.
	MaxTickerLte *string `form:"max_ticker.lte,omitempty" json:"max_ticker.lte,omitempty"`

	// MinTicker Filter equal to the value.
	MinTicker *string `form:"min_ticker,omitempty" json:"min_ticker,omitempty"`

	// MinTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	MinTickerAnyOf *string `form:"min_ticker.any_of,omitempty" json:"min_ticker.any_of,omitempty"`

	// MinTickerGt Filter greater than the value.
	MinTickerGt *string `form:"min_ticker.gt,omitempty" json:"min_ticker.gt,omitempty"`

	// MinTickerGte Filter greater than or equal to the value.
	MinTickerGte *string `form:"min_ticker.gte,omitempty" json:"min_ticker.gte,omitempty"`

	// MinTickerLt Filter less than the value.
	MinTickerLt *string `form:"min_ticker.lt,omitempty" json:"min_ticker.lt,omitempty"`

	// MinTickerLte Filter less than or equal to the value.
	MinTickerLte *string `form:"min_ticker.lte,omitempty" json:"min_ticker.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'period_end' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksFinancialsV1RatiosParams defines parameters for GetStocksFinancialsV1Ratios.
type GetStocksFinancialsV1RatiosParams struct {
	// Ticker Stock ticker symbol for the company.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Cik Central Index Key (CIK) number assigned by the SEC to identify the company.
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	CikAnyOf *string `form:"cik.any_of,omitempty" json:"cik.any_of,omitempty"`

	// CikGt Filter greater than the value.
	CikGt *string `form:"cik.gt,omitempty" json:"cik.gt,omitempty"`

	// CikGte Filter greater than or equal to the value.
	CikGte *string `form:"cik.gte,omitempty" json:"cik.gte,omitempty"`

	// CikLt Filter less than the value.
	CikLt *string `form:"cik.lt,omitempty" json:"cik.lt,omitempty"`

	// CikLte Filter less than or equal to the value.
	CikLte *string `form:"cik.lte,omitempty" json:"cik.lte,omitempty"`

	// Price Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number.
	Price *float64 `form:"price,omitempty" json:"price,omitempty"`

	// PriceGt Filter greater than the value. Value must be a floating point number.
	PriceGt *float64 `form:"price.gt,omitempty" json:"price.gt,omitempty"`

	// PriceGte Filter greater than or equal to the value. Value must be a floating point number.
	PriceGte *float64 `form:"price.gte,omitempty" json:"price.gte,omitempty"`

	// PriceLt Filter less than the value. Value must be a floating point number.
	PriceLt *float64 `form:"price.lt,omitempty" json:"price.lt,omitempty"`

	// PriceLte Filter less than or equal to the value. Value must be a floating point number.
	PriceLte *float64 `form:"price.lte,omitempty" json:"price.lte,omitempty"`

	// AverageVolume Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number.
	AverageVolume *float64 `form:"average_volume,omitempty" json:"average_volume,omitempty"`

	// AverageVolumeGt Filter greater than the value. Value must be a floating point number.
	AverageVolumeGt *float64 `form:"average_volume.gt,omitempty" json:"average_volume.gt,omitempty"`

	// AverageVolumeGte Filter greater than or equal to the value. Value must be a floating point number.
	AverageVolumeGte *float64 `form:"average_volume.gte,omitempty" json:"average_volume.gte,omitempty"`

	// AverageVolumeLt Filter less than the value. Value must be a floating point number.
	AverageVolumeLt *float64 `form:"average_volume.lt,omitempty" json:"average_volume.lt,omitempty"`

	// AverageVolumeLte Filter less than or equal to the value. Value must be a floating point number.
	AverageVolumeLte *float64 `form:"average_volume.lte,omitempty" json:"average_volume.lte,omitempty"`

	// MarketCap Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number.
	MarketCap *float64 `form:"market_cap,omitempty" json:"market_cap,omitempty"`

	// MarketCapGt Filter greater than the value. Value must be a floating point number.
	MarketCapGt *float64 `form:"market_cap.gt,omitempty" json:"market_cap.gt,omitempty"`

	// MarketCapGte Filter greater than or equal to the value. Value must be a floating point number.
	MarketCapGte *float64 `form:"market_cap.gte,omitempty" json:"market_cap.gte,omitempty"`

	// MarketCapLt Filter less than the value. Value must be a floating point number.
	MarketCapLt *float64 `form:"market_cap.lt,omitempty" json:"market_cap.lt,omitempty"`

	// MarketCapLte Filter less than or equal to the value. Value must be a floating point number.
	MarketCapLte *float64 `form:"market_cap.lte,omitempty" json:"market_cap.lte,omitempty"`

	// EarningsPerShare Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number.
	EarningsPerShare *float64 `form:"earnings_per_share,omitempty" json:"earnings_per_share,omitempty"`

	// EarningsPerShareGt Filter greater than the value. Value must be a floating point number.
	EarningsPerShareGt *float64 `form:"earnings_per_share.gt,omitempty" json:"earnings_per_share.gt,omitempty"`

	// EarningsPerShareGte Filter greater than or equal to the value. Value must be a floating point number.
	EarningsPerShareGte *float64 `form:"earnings_per_share.gte,omitempty" json:"earnings_per_share.gte,omitempty"`

	// EarningsPerShareLt Filter less than the value. Value must be a floating point number.
	EarningsPerShareLt *float64 `form:"earnings_per_share.lt,omitempty" json:"earnings_per_share.lt,omitempty"`

	// EarningsPerShareLte Filter less than or equal to the value. Value must be a floating point number.
	EarningsPerShareLte *float64 `form:"earnings_per_share.lte,omitempty" json:"earnings_per_share.lte,omitempty"`

	// PriceToEarnings Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number.
	PriceToEarnings *float64 `form:"price_to_earnings,omitempty" json:"price_to_earnings,omitempty"`

	// PriceToEarningsGt Filter greater than the value. Value must be a floating point number.
	PriceToEarningsGt *float64 `form:"price_to_earnings.gt,omitempty" json:"price_to_earnings.gt,omitempty"`

	// PriceToEarningsGte Filter greater than or equal to the value. Value must be a floating point number.
	PriceToEarningsGte *float64 `form:"price_to_earnings.gte,omitempty" json:"price_to_earnings.gte,omitempty"`

	// PriceToEarningsLt Filter less than the value. Value must be a floating point number.
	PriceToEarningsLt *float64 `form:"price_to_earnings.lt,omitempty" json:"price_to_earnings.lt,omitempty"`

	// PriceToEarningsLte Filter less than or equal to the value. Value must be a floating point number.
	PriceToEarningsLte *float64 `form:"price_to_earnings.lte,omitempty" json:"price_to_earnings.lte,omitempty"`

	// PriceToBook Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number.
	PriceToBook *float64 `form:"price_to_book,omitempty" json:"price_to_book,omitempty"`

	// PriceToBookGt Filter greater than the value. Value must be a floating point number.
	PriceToBookGt *float64 `form:"price_to_book.gt,omitempty" json:"price_to_book.gt,omitempty"`

	// PriceToBookGte Filter greater than or equal to the value. Value must be a floating point number.
	PriceToBookGte *float64 `form:"price_to_book.gte,omitempty" json:"price_to_book.gte,omitempty"`

	// PriceToBookLt Filter less than the value. Value must be a floating point number.
	PriceToBookLt *float64 `form:"price_to_book.lt,omitempty" json:"price_to_book.lt,omitempty"`

	// PriceToBookLte Filter less than or equal to the value. Value must be a floating point number.
	PriceToBookLte *float64 `form:"price_to_book.lte,omitempty" json:"price_to_book.lte,omitempty"`

	// PriceToSales Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number.
	PriceToSales *float64 `form:"price_to_sales,omitempty" json:"price_to_sales,omitempty"`

	// PriceToSalesGt Filter greater than the value. Value must be a floating point number.
	PriceToSalesGt *float64 `form:"price_to_sales.gt,omitempty" json:"price_to_sales.gt,omitempty"`

	// PriceToSalesGte Filter greater than or equal to the value. Value must be a floating point number.
	PriceToSalesGte *float64 `form:"price_to_sales.gte,omitempty" json:"price_to_sales.gte,omitempty"`

	// PriceToSalesLt Filter less than the value. Value must be a floating point number.
	PriceToSalesLt *float64 `form:"price_to_sales.lt,omitempty" json:"price_to_sales.lt,omitempty"`

	// PriceToSalesLte Filter less than or equal to the value. Value must be a floating point number.
	PriceToSalesLte *float64 `form:"price_to_sales.lte,omitempty" json:"price_to_sales.lte,omitempty"`

	// PriceToCashFlow Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number.
	PriceToCashFlow *float64 `form:"price_to_cash_flow,omitempty" json:"price_to_cash_flow,omitempty"`

	// PriceToCashFlowGt Filter greater than the value. Value must be a floating point number.
	PriceToCashFlowGt *float64 `form:"price_to_cash_flow.gt,omitempty" json:"price_to_cash_flow.gt,omitempty"`

	// PriceToCashFlowGte Filter greater than or equal to the value. Value must be a floating point number.
	PriceToCashFlowGte *float64 `form:"price_to_cash_flow.gte,omitempty" json:"price_to_cash_flow.gte,omitempty"`

	// PriceToCashFlowLt Filter less than the value. Value must be a floating point number.
	PriceToCashFlowLt *float64 `form:"price_to_cash_flow.lt,omitempty" json:"price_to_cash_flow.lt,omitempty"`

	// PriceToCashFlowLte Filter less than or equal to the value. Value must be a floating point number.
	PriceToCashFlowLte *float64 `form:"price_to_cash_flow.lte,omitempty" json:"price_to_cash_flow.lte,omitempty"`

	// PriceToFreeCashFlow Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number.
	PriceToFreeCashFlow *float64 `form:"price_to_free_cash_flow,omitempty" json:"price_to_free_cash_flow,omitempty"`

	// PriceToFreeCashFlowGt Filter greater than the value. Value must be a floating point number.
	PriceToFreeCashFlowGt *float64 `form:"price_to_free_cash_flow.gt,omitempty" json:"price_to_free_cash_flow.gt,omitempty"`

	// PriceToFreeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number.
	PriceToFreeCashFlowGte *float64 `form:"price_to_free_cash_flow.gte,omitempty" json:"price_to_free_cash_flow.gte,omitempty"`

	// PriceToFreeCashFlowLt Filter less than the value. Value must be a floating point number.
	PriceToFreeCashFlowLt *float64 `form:"price_to_free_cash_flow.lt,omitempty" json:"price_to_free_cash_flow.lt,omitempty"`

	// PriceToFreeCashFlowLte Filter less than or equal to the value. Value must be a floating point number.
	PriceToFreeCashFlowLte *float64 `form:"price_to_free_cash_flow.lte,omitempty" json:"price_to_free_cash_flow.lte,omitempty"`

	// DividendYield Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number.
	DividendYield *float64 `form:"dividend_yield,omitempty" json:"dividend_yield,omitempty"`

	// DividendYieldGt Filter greater than the value. Value must be a floating point number.
	DividendYieldGt *float64 `form:"dividend_yield.gt,omitempty" json:"dividend_yield.gt,omitempty"`

	// DividendYieldGte Filter greater than or equal to the value. Value must be a floating point number.
	DividendYieldGte *float64 `form:"dividend_yield.gte,omitempty" json:"dividend_yield.gte,omitempty"`

	// DividendYieldLt Filter less than the value. Value must be a floating point number.
	DividendYieldLt *float64 `form:"dividend_yield.lt,omitempty" json:"dividend_yield.lt,omitempty"`

	// DividendYieldLte Filter less than or equal to the value. Value must be a floating point number.
	DividendYieldLte *float64 `form:"dividend_yield.lte,omitempty" json:"dividend_yield.lte,omitempty"`

	// ReturnOnAssets Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number.
	ReturnOnAssets *float64 `form:"return_on_assets,omitempty" json:"return_on_assets,omitempty"`

	// ReturnOnAssetsGt Filter greater than the value. Value must be a floating point number.
	ReturnOnAssetsGt *float64 `form:"return_on_assets.gt,omitempty" json:"return_on_assets.gt,omitempty"`

	// ReturnOnAssetsGte Filter greater than or equal to the value. Value must be a floating point number.
	ReturnOnAssetsGte *float64 `form:"return_on_assets.gte,omitempty" json:"return_on_assets.gte,omitempty"`

	// ReturnOnAssetsLt Filter less than the value. Value must be a floating point number.
	ReturnOnAssetsLt *float64 `form:"return_on_assets.lt,omitempty" json:"return_on_assets.lt,omitempty"`

	// ReturnOnAssetsLte Filter less than or equal to the value. Value must be a floating point number.
	ReturnOnAssetsLte *float64 `form:"return_on_assets.lte,omitempty" json:"return_on_assets.lte,omitempty"`

	// ReturnOnEquity Return on equity ratio, calculated as net income divided by total shareholders' equity, measuring profitability relative to shareholders' equity. Value must be a floating point number.
	ReturnOnEquity *float64 `form:"return_on_equity,omitempty" json:"return_on_equity,omitempty"`

	// ReturnOnEquityGt Filter greater than the value. Value must be a floating point number.
	ReturnOnEquityGt *float64 `form:"return_on_equity.gt,omitempty" json:"return_on_equity.gt,omitempty"`

	// ReturnOnEquityGte Filter greater than or equal to the value. Value must be a floating point number.
	ReturnOnEquityGte *float64 `form:"return_on_equity.gte,omitempty" json:"return_on_equity.gte,omitempty"`

	// ReturnOnEquityLt Filter less than the value. Value must be a floating point number.
	ReturnOnEquityLt *float64 `form:"return_on_equity.lt,omitempty" json:"return_on_equity.lt,omitempty"`

	// ReturnOnEquityLte Filter less than or equal to the value. Value must be a floating point number.
	ReturnOnEquityLte *float64 `form:"return_on_equity.lte,omitempty" json:"return_on_equity.lte,omitempty"`

	// DebtToEquity Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders' equity, measuring financial leverage. Value must be a floating point number.
	DebtToEquity *float64 `form:"debt_to_equity,omitempty" json:"debt_to_equity,omitempty"`

	// DebtToEquityGt Filter greater than the value. Value must be a floating point number.
	DebtToEquityGt *float64 `form:"debt_to_equity.gt,omitempty" json:"debt_to_equity.gt,omitempty"`

	// DebtToEquityGte Filter greater than or equal to the value. Value must be a floating point number.
	DebtToEquityGte *float64 `form:"debt_to_equity.gte,omitempty" json:"debt_to_equity.gte,omitempty"`

	// DebtToEquityLt Filter less than the value. Value must be a floating point number.
	DebtToEquityLt *float64 `form:"debt_to_equity.lt,omitempty" json:"debt_to_equity.lt,omitempty"`

	// DebtToEquityLte Filter less than or equal to the value. Value must be a floating point number.
	DebtToEquityLte *float64 `form:"debt_to_equity.lte,omitempty" json:"debt_to_equity.lte,omitempty"`

	// Current Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number.
	Current *float64 `form:"current,omitempty" json:"current,omitempty"`

	// CurrentGt Filter greater than the value. Value must be a floating point number.
	CurrentGt *float64 `form:"current.gt,omitempty" json:"current.gt,omitempty"`

	// CurrentGte Filter greater than or equal to the value. Value must be a floating point number.
	CurrentGte *float64 `form:"current.gte,omitempty" json:"current.gte,omitempty"`

	// CurrentLt Filter less than the value. Value must be a floating point number.
	CurrentLt *float64 `form:"current.lt,omitempty" json:"current.lt,omitempty"`

	// CurrentLte Filter less than or equal to the value. Value must be a floating point number.
	CurrentLte *float64 `form:"current.lte,omitempty" json:"current.lte,omitempty"`

	// Quick Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number.
	Quick *float64 `form:"quick,omitempty" json:"quick,omitempty"`

	// QuickGt Filter greater than the value. Value must be a floating point number.
	QuickGt *float64 `form:"quick.gt,omitempty" json:"quick.gt,omitempty"`

	// QuickGte Filter greater than or equal to the value. Value must be a floating point number.
	QuickGte *float64 `form:"quick.gte,omitempty" json:"quick.gte,omitempty"`

	// QuickLt Filter less than the value. Value must be a floating point number.
	QuickLt *float64 `form:"quick.lt,omitempty" json:"quick.lt,omitempty"`

	// QuickLte Filter less than or equal to the value. Value must be a floating point number.
	QuickLte *float64 `form:"quick.lte,omitempty" json:"quick.lte,omitempty"`

	// Cash Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number.
	Cash *float64 `form:"cash,omitempty" json:"cash,omitempty"`

	// CashGt Filter greater than the value. Value must be a floating point number.
	CashGt *float64 `form:"cash.gt,omitempty" json:"cash.gt,omitempty"`

	// CashGte Filter greater than or equal to the value. Value must be a floating point number.
	CashGte *float64 `form:"cash.gte,omitempty" json:"cash.gte,omitempty"`

	// CashLt Filter less than the value. Value must be a floating point number.
	CashLt *float64 `form:"cash.lt,omitempty" json:"cash.lt,omitempty"`

	// CashLte Filter less than or equal to the value. Value must be a floating point number.
	CashLte *float64 `form:"cash.lte,omitempty" json:"cash.lte,omitempty"`

	// EvToSales Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number.
	EvToSales *float64 `form:"ev_to_sales,omitempty" json:"ev_to_sales,omitempty"`

	// EvToSalesGt Filter greater than the value. Value must be a floating point number.
	EvToSalesGt *float64 `form:"ev_to_sales.gt,omitempty" json:"ev_to_sales.gt,omitempty"`

	// EvToSalesGte Filter greater than or equal to the value. Value must be a floating point number.
	EvToSalesGte *float64 `form:"ev_to_sales.gte,omitempty" json:"ev_to_sales.gte,omitempty"`

	// EvToSalesLt Filter less than the value. Value must be a floating point number.
	EvToSalesLt *float64 `form:"ev_to_sales.lt,omitempty" json:"ev_to_sales.lt,omitempty"`

	// EvToSalesLte Filter less than or equal to the value. Value must be a floating point number.
	EvToSalesLte *float64 `form:"ev_to_sales.lte,omitempty" json:"ev_to_sales.lte,omitempty"`

	// EvToEbitda Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number.
	EvToEbitda *float64 `form:"ev_to_ebitda,omitempty" json:"ev_to_ebitda,omitempty"`

	// EvToEbitdaGt Filter greater than the value. Value must be a floating point number.
	EvToEbitdaGt *float64 `form:"ev_to_ebitda.gt,omitempty" json:"ev_to_ebitda.gt,omitempty"`

	// EvToEbitdaGte Filter greater than or equal to the value. Value must be a floating point number.
	EvToEbitdaGte *float64 `form:"ev_to_ebitda.gte,omitempty" json:"ev_to_ebitda.gte,omitempty"`

	// EvToEbitdaLt Filter less than the value. Value must be a floating point number.
	EvToEbitdaLt *float64 `form:"ev_to_ebitda.lt,omitempty" json:"ev_to_ebitda.lt,omitempty"`

	// EvToEbitdaLte Filter less than or equal to the value. Value must be a floating point number.
	EvToEbitdaLte *float64 `form:"ev_to_ebitda.lte,omitempty" json:"ev_to_ebitda.lte,omitempty"`

	// EnterpriseValue Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number.
	EnterpriseValue *float64 `form:"enterprise_value,omitempty" json:"enterprise_value,omitempty"`

	// EnterpriseValueGt Filter greater than the value. Value must be a floating point number.
	EnterpriseValueGt *float64 `form:"enterprise_value.gt,omitempty" json:"enterprise_value.gt,omitempty"`

	// EnterpriseValueGte Filter greater than or equal to the value. Value must be a floating point number.
	EnterpriseValueGte *float64 `form:"enterprise_value.gte,omitempty" json:"enterprise_value.gte,omitempty"`

	// EnterpriseValueLt Filter less than the value. Value must be a floating point number.
	EnterpriseValueLt *float64 `form:"enterprise_value.lt,omitempty" json:"enterprise_value.lt,omitempty"`

	// EnterpriseValueLte Filter less than or equal to the value. Value must be a floating point number.
	EnterpriseValueLte *float64 `form:"enterprise_value.lte,omitempty" json:"enterprise_value.lte,omitempty"`

	// FreeCashFlow Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number.
	FreeCashFlow *float64 `form:"free_cash_flow,omitempty" json:"free_cash_flow,omitempty"`

	// FreeCashFlowGt Filter greater than the value. Value must be a floating point number.
	FreeCashFlowGt *float64 `form:"free_cash_flow.gt,omitempty" json:"free_cash_flow.gt,omitempty"`

	// FreeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number.
	FreeCashFlowGte *float64 `form:"free_cash_flow.gte,omitempty" json:"free_cash_flow.gte,omitempty"`

	// FreeCashFlowLt Filter less than the value. Value must be a floating point number.
	FreeCashFlowLt *float64 `form:"free_cash_flow.lt,omitempty" json:"free_cash_flow.lt,omitempty"`

	// FreeCashFlowLte Filter less than or equal to the value. Value must be a floating point number.
	FreeCashFlowLte *float64 `form:"free_cash_flow.lte,omitempty" json:"free_cash_flow.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksTaxonomiesVXRiskFactorsParams defines parameters for GetStocksTaxonomiesVXRiskFactors.
type GetStocksTaxonomiesVXRiskFactorsParams struct {
	// Taxonomy Version identifier (e.g., '1.0', '1.1') for the taxonomy Value must be a floating point number.
	Taxonomy *float64 `form:"taxonomy,omitempty" json:"taxonomy,omitempty"`

	// TaxonomyGt Filter greater than the value. Value must be a floating point number.
	TaxonomyGt *float64 `form:"taxonomy.gt,omitempty" json:"taxonomy.gt,omitempty"`

	// TaxonomyGte Filter greater than or equal to the value. Value must be a floating point number.
	TaxonomyGte *float64 `form:"taxonomy.gte,omitempty" json:"taxonomy.gte,omitempty"`

	// TaxonomyLt Filter less than the value. Value must be a floating point number.
	TaxonomyLt *float64 `form:"taxonomy.lt,omitempty" json:"taxonomy.lt,omitempty"`

	// TaxonomyLte Filter less than or equal to the value. Value must be a floating point number.
	TaxonomyLte *float64 `form:"taxonomy.lte,omitempty" json:"taxonomy.lte,omitempty"`

	// PrimaryCategory Top-level risk category
	PrimaryCategory *string `form:"primary_category,omitempty" json:"primary_category,omitempty"`

	// PrimaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	PrimaryCategoryAnyOf *string `form:"primary_category.any_of,omitempty" json:"primary_category.any_of,omitempty"`

	// PrimaryCategoryGt Filter greater than the value.
	PrimaryCategoryGt *string `form:"primary_category.gt,omitempty" json:"primary_category.gt,omitempty"`

	// PrimaryCategoryGte Filter greater than or equal to the value.
	PrimaryCategoryGte *string `form:"primary_category.gte,omitempty" json:"primary_category.gte,omitempty"`

	// PrimaryCategoryLt Filter less than the value.
	PrimaryCategoryLt *string `form:"primary_category.lt,omitempty" json:"primary_category.lt,omitempty"`

	// PrimaryCategoryLte Filter less than or equal to the value.
	PrimaryCategoryLte *string `form:"primary_category.lte,omitempty" json:"primary_category.lte,omitempty"`

	// SecondaryCategory Mid-level risk category
	SecondaryCategory *string `form:"secondary_category,omitempty" json:"secondary_category,omitempty"`

	// SecondaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SecondaryCategoryAnyOf *string `form:"secondary_category.any_of,omitempty" json:"secondary_category.any_of,omitempty"`

	// SecondaryCategoryGt Filter greater than the value.
	SecondaryCategoryGt *string `form:"secondary_category.gt,omitempty" json:"secondary_category.gt,omitempty"`

	// SecondaryCategoryGte Filter greater than or equal to the value.
	SecondaryCategoryGte *string `form:"secondary_category.gte,omitempty" json:"secondary_category.gte,omitempty"`

	// SecondaryCategoryLt Filter less than the value.
	SecondaryCategoryLt *string `form:"secondary_category.lt,omitempty" json:"secondary_category.lt,omitempty"`

	// SecondaryCategoryLte Filter less than or equal to the value.
	SecondaryCategoryLte *string `form:"secondary_category.lte,omitempty" json:"secondary_category.lte,omitempty"`

	// TertiaryCategory Most specific risk classification
	TertiaryCategory *string `form:"tertiary_category,omitempty" json:"tertiary_category,omitempty"`

	// TertiaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TertiaryCategoryAnyOf *string `form:"tertiary_category.any_of,omitempty" json:"tertiary_category.any_of,omitempty"`

	// TertiaryCategoryGt Filter greater than the value.
	TertiaryCategoryGt *string `form:"tertiary_category.gt,omitempty" json:"tertiary_category.gt,omitempty"`

	// TertiaryCategoryGte Filter greater than or equal to the value.
	TertiaryCategoryGte *string `form:"tertiary_category.gte,omitempty" json:"tertiary_category.gte,omitempty"`

	// TertiaryCategoryLt Filter less than the value.
	TertiaryCategoryLt *string `form:"tertiary_category.lt,omitempty" json:"tertiary_category.lt,omitempty"`

	// TertiaryCategoryLte Filter less than or equal to the value.
	TertiaryCategoryLte *string `form:"tertiary_category.lte,omitempty" json:"tertiary_category.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '200' if not specified. The maximum allowed limit is '999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'taxonomy' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksV1DividendsParams defines parameters for GetStocksV1Dividends.
type GetStocksV1DividendsParams struct {
	// Ticker Stock symbol for the company issuing the dividend
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// ExDividendDate Date when the stock begins trading without the dividend value Value must be formatted 'yyyy-mm-dd'.
	ExDividendDate *string `form:"ex_dividend_date,omitempty" json:"ex_dividend_date,omitempty"`

	// ExDividendDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ExDividendDateGt *string `form:"ex_dividend_date.gt,omitempty" json:"ex_dividend_date.gt,omitempty"`

	// ExDividendDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ExDividendDateGte *string `form:"ex_dividend_date.gte,omitempty" json:"ex_dividend_date.gte,omitempty"`

	// ExDividendDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ExDividendDateLt *string `form:"ex_dividend_date.lt,omitempty" json:"ex_dividend_date.lt,omitempty"`

	// ExDividendDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ExDividendDateLte *string `form:"ex_dividend_date.lte,omitempty" json:"ex_dividend_date.lte,omitempty"`

	// Frequency How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 52 (weekly), 104 (bi-weekly), and 365 (daily) depending on the issuer's declared or inferred payout cadence. Value must be an integer.
	Frequency *int64 `form:"frequency,omitempty" json:"frequency,omitempty"`

	// FrequencyGt Filter greater than the value. Value must be an integer.
	FrequencyGt *int64 `form:"frequency.gt,omitempty" json:"frequency.gt,omitempty"`

	// FrequencyGte Filter greater than or equal to the value. Value must be an integer.
	FrequencyGte *int64 `form:"frequency.gte,omitempty" json:"frequency.gte,omitempty"`

	// FrequencyLt Filter less than the value. Value must be an integer.
	FrequencyLt *int64 `form:"frequency.lt,omitempty" json:"frequency.lt,omitempty"`

	// FrequencyLte Filter less than or equal to the value. Value must be an integer.
	FrequencyLte *int64 `form:"frequency.lte,omitempty" json:"frequency.lte,omitempty"`

	// DistributionType Classification describing the nature of this dividend's recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
	DistributionType *GetStocksV1DividendsParamsDistributionType `form:"distribution_type,omitempty" json:"distribution_type,omitempty"`

	// DistributionTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DistributionTypeAnyOf *GetStocksV1DividendsParamsDistributionTypeAnyOf `form:"distribution_type.any_of,omitempty" json:"distribution_type.any_of,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksV1DividendsParamsDistributionType defines parameters for GetStocksV1Dividends.
type GetStocksV1DividendsParamsDistributionType string

// GetStocksV1DividendsParamsDistributionTypeAnyOf defines parameters for GetStocksV1Dividends.
type GetStocksV1DividendsParamsDistributionTypeAnyOf string

// GetStocksV1ExchangesParams defines parameters for GetStocksV1Exchanges.
type GetStocksV1ExchangesParams struct {
	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '999'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetStocksV1ShortInterestParams defines parameters for GetStocksV1ShortInterest.
type GetStocksV1ShortInterestParams struct {
	// Ticker The primary ticker symbol for the stock.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// DaysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
	DaysToCover *float64 `form:"days_to_cover,omitempty" json:"days_to_cover,omitempty"`

	// DaysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
	DaysToCoverAnyOf *string `form:"days_to_cover.any_of,omitempty" json:"days_to_cover.any_of,omitempty"`

	// DaysToCoverGt Filter greater than the value. Value must be a floating point number.
	DaysToCoverGt *float64 `form:"days_to_cover.gt,omitempty" json:"days_to_cover.gt,omitempty"`

	// DaysToCoverGte Filter greater than or equal to the value. Value must be a floating point number.
	DaysToCoverGte *float64 `form:"days_to_cover.gte,omitempty" json:"days_to_cover.gte,omitempty"`

	// DaysToCoverLt Filter less than the value. Value must be a floating point number.
	DaysToCoverLt *float64 `form:"days_to_cover.lt,omitempty" json:"days_to_cover.lt,omitempty"`

	// DaysToCoverLte Filter less than or equal to the value. Value must be a floating point number.
	DaysToCoverLte *float64 `form:"days_to_cover.lte,omitempty" json:"days_to_cover.lte,omitempty"`

	// SettlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
	SettlementDate *string `form:"settlement_date,omitempty" json:"settlement_date,omitempty"`

	// SettlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	SettlementDateAnyOf *string `form:"settlement_date.any_of,omitempty" json:"settlement_date.any_of,omitempty"`

	// SettlementDateGt Filter greater than the value.
	SettlementDateGt *string `form:"settlement_date.gt,omitempty" json:"settlement_date.gt,omitempty"`

	// SettlementDateGte Filter greater than or equal to the value.
	SettlementDateGte *string `form:"settlement_date.gte,omitempty" json:"settlement_date.gte,omitempty"`

	// SettlementDateLt Filter less than the value.
	SettlementDateLt *string `form:"settlement_date.lt,omitempty" json:"settlement_date.lt,omitempty"`

	// SettlementDateLte Filter less than or equal to the value.
	SettlementDateLte *string `form:"settlement_date.lte,omitempty" json:"settlement_date.lte,omitempty"`

	// AvgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
	AvgDailyVolume *int64 `form:"avg_daily_volume,omitempty" json:"avg_daily_volume,omitempty"`

	// AvgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
	AvgDailyVolumeAnyOf *string `form:"avg_daily_volume.any_of,omitempty" json:"avg_daily_volume.any_of,omitempty"`

	// AvgDailyVolumeGt Filter greater than the value. Value must be an integer.
	AvgDailyVolumeGt *int64 `form:"avg_daily_volume.gt,omitempty" json:"avg_daily_volume.gt,omitempty"`

	// AvgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer.
	AvgDailyVolumeGte *int64 `form:"avg_daily_volume.gte,omitempty" json:"avg_daily_volume.gte,omitempty"`

	// AvgDailyVolumeLt Filter less than the value. Value must be an integer.
	AvgDailyVolumeLt *int64 `form:"avg_daily_volume.lt,omitempty" json:"avg_daily_volume.lt,omitempty"`

	// AvgDailyVolumeLte Filter less than or equal to the value. Value must be an integer.
	AvgDailyVolumeLte *int64 `form:"avg_daily_volume.lte,omitempty" json:"avg_daily_volume.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '10' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksV1ShortVolumeParams defines parameters for GetStocksV1ShortVolume.
type GetStocksV1ShortVolumeParams struct {
	// Ticker The primary ticker symbol for the stock.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Date The date of trade activity reported in the format YYYY-MM-DD
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// ShortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
	ShortVolumeRatio *float64 `form:"short_volume_ratio,omitempty" json:"short_volume_ratio,omitempty"`

	// ShortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
	ShortVolumeRatioAnyOf *string `form:"short_volume_ratio.any_of,omitempty" json:"short_volume_ratio.any_of,omitempty"`

	// ShortVolumeRatioGt Filter greater than the value. Value must be a floating point number.
	ShortVolumeRatioGt *float64 `form:"short_volume_ratio.gt,omitempty" json:"short_volume_ratio.gt,omitempty"`

	// ShortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number.
	ShortVolumeRatioGte *float64 `form:"short_volume_ratio.gte,omitempty" json:"short_volume_ratio.gte,omitempty"`

	// ShortVolumeRatioLt Filter less than the value. Value must be a floating point number.
	ShortVolumeRatioLt *float64 `form:"short_volume_ratio.lt,omitempty" json:"short_volume_ratio.lt,omitempty"`

	// ShortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number.
	ShortVolumeRatioLte *float64 `form:"short_volume_ratio.lte,omitempty" json:"short_volume_ratio.lte,omitempty"`

	// TotalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer.
	TotalVolume *int64 `form:"total_volume,omitempty" json:"total_volume,omitempty"`

	// TotalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
	TotalVolumeAnyOf *string `form:"total_volume.any_of,omitempty" json:"total_volume.any_of,omitempty"`

	// TotalVolumeGt Filter greater than the value. Value must be an integer.
	TotalVolumeGt *int64 `form:"total_volume.gt,omitempty" json:"total_volume.gt,omitempty"`

	// TotalVolumeGte Filter greater than or equal to the value. Value must be an integer.
	TotalVolumeGte *int64 `form:"total_volume.gte,omitempty" json:"total_volume.gte,omitempty"`

	// TotalVolumeLt Filter less than the value. Value must be an integer.
	TotalVolumeLt *int64 `form:"total_volume.lt,omitempty" json:"total_volume.lt,omitempty"`

	// TotalVolumeLte Filter less than or equal to the value. Value must be an integer.
	TotalVolumeLte *int64 `form:"total_volume.lte,omitempty" json:"total_volume.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '10' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksV1SplitsParams defines parameters for GetStocksV1Splits.
type GetStocksV1SplitsParams struct {
	// Ticker Stock symbol for the company that executed the split
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// ExecutionDate Date when the stock split was applied and shares adjusted Value must be formatted 'yyyy-mm-dd'.
	ExecutionDate *string `form:"execution_date,omitempty" json:"execution_date,omitempty"`

	// ExecutionDateGt Filter greater than the value. Value must be formatted 'yyyy-mm-dd'.
	ExecutionDateGt *string `form:"execution_date.gt,omitempty" json:"execution_date.gt,omitempty"`

	// ExecutionDateGte Filter greater than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ExecutionDateGte *string `form:"execution_date.gte,omitempty" json:"execution_date.gte,omitempty"`

	// ExecutionDateLt Filter less than the value. Value must be formatted 'yyyy-mm-dd'.
	ExecutionDateLt *string `form:"execution_date.lt,omitempty" json:"execution_date.lt,omitempty"`

	// ExecutionDateLte Filter less than or equal to the value. Value must be formatted 'yyyy-mm-dd'.
	ExecutionDateLte *string `form:"execution_date.lte,omitempty" json:"execution_date.lte,omitempty"`

	// AdjustmentType Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
	AdjustmentType *GetStocksV1SplitsParamsAdjustmentType `form:"adjustment_type,omitempty" json:"adjustment_type,omitempty"`

	// AdjustmentTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	AdjustmentTypeAnyOf *GetStocksV1SplitsParamsAdjustmentTypeAnyOf `form:"adjustment_type.any_of,omitempty" json:"adjustment_type.any_of,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'execution_date' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksV1SplitsParamsAdjustmentType defines parameters for GetStocksV1Splits.
type GetStocksV1SplitsParamsAdjustmentType string

// GetStocksV1SplitsParamsAdjustmentTypeAnyOf defines parameters for GetStocksV1Splits.
type GetStocksV1SplitsParamsAdjustmentTypeAnyOf string

// GetStocksVXFloatParams defines parameters for GetStocksVXFloat.
type GetStocksVXFloatParams struct {
	// Ticker The primary ticker symbol for the stock.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// FreeFloatPercent Percentage of total shares outstanding that are available for public trading, rounded to two decimal places. Value must be a floating point number.
	FreeFloatPercent *float64 `form:"free_float_percent,omitempty" json:"free_float_percent,omitempty"`

	// FreeFloatPercentGt Filter greater than the value. Value must be a floating point number.
	FreeFloatPercentGt *float64 `form:"free_float_percent.gt,omitempty" json:"free_float_percent.gt,omitempty"`

	// FreeFloatPercentGte Filter greater than or equal to the value. Value must be a floating point number.
	FreeFloatPercentGte *float64 `form:"free_float_percent.gte,omitempty" json:"free_float_percent.gte,omitempty"`

	// FreeFloatPercentLt Filter less than the value. Value must be a floating point number.
	FreeFloatPercentLt *float64 `form:"free_float_percent.lt,omitempty" json:"free_float_percent.lt,omitempty"`

	// FreeFloatPercentLte Filter less than or equal to the value. Value must be a floating point number.
	FreeFloatPercentLte *float64 `form:"free_float_percent.lte,omitempty" json:"free_float_percent.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '5000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'ticker' if not specified. The sort order defaults to 'asc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetTmxV1CorporateEventsParams defines parameters for GetTmxV1CorporateEvents.
type GetTmxV1CorporateEventsParams struct {
	// Date Scheduled date of the corporate event, formatted as YYYY-MM-DD.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// DateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	DateAnyOf *string `form:"date.any_of,omitempty" json:"date.any_of,omitempty"`

	// DateGt Filter greater than the value.
	DateGt *string `form:"date.gt,omitempty" json:"date.gt,omitempty"`

	// DateGte Filter greater than or equal to the value.
	DateGte *string `form:"date.gte,omitempty" json:"date.gte,omitempty"`

	// DateLt Filter less than the value.
	DateLt *string `form:"date.lt,omitempty" json:"date.lt,omitempty"`

	// DateLte Filter less than or equal to the value.
	DateLte *string `form:"date.lte,omitempty" json:"date.lte,omitempty"`

	// Type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// TypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TypeAnyOf *string `form:"type.any_of,omitempty" json:"type.any_of,omitempty"`

	// TypeGt Filter greater than the value.
	TypeGt *string `form:"type.gt,omitempty" json:"type.gt,omitempty"`

	// TypeGte Filter greater than or equal to the value.
	TypeGte *string `form:"type.gte,omitempty" json:"type.gte,omitempty"`

	// TypeLt Filter less than the value.
	TypeLt *string `form:"type.lt,omitempty" json:"type.lt,omitempty"`

	// TypeLte Filter less than or equal to the value.
	TypeLte *string `form:"type.lte,omitempty" json:"type.lte,omitempty"`

	// Status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// StatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	StatusAnyOf *string `form:"status.any_of,omitempty" json:"status.any_of,omitempty"`

	// StatusGt Filter greater than the value.
	StatusGt *string `form:"status.gt,omitempty" json:"status.gt,omitempty"`

	// StatusGte Filter greater than or equal to the value.
	StatusGte *string `form:"status.gte,omitempty" json:"status.gte,omitempty"`

	// StatusLt Filter less than the value.
	StatusLt *string `form:"status.lt,omitempty" json:"status.lt,omitempty"`

	// StatusLte Filter less than or equal to the value.
	StatusLte *string `form:"status.lte,omitempty" json:"status.lte,omitempty"`

	// Ticker The company's stock symbol.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// Isin Standard international identifier for the company's common stock.
	Isin *string `form:"isin,omitempty" json:"isin,omitempty"`

	// IsinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	IsinAnyOf *string `form:"isin.any_of,omitempty" json:"isin.any_of,omitempty"`

	// IsinGt Filter greater than the value.
	IsinGt *string `form:"isin.gt,omitempty" json:"isin.gt,omitempty"`

	// IsinGte Filter greater than or equal to the value.
	IsinGte *string `form:"isin.gte,omitempty" json:"isin.gte,omitempty"`

	// IsinLt Filter less than the value.
	IsinLt *string `form:"isin.lt,omitempty" json:"isin.lt,omitempty"`

	// IsinLte Filter less than or equal to the value.
	IsinLte *string `form:"isin.lte,omitempty" json:"isin.lte,omitempty"`

	// TradingVenue MIC (Market Identifier Code) of the exchange where the company's stock is listed.
	TradingVenue *string `form:"trading_venue,omitempty" json:"trading_venue,omitempty"`

	// TradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TradingVenueAnyOf *string `form:"trading_venue.any_of,omitempty" json:"trading_venue.any_of,omitempty"`

	// TradingVenueGt Filter greater than the value.
	TradingVenueGt *string `form:"trading_venue.gt,omitempty" json:"trading_venue.gt,omitempty"`

	// TradingVenueGte Filter greater than or equal to the value.
	TradingVenueGte *string `form:"trading_venue.gte,omitempty" json:"trading_venue.gte,omitempty"`

	// TradingVenueLt Filter less than the value.
	TradingVenueLt *string `form:"trading_venue.lt,omitempty" json:"trading_venue.lt,omitempty"`

	// TradingVenueLte Filter less than or equal to the value.
	TradingVenueLte *string `form:"trading_venue.lte,omitempty" json:"trading_venue.lte,omitempty"`

	// TmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer.
	TmxCompanyId *int64 `form:"tmx_company_id,omitempty" json:"tmx_company_id,omitempty"`

	// TmxCompanyIdGt Filter greater than the value. Value must be an integer.
	TmxCompanyIdGt *int64 `form:"tmx_company_id.gt,omitempty" json:"tmx_company_id.gt,omitempty"`

	// TmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer.
	TmxCompanyIdGte *int64 `form:"tmx_company_id.gte,omitempty" json:"tmx_company_id.gte,omitempty"`

	// TmxCompanyIdLt Filter less than the value. Value must be an integer.
	TmxCompanyIdLt *int64 `form:"tmx_company_id.lt,omitempty" json:"tmx_company_id.lt,omitempty"`

	// TmxCompanyIdLte Filter less than or equal to the value. Value must be an integer.
	TmxCompanyIdLte *int64 `form:"tmx_company_id.lte,omitempty" json:"tmx_company_id.lte,omitempty"`

	// TmxRecordId The unique alphanumeric identifier for the event record used by TMX.
	TmxRecordId *string `form:"tmx_record_id,omitempty" json:"tmx_record_id,omitempty"`

	// TmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TmxRecordIdAnyOf *string `form:"tmx_record_id.any_of,omitempty" json:"tmx_record_id.any_of,omitempty"`

	// TmxRecordIdGt Filter greater than the value.
	TmxRecordIdGt *string `form:"tmx_record_id.gt,omitempty" json:"tmx_record_id.gt,omitempty"`

	// TmxRecordIdGte Filter greater than or equal to the value.
	TmxRecordIdGte *string `form:"tmx_record_id.gte,omitempty" json:"tmx_record_id.gte,omitempty"`

	// TmxRecordIdLt Filter less than the value.
	TmxRecordIdLt *string `form:"tmx_record_id.lt,omitempty" json:"tmx_record_id.lt,omitempty"`

	// TmxRecordIdLte Filter less than or equal to the value.
	TmxRecordIdLte *string `form:"tmx_record_id.lte,omitempty" json:"tmx_record_id.lte,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '100' if not specified. The maximum allowed limit is '50000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'date' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetCurrencyConversionParams defines parameters for GetCurrencyConversion.
type GetCurrencyConversionParams struct {
	// Amount The amount to convert, with a decimal.
	Amount *float32 `form:"amount,omitempty" json:"amount,omitempty"`

	// Precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
	Precision *GetCurrencyConversionParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// GetCurrencyConversionParamsPrecision defines parameters for GetCurrencyConversion.
type GetCurrencyConversionParamsPrecision int

// DeprecatedGetHistoricCryptoTradesParams defines parameters for DeprecatedGetHistoricCryptoTrades.
type DeprecatedGetHistoricCryptoTradesParams struct {
	// Offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the `timestamp` of the last result as the offset will give you the next page of results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the size of the response, max 10000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeprecatedGetHistoricForexQuotesParams defines parameters for DeprecatedGetHistoricForexQuotes.
type DeprecatedGetHistoricForexQuotesParams struct {
	// Offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the `timestamp` of the last result as the offset will give you the next page of results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the size of the response, max 10000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCryptoEMAParams defines parameters for GetCryptoEMA.
type GetCryptoEMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetCryptoEMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close prices to
	// calculate the exponential moving average (EMA).
	SeriesType *GetCryptoEMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetCryptoEMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetCryptoEMAParamsTimespan defines parameters for GetCryptoEMA.
type GetCryptoEMAParamsTimespan string

// GetCryptoEMAParamsSeriesType defines parameters for GetCryptoEMA.
type GetCryptoEMAParamsSeriesType string

// GetCryptoEMAParamsOrder defines parameters for GetCryptoEMA.
type GetCryptoEMAParamsOrder string

// GetForexEMAParams defines parameters for GetForexEMA.
type GetForexEMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetForexEMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close prices to
	// calculate the exponential moving average (EMA).
	SeriesType *GetForexEMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetForexEMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetForexEMAParamsTimespan defines parameters for GetForexEMA.
type GetForexEMAParamsTimespan string

// GetForexEMAParamsSeriesType defines parameters for GetForexEMA.
type GetForexEMAParamsSeriesType string

// GetForexEMAParamsOrder defines parameters for GetForexEMA.
type GetForexEMAParamsOrder string

// GetIndicesEMAParams defines parameters for GetIndicesEMA.
type GetIndicesEMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetIndicesEMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The value in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close values to
	// calculate the exponential moving average (EMA).
	SeriesType *GetIndicesEMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetIndicesEMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetIndicesEMAParamsTimespan defines parameters for GetIndicesEMA.
type GetIndicesEMAParamsTimespan string

// GetIndicesEMAParamsSeriesType defines parameters for GetIndicesEMA.
type GetIndicesEMAParamsSeriesType string

// GetIndicesEMAParamsOrder defines parameters for GetIndicesEMA.
type GetIndicesEMAParamsOrder string

// GetOptionsEMAParams defines parameters for GetOptionsEMA.
type GetOptionsEMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetOptionsEMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close prices to
	// calculate the exponential moving average (EMA).
	SeriesType *GetOptionsEMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetOptionsEMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetOptionsEMAParamsTimespan defines parameters for GetOptionsEMA.
type GetOptionsEMAParamsTimespan string

// GetOptionsEMAParamsSeriesType defines parameters for GetOptionsEMA.
type GetOptionsEMAParamsSeriesType string

// GetOptionsEMAParamsOrder defines parameters for GetOptionsEMA.
type GetOptionsEMAParamsOrder string

// GetStocksEMAParams defines parameters for GetStocksEMA.
type GetStocksEMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetStocksEMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close prices to
	// calculate the exponential moving average (EMA).
	SeriesType *GetStocksEMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetStocksEMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetStocksEMAParamsTimespan defines parameters for GetStocksEMA.
type GetStocksEMAParamsTimespan string

// GetStocksEMAParamsSeriesType defines parameters for GetStocksEMA.
type GetStocksEMAParamsSeriesType string

// GetStocksEMAParamsOrder defines parameters for GetStocksEMA.
type GetStocksEMAParamsOrder string

// GetCryptoMACDParams defines parameters for GetCryptoMACD.
type GetCryptoMACDParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetCryptoMACDParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// ShortWindow The short window size used to calculate MACD data.
	ShortWindow *int `form:"short_window,omitempty" json:"short_window,omitempty"`

	// LongWindow The long window size used to calculate MACD data.
	LongWindow *int `form:"long_window,omitempty" json:"long_window,omitempty"`

	// SignalWindow The window size used to calculate the MACD signal line.
	SignalWindow *int `form:"signal_window,omitempty" json:"signal_window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate MACD data. i.e. 'close' will result in using close prices to
	// calculate the MACD.
	SeriesType *GetCryptoMACDParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetCryptoMACDParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetCryptoMACDParamsTimespan defines parameters for GetCryptoMACD.
type GetCryptoMACDParamsTimespan string

// GetCryptoMACDParamsSeriesType defines parameters for GetCryptoMACD.
type GetCryptoMACDParamsSeriesType string

// GetCryptoMACDParamsOrder defines parameters for GetCryptoMACD.
type GetCryptoMACDParamsOrder string

// GetForexMACDParams defines parameters for GetForexMACD.
type GetForexMACDParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetForexMACDParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// ShortWindow The short window size used to calculate MACD data.
	ShortWindow *int `form:"short_window,omitempty" json:"short_window,omitempty"`

	// LongWindow The long window size used to calculate MACD data.
	LongWindow *int `form:"long_window,omitempty" json:"long_window,omitempty"`

	// SignalWindow The window size used to calculate the MACD signal line.
	SignalWindow *int `form:"signal_window,omitempty" json:"signal_window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the MACD. i.e. 'close' will result in using close prices to
	// calculate the MACD.
	SeriesType *GetForexMACDParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetForexMACDParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetForexMACDParamsTimespan defines parameters for GetForexMACD.
type GetForexMACDParamsTimespan string

// GetForexMACDParamsSeriesType defines parameters for GetForexMACD.
type GetForexMACDParamsSeriesType string

// GetForexMACDParamsOrder defines parameters for GetForexMACD.
type GetForexMACDParamsOrder string

// GetIndicesMACDParams defines parameters for GetIndicesMACD.
type GetIndicesMACDParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetIndicesMACDParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// ShortWindow The short window size used to calculate MACD data.
	ShortWindow *int `form:"short_window,omitempty" json:"short_window,omitempty"`

	// LongWindow The long window size used to calculate MACD data.
	LongWindow *int `form:"long_window,omitempty" json:"long_window,omitempty"`

	// SignalWindow The window size used to calculate the MACD signal line.
	SignalWindow *int `form:"signal_window,omitempty" json:"signal_window,omitempty"`

	// SeriesType The value in the aggregate which will be used to calculate the MACD. i.e. 'close' will result in using close values to
	// calculate the MACD.
	SeriesType *GetIndicesMACDParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetIndicesMACDParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetIndicesMACDParamsTimespan defines parameters for GetIndicesMACD.
type GetIndicesMACDParamsTimespan string

// GetIndicesMACDParamsSeriesType defines parameters for GetIndicesMACD.
type GetIndicesMACDParamsSeriesType string

// GetIndicesMACDParamsOrder defines parameters for GetIndicesMACD.
type GetIndicesMACDParamsOrder string

// GetOptionsMACDParams defines parameters for GetOptionsMACD.
type GetOptionsMACDParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetOptionsMACDParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// ShortWindow The short window size used to calculate MACD data.
	ShortWindow *int `form:"short_window,omitempty" json:"short_window,omitempty"`

	// LongWindow The long window size used to calculate MACD data.
	LongWindow *int `form:"long_window,omitempty" json:"long_window,omitempty"`

	// SignalWindow The window size used to calculate the MACD signal line.
	SignalWindow *int `form:"signal_window,omitempty" json:"signal_window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the MACD. i.e. 'close' will result in using close prices to
	// calculate the MACD.
	SeriesType *GetOptionsMACDParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetOptionsMACDParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetOptionsMACDParamsTimespan defines parameters for GetOptionsMACD.
type GetOptionsMACDParamsTimespan string

// GetOptionsMACDParamsSeriesType defines parameters for GetOptionsMACD.
type GetOptionsMACDParamsSeriesType string

// GetOptionsMACDParamsOrder defines parameters for GetOptionsMACD.
type GetOptionsMACDParamsOrder string

// GetStocksMACDParams defines parameters for GetStocksMACD.
type GetStocksMACDParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetStocksMACDParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// ShortWindow The short window size used to calculate MACD data.
	ShortWindow *int `form:"short_window,omitempty" json:"short_window,omitempty"`

	// LongWindow The long window size used to calculate MACD data.
	LongWindow *int `form:"long_window,omitempty" json:"long_window,omitempty"`

	// SignalWindow The window size used to calculate the MACD signal line.
	SignalWindow *int `form:"signal_window,omitempty" json:"signal_window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the MACD. i.e. 'close' will result in using close prices to
	// calculate the MACD.
	SeriesType *GetStocksMACDParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetStocksMACDParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetStocksMACDParamsTimespan defines parameters for GetStocksMACD.
type GetStocksMACDParamsTimespan string

// GetStocksMACDParamsSeriesType defines parameters for GetStocksMACD.
type GetStocksMACDParamsSeriesType string

// GetStocksMACDParamsOrder defines parameters for GetStocksMACD.
type GetStocksMACDParamsOrder string

// GetCryptoRSIParams defines parameters for GetCryptoRSI.
type GetCryptoRSIParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetCryptoRSIParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Window The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close prices to
	// calculate the relative strength index (RSI).
	SeriesType *GetCryptoRSIParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetCryptoRSIParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetCryptoRSIParamsTimespan defines parameters for GetCryptoRSI.
type GetCryptoRSIParamsTimespan string

// GetCryptoRSIParamsSeriesType defines parameters for GetCryptoRSI.
type GetCryptoRSIParamsSeriesType string

// GetCryptoRSIParamsOrder defines parameters for GetCryptoRSI.
type GetCryptoRSIParamsOrder string

// GetForexRSIParams defines parameters for GetForexRSI.
type GetForexRSIParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetForexRSIParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the relative strength index (RSI).
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close prices to
	// calculate the relative strength index (RSI).
	SeriesType *GetForexRSIParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetForexRSIParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetForexRSIParamsTimespan defines parameters for GetForexRSI.
type GetForexRSIParamsTimespan string

// GetForexRSIParamsSeriesType defines parameters for GetForexRSI.
type GetForexRSIParamsSeriesType string

// GetForexRSIParamsOrder defines parameters for GetForexRSI.
type GetForexRSIParamsOrder string

// GetIndicesRSIParams defines parameters for GetIndicesRSI.
type GetIndicesRSIParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetIndicesRSIParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the relative strength index (RSI).
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The value in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close values to
	// calculate the relative strength index (RSI).
	SeriesType *GetIndicesRSIParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetIndicesRSIParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetIndicesRSIParamsTimespan defines parameters for GetIndicesRSI.
type GetIndicesRSIParamsTimespan string

// GetIndicesRSIParamsSeriesType defines parameters for GetIndicesRSI.
type GetIndicesRSIParamsSeriesType string

// GetIndicesRSIParamsOrder defines parameters for GetIndicesRSI.
type GetIndicesRSIParamsOrder string

// GetOptionsRSIParams defines parameters for GetOptionsRSI.
type GetOptionsRSIParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetOptionsRSIParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the relative strength index (RSI).
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close prices to
	// calculate the relative strength index (RSI).
	SeriesType *GetOptionsRSIParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetOptionsRSIParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetOptionsRSIParamsTimespan defines parameters for GetOptionsRSI.
type GetOptionsRSIParamsTimespan string

// GetOptionsRSIParamsSeriesType defines parameters for GetOptionsRSI.
type GetOptionsRSIParamsSeriesType string

// GetOptionsRSIParamsOrder defines parameters for GetOptionsRSI.
type GetOptionsRSIParamsOrder string

// GetStocksRSIParams defines parameters for GetStocksRSI.
type GetStocksRSIParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetStocksRSIParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the relative strength index (RSI).
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close prices to
	// calculate the relative strength index (RSI).
	SeriesType *GetStocksRSIParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetStocksRSIParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetStocksRSIParamsTimespan defines parameters for GetStocksRSI.
type GetStocksRSIParamsTimespan string

// GetStocksRSIParamsSeriesType defines parameters for GetStocksRSI.
type GetStocksRSIParamsSeriesType string

// GetStocksRSIParamsOrder defines parameters for GetStocksRSI.
type GetStocksRSIParamsOrder string

// GetCryptoSMAParams defines parameters for GetCryptoSMA.
type GetCryptoSMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetCryptoSMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close prices to
	// calculate the simple moving average (SMA).
	SeriesType *GetCryptoSMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetCryptoSMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetCryptoSMAParamsTimespan defines parameters for GetCryptoSMA.
type GetCryptoSMAParamsTimespan string

// GetCryptoSMAParamsSeriesType defines parameters for GetCryptoSMA.
type GetCryptoSMAParamsSeriesType string

// GetCryptoSMAParamsOrder defines parameters for GetCryptoSMA.
type GetCryptoSMAParamsOrder string

// GetForexSMAParams defines parameters for GetForexSMA.
type GetForexSMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetForexSMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close prices to
	// calculate the simple moving average (SMA).
	SeriesType *GetForexSMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetForexSMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetForexSMAParamsTimespan defines parameters for GetForexSMA.
type GetForexSMAParamsTimespan string

// GetForexSMAParamsSeriesType defines parameters for GetForexSMA.
type GetForexSMAParamsSeriesType string

// GetForexSMAParamsOrder defines parameters for GetForexSMA.
type GetForexSMAParamsOrder string

// GetIndicesSMAParams defines parameters for GetIndicesSMA.
type GetIndicesSMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetIndicesSMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The value in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close values to
	// calculate the simple moving average (SMA).
	SeriesType *GetIndicesSMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetIndicesSMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetIndicesSMAParamsTimespan defines parameters for GetIndicesSMA.
type GetIndicesSMAParamsTimespan string

// GetIndicesSMAParamsSeriesType defines parameters for GetIndicesSMA.
type GetIndicesSMAParamsSeriesType string

// GetIndicesSMAParamsOrder defines parameters for GetIndicesSMA.
type GetIndicesSMAParamsOrder string

// GetOptionsSMAParams defines parameters for GetOptionsSMA.
type GetOptionsSMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetOptionsSMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close prices to
	// calculate the simple moving average (SMA).
	SeriesType *GetOptionsSMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetOptionsSMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetOptionsSMAParamsTimespan defines parameters for GetOptionsSMA.
type GetOptionsSMAParamsTimespan string

// GetOptionsSMAParamsSeriesType defines parameters for GetOptionsSMA.
type GetOptionsSMAParamsSeriesType string

// GetOptionsSMAParamsOrder defines parameters for GetOptionsSMA.
type GetOptionsSMAParamsOrder string

// GetStocksSMAParams defines parameters for GetStocksSMA.
type GetStocksSMAParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// Timespan The size of the aggregate time window.
	Timespan *GetStocksSMAParamsTimespan `form:"timespan,omitempty" json:"timespan,omitempty"`

	// Adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
	Window *int `form:"window,omitempty" json:"window,omitempty"`

	// SeriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close prices to
	// calculate the simple moving average (SMA).
	SeriesType *GetStocksSMAParamsSeriesType `form:"series_type,omitempty" json:"series_type,omitempty"`

	// ExpandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response.
	ExpandUnderlying *bool `form:"expand_underlying,omitempty" json:"expand_underlying,omitempty"`

	// Order The order in which to return the results, ordered by timestamp.
	Order *GetStocksSMAParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 5000
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`
}

// GetStocksSMAParamsTimespan defines parameters for GetStocksSMA.
type GetStocksSMAParamsTimespan string

// GetStocksSMAParamsSeriesType defines parameters for GetStocksSMA.
type GetStocksSMAParamsSeriesType string

// GetStocksSMAParamsOrder defines parameters for GetStocksSMA.
type GetStocksSMAParamsOrder string

// GetCryptoOpenCloseParams defines parameters for GetCryptoOpenClose.
type GetCryptoOpenCloseParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetOptionsOpenCloseParams defines parameters for GetOptionsOpenClose.
type GetOptionsOpenCloseParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetStocksOpenCloseParams defines parameters for GetStocksOpenClose.
type GetStocksOpenCloseParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetV1ReferenceIposParams defines parameters for GetV1ReferenceIpos.
type GetV1ReferenceIposParams struct {
	// Ticker The ticker symbol of the IPO event.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// TickerGt Filter greater than the value.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerGte Filter greater than or equal to the value.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerLt Filter less than the value.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerLte Filter less than or equal to the value.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// UsCode Nine-character alphanumeric code that uniquely identifies a financial security in North America.
	UsCode *string `form:"us_code,omitempty" json:"us_code,omitempty"`

	// UsCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	UsCodeAnyOf *string `form:"us_code.any_of,omitempty" json:"us_code.any_of,omitempty"`

	// UsCodeGt Filter greater than the value.
	UsCodeGt *string `form:"us_code.gt,omitempty" json:"us_code.gt,omitempty"`

	// UsCodeGte Filter greater than or equal to the value.
	UsCodeGte *string `form:"us_code.gte,omitempty" json:"us_code.gte,omitempty"`

	// UsCodeLt Filter less than the value.
	UsCodeLt *string `form:"us_code.lt,omitempty" json:"us_code.lt,omitempty"`

	// UsCodeLte Filter less than or equal to the value.
	UsCodeLte *string `form:"us_code.lte,omitempty" json:"us_code.lte,omitempty"`

	// Isin International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
	Isin *string `form:"isin,omitempty" json:"isin,omitempty"`

	// IsinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	IsinAnyOf *string `form:"isin.any_of,omitempty" json:"isin.any_of,omitempty"`

	// IsinGt Filter greater than the value.
	IsinGt *string `form:"isin.gt,omitempty" json:"isin.gt,omitempty"`

	// IsinGte Filter greater than or equal to the value.
	IsinGte *string `form:"isin.gte,omitempty" json:"isin.gte,omitempty"`

	// IsinLt Filter less than the value.
	IsinLt *string `form:"isin.lt,omitempty" json:"isin.lt,omitempty"`

	// IsinLte Filter less than or equal to the value.
	IsinLte *string `form:"isin.lte,omitempty" json:"isin.lte,omitempty"`

	// ListingDate First trading date for the newly listed entity. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	ListingDate *string `form:"listing_date,omitempty" json:"listing_date,omitempty"`

	// ListingDateGt Filter greater than the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	ListingDateGt *string `form:"listing_date.gt,omitempty" json:"listing_date.gt,omitempty"`

	// ListingDateGte Filter greater than or equal to the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	ListingDateGte *string `form:"listing_date.gte,omitempty" json:"listing_date.gte,omitempty"`

	// ListingDateLt Filter less than the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	ListingDateLt *string `form:"listing_date.lt,omitempty" json:"listing_date.lt,omitempty"`

	// ListingDateLte Filter less than or equal to the value. Value must be an integer timestamp in nanoseconds, formatted 'yyyy-mm-dd', or ISO 8601/RFC 3339 (e.g. '2024-05-28T20:27:41Z').
	ListingDateLte *string `form:"listing_date.lte,omitempty" json:"listing_date.lte,omitempty"`

	// IpoStatus The status of the IPO.
	IpoStatus *GetV1ReferenceIposParamsIpoStatus `form:"ipo_status,omitempty" json:"ipo_status,omitempty"`

	// IpoStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
	IpoStatusAnyOf *GetV1ReferenceIposParamsIpoStatusAnyOf `form:"ipo_status.any_of,omitempty" json:"ipo_status.any_of,omitempty"`

	// Limit Limit the maximum number of results returned. Defaults to '10' if not specified. The maximum allowed limit is '1000'.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort A comma separated list of sort columns. For each column, append '.asc' or '.desc' to specify the sort direction. The sort column defaults to 'listing_date' if not specified. The sort order defaults to 'desc' if not specified.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetV1ReferenceIposParamsIpoStatus defines parameters for GetV1ReferenceIpos.
type GetV1ReferenceIposParamsIpoStatus string

// GetV1ReferenceIposParamsIpoStatusAnyOf defines parameters for GetV1ReferenceIpos.
type GetV1ReferenceIposParamsIpoStatusAnyOf string

// GetSnapshotSummaryParams defines parameters for GetSnapshotSummary.
type GetSnapshotSummaryParams struct {
	// TickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See <a rel="nofollow" target="_blank" href="https://massive.com/docs/rest/stocks/tickers/all-tickers">the tickers endpoint</a> for more details on supported tickers. If no tickers are passed then no results will be returned.
	//
	// Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`
}

// GetGroupedCryptoAggregatesParams defines parameters for GetGroupedCryptoAggregates.
type GetGroupedCryptoAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetGroupedForexAggregatesParams defines parameters for GetGroupedForexAggregates.
type GetGroupedForexAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetGroupedStocksAggregatesParams defines parameters for GetGroupedStocksAggregates.
type GetGroupedStocksAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// IncludeOtc Include OTC securities in the response. Default is false (don't include OTC securities).
	IncludeOtc *bool `form:"include_otc,omitempty" json:"include_otc,omitempty"`
}

// GetPreviousCryptoAggregatesParams defines parameters for GetPreviousCryptoAggregates.
type GetPreviousCryptoAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetCryptoAggregatesParams defines parameters for GetCryptoAggregates.
type GetCryptoAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Sort Sort the results by timestamp.
	// `asc` will return results in ascending order (oldest at the top),
	// `desc` will return results in descending order (newest at the top).
	Sort interface{} `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000.
	// Read more about how limit is used to calculate aggregate results in our article on
	// <a href="https://massive.com/blog/aggs-api-updates/" target="_blank" alt="Aggregate Data API Improvements">Aggregate Data API Improvements</a>.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCryptoAggregatesParamsTimespan defines parameters for GetCryptoAggregates.
type GetCryptoAggregatesParamsTimespan string

// GetPreviousForexAggregatesParams defines parameters for GetPreviousForexAggregates.
type GetPreviousForexAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetForexAggregatesParams defines parameters for GetForexAggregates.
type GetForexAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Sort Sort the results by timestamp.
	// `asc` will return results in ascending order (oldest at the top),
	// `desc` will return results in descending order (newest at the top).
	Sort interface{} `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000.
	// Read more about how limit is used to calculate aggregate results in our article on
	// <a href="https://massive.com/blog/aggs-api-updates/" target="_blank" alt="Aggregate Data API Improvements">Aggregate Data API Improvements</a>.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetForexAggregatesParamsTimespan defines parameters for GetForexAggregates.
type GetForexAggregatesParamsTimespan string

// GetIndicesAggregatesParams defines parameters for GetIndicesAggregates.
type GetIndicesAggregatesParams struct {
	// Sort Sort the results by timestamp.
	// `asc` will return results in ascending order (oldest at the top),
	// `desc` will return results in descending order (newest at the top).
	Sort interface{} `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000.
	// Read more about how limit is used to calculate aggregate results in our article on
	// <a href="https://massive.com/blog/aggs-api-updates/" target="_blank" alt="Aggregate Data API Improvements">Aggregate Data API Improvements</a>.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetIndicesAggregatesParamsTimespan defines parameters for GetIndicesAggregates.
type GetIndicesAggregatesParamsTimespan string

// GetPreviousOptionsAggregatesParams defines parameters for GetPreviousOptionsAggregates.
type GetPreviousOptionsAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetOptionsAggregatesParams defines parameters for GetOptionsAggregates.
type GetOptionsAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Sort Sort the results by timestamp.
	// `asc` will return results in ascending order (oldest at the top),
	// `desc` will return results in descending order (newest at the top).
	Sort interface{} `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000.
	// Read more about how limit is used to calculate aggregate results in our article on
	// <a href="https://massive.com/blog/aggs-api-updates/" target="_blank" alt="Aggregate Data API Improvements">Aggregate Data API Improvements</a>.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetOptionsAggregatesParamsTimespan defines parameters for GetOptionsAggregates.
type GetOptionsAggregatesParamsTimespan string

// GetPreviousStocksAggregatesParams defines parameters for GetPreviousStocksAggregates.
type GetPreviousStocksAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`
}

// GetStocksAggregatesParams defines parameters for GetStocksAggregates.
type GetStocksAggregatesParams struct {
	// Adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted.
	// Set this to false to get results that are NOT adjusted for splits.
	Adjusted *bool `form:"adjusted,omitempty" json:"adjusted,omitempty"`

	// Sort Sort the results by timestamp.
	// `asc` will return results in ascending order (oldest at the top),
	// `desc` will return results in descending order (newest at the top).
	Sort interface{} `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000.
	// Read more about how limit is used to calculate aggregate results in our article on
	// <a href="https://massive.com/blog/aggs-api-updates/" target="_blank" alt="Aggregate Data API Improvements">Aggregate Data API Improvements</a>.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetStocksAggregatesParamsTimespan defines parameters for GetStocksAggregates.
type GetStocksAggregatesParamsTimespan string

// ListNewsParams defines parameters for ListNews.
type ListNewsParams struct {
	// Ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// PublishedUtc Return results published on, before, or after this date.
	PublishedUtc *struct {
		union json.RawMessage
	} `form:"published_utc,omitempty" json:"published_utc,omitempty"`

	// TickerGte Search by ticker.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerGt Search by ticker.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerLte Search by ticker.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// TickerLt Search by ticker.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// PublishedUtcGte Search by published_utc.
	PublishedUtcGte *struct {
		union json.RawMessage
	} `form:"published_utc.gte,omitempty" json:"published_utc.gte,omitempty"`

	// PublishedUtcGt Search by published_utc.
	PublishedUtcGt *struct {
		union json.RawMessage
	} `form:"published_utc.gt,omitempty" json:"published_utc.gt,omitempty"`

	// PublishedUtcLte Search by published_utc.
	PublishedUtcLte *struct {
		union json.RawMessage
	} `form:"published_utc.lte,omitempty" json:"published_utc.lte,omitempty"`

	// PublishedUtcLt Search by published_utc.
	PublishedUtcLt *struct {
		union json.RawMessage
	} `form:"published_utc.lt,omitempty" json:"published_utc.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListNewsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListNewsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListNewsParamsPublishedUtc0 defines parameters for ListNews.
type ListNewsParamsPublishedUtc0 = time.Time

// ListNewsParamsPublishedUtc1 defines parameters for ListNews.
type ListNewsParamsPublishedUtc1 = openapi_types.Date

// ListNewsParamsPublishedUtcGte0 defines parameters for ListNews.
type ListNewsParamsPublishedUtcGte0 = time.Time

// ListNewsParamsPublishedUtcGte1 defines parameters for ListNews.
type ListNewsParamsPublishedUtcGte1 = openapi_types.Date

// ListNewsParamsPublishedUtcGt0 defines parameters for ListNews.
type ListNewsParamsPublishedUtcGt0 = time.Time

// ListNewsParamsPublishedUtcGt1 defines parameters for ListNews.
type ListNewsParamsPublishedUtcGt1 = openapi_types.Date

// ListNewsParamsPublishedUtcLte0 defines parameters for ListNews.
type ListNewsParamsPublishedUtcLte0 = time.Time

// ListNewsParamsPublishedUtcLte1 defines parameters for ListNews.
type ListNewsParamsPublishedUtcLte1 = openapi_types.Date

// ListNewsParamsPublishedUtcLt0 defines parameters for ListNews.
type ListNewsParamsPublishedUtcLt0 = time.Time

// ListNewsParamsPublishedUtcLt1 defines parameters for ListNews.
type ListNewsParamsPublishedUtcLt1 = openapi_types.Date

// ListNewsParamsOrder defines parameters for ListNews.
type ListNewsParamsOrder string

// ListNewsParamsSort defines parameters for ListNews.
type ListNewsParamsSort string

// GetCryptoSnapshotTickersParams defines parameters for GetCryptoSnapshotTickers.
type GetCryptoSnapshotTickersParams struct {
	// Tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
	Tickers *[]string `form:"tickers,omitempty" json:"tickers,omitempty"`
}

// GetCryptoSnapshotDirectionParamsDirection defines parameters for GetCryptoSnapshotDirection.
type GetCryptoSnapshotDirectionParamsDirection string

// GetForexSnapshotTickersParams defines parameters for GetForexSnapshotTickers.
type GetForexSnapshotTickersParams struct {
	// Tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
	Tickers *[]string `form:"tickers,omitempty" json:"tickers,omitempty"`
}

// GetForexSnapshotDirectionParamsDirection defines parameters for GetForexSnapshotDirection.
type GetForexSnapshotDirectionParamsDirection string

// GetStocksSnapshotTickersParams defines parameters for GetStocksSnapshotTickers.
type GetStocksSnapshotTickersParams struct {
	// Tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
	Tickers *[]string `form:"tickers,omitempty" json:"tickers,omitempty"`

	// IncludeOtc Include OTC securities in the response. Default is false (don't include OTC securities).
	IncludeOtc *bool `form:"include_otc,omitempty" json:"include_otc,omitempty"`
}

// GetStocksSnapshotDirectionParams defines parameters for GetStocksSnapshotDirection.
type GetStocksSnapshotDirectionParams struct {
	// IncludeOtc Include OTC securities in the response. Default is false (don't include OTC securities).
	IncludeOtc *bool `form:"include_otc,omitempty" json:"include_otc,omitempty"`
}

// GetStocksSnapshotDirectionParamsDirection defines parameters for GetStocksSnapshotDirection.
type GetStocksSnapshotDirectionParamsDirection string

// DeprecatedGetHistoricStocksQuotesParams defines parameters for DeprecatedGetHistoricStocksQuotes.
type DeprecatedGetHistoricStocksQuotesParams struct {
	// Timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the `timestamp` of the last result as the offset will give you the next page of results.
	Timestamp *int `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampLimit The maximum timestamp allowed in the results.
	TimestampLimit *int `form:"timestampLimit,omitempty" json:"timestampLimit,omitempty"`

	// Reverse Reverse the order of the results.
	Reverse *bool `form:"reverse,omitempty" json:"reverse,omitempty"`

	// Limit Limit the size of the response, max 50000 and default 5000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeprecatedGetHistoricStocksTradesParams defines parameters for DeprecatedGetHistoricStocksTrades.
type DeprecatedGetHistoricStocksTradesParams struct {
	// Timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the `timestamp` of the last result as the offset will give you the next page of results.
	Timestamp *int `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampLimit The maximum timestamp allowed in the results.
	TimestampLimit *int `form:"timestampLimit,omitempty" json:"timestampLimit,omitempty"`

	// Reverse Reverse the order of the results.
	Reverse *bool `form:"reverse,omitempty" json:"reverse,omitempty"`

	// Limit Limit the size of the response, max 50000 and default 5000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetForexQuotesParams defines parameters for GetForexQuotes.
type GetForexQuotesParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetForexQuotesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 1000 and max is 50000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetForexQuotesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetForexQuotesParamsOrder defines parameters for GetForexQuotes.
type GetForexQuotesParamsOrder string

// GetForexQuotesParamsSort defines parameters for GetForexQuotes.
type GetForexQuotesParamsSort string

// GetOptionsQuotesParams defines parameters for GetOptionsQuotes.
type GetOptionsQuotesParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetOptionsQuotesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 1000 and max is 50000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetOptionsQuotesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetOptionsQuotesParamsOrder defines parameters for GetOptionsQuotes.
type GetOptionsQuotesParamsOrder string

// GetOptionsQuotesParamsSort defines parameters for GetOptionsQuotes.
type GetOptionsQuotesParamsSort string

// GetStocksQuotesParams defines parameters for GetStocksQuotes.
type GetStocksQuotesParams struct {
	// Timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetStocksQuotesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 1000 and max is 50000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetStocksQuotesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksQuotesParamsOrder defines parameters for GetStocksQuotes.
type GetStocksQuotesParamsOrder string

// GetStocksQuotesParamsSort defines parameters for GetStocksQuotes.
type GetStocksQuotesParamsSort string

// ListConditionsParams defines parameters for ListConditions.
type ListConditionsParams struct {
	// AssetClass Filter for conditions within a given asset class.
	AssetClass *ListConditionsParamsAssetClass `form:"asset_class,omitempty" json:"asset_class,omitempty"`

	// DataType Filter by data type.
	DataType *ListConditionsParamsDataType `form:"data_type,omitempty" json:"data_type,omitempty"`

	// Id Filter for conditions with a given ID.
	Id *int `form:"id,omitempty" json:"id,omitempty"`

	// Sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
	Sip *ListConditionsParamsSip `form:"sip,omitempty" json:"sip,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListConditionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListConditionsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListConditionsParamsAssetClass defines parameters for ListConditions.
type ListConditionsParamsAssetClass string

// ListConditionsParamsDataType defines parameters for ListConditions.
type ListConditionsParamsDataType string

// ListConditionsParamsSip defines parameters for ListConditions.
type ListConditionsParamsSip string

// ListConditionsParamsOrder defines parameters for ListConditions.
type ListConditionsParamsOrder string

// ListConditionsParamsSort defines parameters for ListConditions.
type ListConditionsParamsSort string

// ListDividendsParams defines parameters for ListDividends.
type ListDividendsParams struct {
	// Ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// ExDividendDate Query by ex-dividend date with the format YYYY-MM-DD.
	ExDividendDate *openapi_types.Date `form:"ex_dividend_date,omitempty" json:"ex_dividend_date,omitempty"`

	// RecordDate Query by record date with the format YYYY-MM-DD.
	RecordDate *openapi_types.Date `form:"record_date,omitempty" json:"record_date,omitempty"`

	// DeclarationDate Query by declaration date with the format YYYY-MM-DD.
	DeclarationDate *openapi_types.Date `form:"declaration_date,omitempty" json:"declaration_date,omitempty"`

	// PayDate Query by pay date with the format YYYY-MM-DD.
	PayDate *openapi_types.Date `form:"pay_date,omitempty" json:"pay_date,omitempty"`

	// Frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
	Frequency *ListDividendsParamsFrequency `form:"frequency,omitempty" json:"frequency,omitempty"`

	// CashAmount Query by the cash amount of the dividend.
	CashAmount *float32 `form:"cash_amount,omitempty" json:"cash_amount,omitempty"`

	// DividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD.
	// Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
	DividendType *ListDividendsParamsDividendType `form:"dividend_type,omitempty" json:"dividend_type,omitempty"`

	// TickerGte Range by ticker.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerGt Range by ticker.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerLte Range by ticker.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// TickerLt Range by ticker.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// ExDividendDateGte Range by ex_dividend_date.
	ExDividendDateGte *openapi_types.Date `form:"ex_dividend_date.gte,omitempty" json:"ex_dividend_date.gte,omitempty"`

	// ExDividendDateGt Range by ex_dividend_date.
	ExDividendDateGt *openapi_types.Date `form:"ex_dividend_date.gt,omitempty" json:"ex_dividend_date.gt,omitempty"`

	// ExDividendDateLte Range by ex_dividend_date.
	ExDividendDateLte *openapi_types.Date `form:"ex_dividend_date.lte,omitempty" json:"ex_dividend_date.lte,omitempty"`

	// ExDividendDateLt Range by ex_dividend_date.
	ExDividendDateLt *openapi_types.Date `form:"ex_dividend_date.lt,omitempty" json:"ex_dividend_date.lt,omitempty"`

	// RecordDateGte Range by record_date.
	RecordDateGte *openapi_types.Date `form:"record_date.gte,omitempty" json:"record_date.gte,omitempty"`

	// RecordDateGt Range by record_date.
	RecordDateGt *openapi_types.Date `form:"record_date.gt,omitempty" json:"record_date.gt,omitempty"`

	// RecordDateLte Range by record_date.
	RecordDateLte *openapi_types.Date `form:"record_date.lte,omitempty" json:"record_date.lte,omitempty"`

	// RecordDateLt Range by record_date.
	RecordDateLt *openapi_types.Date `form:"record_date.lt,omitempty" json:"record_date.lt,omitempty"`

	// DeclarationDateGte Range by declaration_date.
	DeclarationDateGte *openapi_types.Date `form:"declaration_date.gte,omitempty" json:"declaration_date.gte,omitempty"`

	// DeclarationDateGt Range by declaration_date.
	DeclarationDateGt *openapi_types.Date `form:"declaration_date.gt,omitempty" json:"declaration_date.gt,omitempty"`

	// DeclarationDateLte Range by declaration_date.
	DeclarationDateLte *openapi_types.Date `form:"declaration_date.lte,omitempty" json:"declaration_date.lte,omitempty"`

	// DeclarationDateLt Range by declaration_date.
	DeclarationDateLt *openapi_types.Date `form:"declaration_date.lt,omitempty" json:"declaration_date.lt,omitempty"`

	// PayDateGte Range by pay_date.
	PayDateGte *openapi_types.Date `form:"pay_date.gte,omitempty" json:"pay_date.gte,omitempty"`

	// PayDateGt Range by pay_date.
	PayDateGt *openapi_types.Date `form:"pay_date.gt,omitempty" json:"pay_date.gt,omitempty"`

	// PayDateLte Range by pay_date.
	PayDateLte *openapi_types.Date `form:"pay_date.lte,omitempty" json:"pay_date.lte,omitempty"`

	// PayDateLt Range by pay_date.
	PayDateLt *openapi_types.Date `form:"pay_date.lt,omitempty" json:"pay_date.lt,omitempty"`

	// CashAmountGte Range by cash_amount.
	CashAmountGte *float32 `form:"cash_amount.gte,omitempty" json:"cash_amount.gte,omitempty"`

	// CashAmountGt Range by cash_amount.
	CashAmountGt *float32 `form:"cash_amount.gt,omitempty" json:"cash_amount.gt,omitempty"`

	// CashAmountLte Range by cash_amount.
	CashAmountLte *float32 `form:"cash_amount.lte,omitempty" json:"cash_amount.lte,omitempty"`

	// CashAmountLt Range by cash_amount.
	CashAmountLt *float32 `form:"cash_amount.lt,omitempty" json:"cash_amount.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListDividendsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListDividendsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListDividendsParamsFrequency defines parameters for ListDividends.
type ListDividendsParamsFrequency int

// ListDividendsParamsDividendType defines parameters for ListDividends.
type ListDividendsParamsDividendType string

// ListDividendsParamsOrder defines parameters for ListDividends.
type ListDividendsParamsOrder string

// ListDividendsParamsSort defines parameters for ListDividends.
type ListDividendsParamsSort string

// ListExchangesParams defines parameters for ListExchanges.
type ListExchangesParams struct {
	// AssetClass Filter by asset class.
	AssetClass *ListExchangesParamsAssetClass `form:"asset_class,omitempty" json:"asset_class,omitempty"`

	// Locale Filter by locale.
	Locale *ListExchangesParamsLocale `form:"locale,omitempty" json:"locale,omitempty"`
}

// ListExchangesParamsAssetClass defines parameters for ListExchanges.
type ListExchangesParamsAssetClass string

// ListExchangesParamsLocale defines parameters for ListExchanges.
type ListExchangesParamsLocale string

// ListOptionsContractsParams defines parameters for ListOptionsContracts.
type ListOptionsContractsParams struct {
	// UnderlyingTicker Query for contracts relating to an underlying stock ticker.
	UnderlyingTicker *string `form:"underlying_ticker,omitempty" json:"underlying_ticker,omitempty"`

	// Ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview).
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// ContractType Query by the type of contract.
	ContractType *ListOptionsContractsParamsContractType `form:"contract_type,omitempty" json:"contract_type,omitempty"`

	// ExpirationDate Query by contract expiration with date format YYYY-MM-DD.
	ExpirationDate *string `form:"expiration_date,omitempty" json:"expiration_date,omitempty"`

	// AsOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today's date.
	AsOf *string `form:"as_of,omitempty" json:"as_of,omitempty"`

	// StrikePrice Query by strike price of a contract.
	StrikePrice *float32 `form:"strike_price,omitempty" json:"strike_price,omitempty"`

	// Expired Query for expired contracts. Default is false.
	Expired *bool `form:"expired,omitempty" json:"expired,omitempty"`

	// UnderlyingTickerGte Range by underlying_ticker.
	UnderlyingTickerGte *string `form:"underlying_ticker.gte,omitempty" json:"underlying_ticker.gte,omitempty"`

	// UnderlyingTickerGt Range by underlying_ticker.
	UnderlyingTickerGt *string `form:"underlying_ticker.gt,omitempty" json:"underlying_ticker.gt,omitempty"`

	// UnderlyingTickerLte Range by underlying_ticker.
	UnderlyingTickerLte *string `form:"underlying_ticker.lte,omitempty" json:"underlying_ticker.lte,omitempty"`

	// UnderlyingTickerLt Range by underlying_ticker.
	UnderlyingTickerLt *string `form:"underlying_ticker.lt,omitempty" json:"underlying_ticker.lt,omitempty"`

	// ExpirationDateGte Range by expiration_date.
	ExpirationDateGte *string `form:"expiration_date.gte,omitempty" json:"expiration_date.gte,omitempty"`

	// ExpirationDateGt Range by expiration_date.
	ExpirationDateGt *string `form:"expiration_date.gt,omitempty" json:"expiration_date.gt,omitempty"`

	// ExpirationDateLte Range by expiration_date.
	ExpirationDateLte *string `form:"expiration_date.lte,omitempty" json:"expiration_date.lte,omitempty"`

	// ExpirationDateLt Range by expiration_date.
	ExpirationDateLt *string `form:"expiration_date.lt,omitempty" json:"expiration_date.lt,omitempty"`

	// StrikePriceGte Range by strike_price.
	StrikePriceGte *float32 `form:"strike_price.gte,omitempty" json:"strike_price.gte,omitempty"`

	// StrikePriceGt Range by strike_price.
	StrikePriceGt *float32 `form:"strike_price.gt,omitempty" json:"strike_price.gt,omitempty"`

	// StrikePriceLte Range by strike_price.
	StrikePriceLte *float32 `form:"strike_price.lte,omitempty" json:"strike_price.lte,omitempty"`

	// StrikePriceLt Range by strike_price.
	StrikePriceLt *float32 `form:"strike_price.lt,omitempty" json:"strike_price.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListOptionsContractsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListOptionsContractsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListOptionsContractsParamsContractType defines parameters for ListOptionsContracts.
type ListOptionsContractsParamsContractType string

// ListOptionsContractsParamsOrder defines parameters for ListOptionsContracts.
type ListOptionsContractsParamsOrder string

// ListOptionsContractsParamsSort defines parameters for ListOptionsContracts.
type ListOptionsContractsParamsSort string

// GetOptionsContractParams defines parameters for GetOptionsContract.
type GetOptionsContractParams struct {
	// AsOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today's date.
	AsOf *string `form:"as_of,omitempty" json:"as_of,omitempty"`
}

// ListStockSplitsParams defines parameters for ListStockSplits.
type ListStockSplitsParams struct {
	// Ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// ExecutionDate Query by execution date with the format YYYY-MM-DD.
	ExecutionDate *openapi_types.Date `form:"execution_date,omitempty" json:"execution_date,omitempty"`

	// ReverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
	ReverseSplit *bool `form:"reverse_split,omitempty" json:"reverse_split,omitempty"`

	// TickerGte Range by ticker.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerGt Range by ticker.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerLte Range by ticker.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// TickerLt Range by ticker.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// ExecutionDateGte Range by execution_date.
	ExecutionDateGte *openapi_types.Date `form:"execution_date.gte,omitempty" json:"execution_date.gte,omitempty"`

	// ExecutionDateGt Range by execution_date.
	ExecutionDateGt *openapi_types.Date `form:"execution_date.gt,omitempty" json:"execution_date.gt,omitempty"`

	// ExecutionDateLte Range by execution_date.
	ExecutionDateLte *openapi_types.Date `form:"execution_date.lte,omitempty" json:"execution_date.lte,omitempty"`

	// ExecutionDateLt Range by execution_date.
	ExecutionDateLt *openapi_types.Date `form:"execution_date.lt,omitempty" json:"execution_date.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListStockSplitsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListStockSplitsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListStockSplitsParamsOrder defines parameters for ListStockSplits.
type ListStockSplitsParamsOrder string

// ListStockSplitsParamsSort defines parameters for ListStockSplits.
type ListStockSplitsParamsSort string

// ListTickersParams defines parameters for ListTickers.
type ListTickersParams struct {
	// Ticker Specify a ticker symbol.
	// Defaults to empty string which queries all tickers.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// Type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
	// Defaults to empty string which queries all types.
	Type *ListTickersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Market Filter by market type. By default all markets are included.
	Market *ListTickersParamsMarket `form:"market,omitempty" json:"market,omitempty"`

	// Exchange Specify the asset's primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes).
	// Defaults to empty string which queries all exchanges.
	Exchange *string `form:"exchange,omitempty" json:"exchange,omitempty"`

	// Cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP).
	// Defaults to empty string which queries all CUSIPs.
	//
	// Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
	Cusip *string `form:"cusip,omitempty" json:"cusip,omitempty"`

	// Cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm).
	// Defaults to empty string which queries all CIKs.
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// Date Specify a point in time to retrieve tickers available on that date.
	// Defaults to the most recent available date.
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Search Search for terms within the ticker and/or company name.
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Active Specify if the tickers returned should be actively traded on the queried date. Default is true.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// TickerGte Range by ticker.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerGt Range by ticker.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerLte Range by ticker.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// TickerLt Range by ticker.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListTickersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 100 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListTickersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListTickersParamsType defines parameters for ListTickers.
type ListTickersParamsType string

// ListTickersParamsMarket defines parameters for ListTickers.
type ListTickersParamsMarket string

// ListTickersParamsOrder defines parameters for ListTickers.
type ListTickersParamsOrder string

// ListTickersParamsSort defines parameters for ListTickers.
type ListTickersParamsSort string

// ListTickerTypesParams defines parameters for ListTickerTypes.
type ListTickerTypesParams struct {
	// AssetClass Filter by asset class.
	AssetClass *ListTickerTypesParamsAssetClass `form:"asset_class,omitempty" json:"asset_class,omitempty"`

	// Locale Filter by locale.
	Locale *ListTickerTypesParamsLocale `form:"locale,omitempty" json:"locale,omitempty"`
}

// ListTickerTypesParamsAssetClass defines parameters for ListTickerTypes.
type ListTickerTypesParamsAssetClass string

// ListTickerTypesParamsLocale defines parameters for ListTickerTypes.
type ListTickerTypesParamsLocale string

// GetTickerParams defines parameters for GetTicker.
type GetTickerParams struct {
	// Date Specify a point in time to get information about the ticker available on that date.
	// When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.
	//
	// For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29.
	// That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29.
	// If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.
	//
	// Defaults to the most recent available date.
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`
}

// GetSnapshotsParams defines parameters for GetSnapshots.
type GetSnapshotsParams struct {
	// Ticker Search a range of tickers lexicographically.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// Type Query by the type of asset.
	Type *GetSnapshotsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// TickerGte Range by ticker.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerGt Range by ticker.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerLte Range by ticker.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// TickerLt Range by ticker.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// TickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.
	//
	// Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetSnapshotsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 250.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetSnapshotsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetSnapshotsParamsType defines parameters for GetSnapshots.
type GetSnapshotsParamsType string

// GetSnapshotsParamsOrder defines parameters for GetSnapshots.
type GetSnapshotsParamsOrder string

// GetSnapshotsParamsSort defines parameters for GetSnapshots.
type GetSnapshotsParamsSort string

// GetIndicesSnapshotParams defines parameters for GetIndicesSnapshot.
type GetIndicesSnapshotParams struct {
	// TickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.
	//
	// Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
	TickerAnyOf *string `form:"ticker.any_of,omitempty" json:"ticker.any_of,omitempty"`

	// Ticker Search a range of tickers lexicographically.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// TickerGte Range by ticker.
	TickerGte *string `form:"ticker.gte,omitempty" json:"ticker.gte,omitempty"`

	// TickerGt Range by ticker.
	TickerGt *string `form:"ticker.gt,omitempty" json:"ticker.gt,omitempty"`

	// TickerLte Range by ticker.
	TickerLte *string `form:"ticker.lte,omitempty" json:"ticker.lte,omitempty"`

	// TickerLt Range by ticker.
	TickerLt *string `form:"ticker.lt,omitempty" json:"ticker.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetIndicesSnapshotParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 250.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetIndicesSnapshotParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetIndicesSnapshotParamsOrder defines parameters for GetIndicesSnapshot.
type GetIndicesSnapshotParamsOrder string

// GetIndicesSnapshotParamsSort defines parameters for GetIndicesSnapshot.
type GetIndicesSnapshotParamsSort string

// GetOptionsChainParams defines parameters for GetOptionsChain.
type GetOptionsChainParams struct {
	// StrikePrice Query by strike price of a contract.
	StrikePrice *float32 `form:"strike_price,omitempty" json:"strike_price,omitempty"`

	// ExpirationDate Query by contract expiration with date format YYYY-MM-DD.
	ExpirationDate *string `form:"expiration_date,omitempty" json:"expiration_date,omitempty"`

	// ContractType Query by the type of contract.
	ContractType *GetOptionsChainParamsContractType `form:"contract_type,omitempty" json:"contract_type,omitempty"`

	// StrikePriceGte Range by strike_price.
	StrikePriceGte *float32 `form:"strike_price.gte,omitempty" json:"strike_price.gte,omitempty"`

	// StrikePriceGt Range by strike_price.
	StrikePriceGt *float32 `form:"strike_price.gt,omitempty" json:"strike_price.gt,omitempty"`

	// StrikePriceLte Range by strike_price.
	StrikePriceLte *float32 `form:"strike_price.lte,omitempty" json:"strike_price.lte,omitempty"`

	// StrikePriceLt Range by strike_price.
	StrikePriceLt *float32 `form:"strike_price.lt,omitempty" json:"strike_price.lt,omitempty"`

	// ExpirationDateGte Range by expiration_date.
	ExpirationDateGte *string `form:"expiration_date.gte,omitempty" json:"expiration_date.gte,omitempty"`

	// ExpirationDateGt Range by expiration_date.
	ExpirationDateGt *string `form:"expiration_date.gt,omitempty" json:"expiration_date.gt,omitempty"`

	// ExpirationDateLte Range by expiration_date.
	ExpirationDateLte *string `form:"expiration_date.lte,omitempty" json:"expiration_date.lte,omitempty"`

	// ExpirationDateLt Range by expiration_date.
	ExpirationDateLt *string `form:"expiration_date.lt,omitempty" json:"expiration_date.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetOptionsChainParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 250.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetOptionsChainParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetOptionsChainParamsContractType defines parameters for GetOptionsChain.
type GetOptionsChainParamsContractType string

// GetOptionsChainParamsOrder defines parameters for GetOptionsChain.
type GetOptionsChainParamsOrder string

// GetOptionsChainParamsSort defines parameters for GetOptionsChain.
type GetOptionsChainParamsSort string

// GetCryptoTradesParams defines parameters for GetCryptoTrades.
type GetCryptoTradesParams struct {
	// Timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetCryptoTradesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 1000 and max is 50000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetCryptoTradesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetCryptoTradesParamsOrder defines parameters for GetCryptoTrades.
type GetCryptoTradesParamsOrder string

// GetCryptoTradesParamsSort defines parameters for GetCryptoTrades.
type GetCryptoTradesParamsSort string

// GetOptionsTradesParams defines parameters for GetOptionsTrades.
type GetOptionsTradesParams struct {
	// Timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetOptionsTradesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 1000 and max is 50000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetOptionsTradesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetOptionsTradesParamsOrder defines parameters for GetOptionsTrades.
type GetOptionsTradesParamsOrder string

// GetOptionsTradesParamsSort defines parameters for GetOptionsTrades.
type GetOptionsTradesParamsSort string

// GetStocksTradesParams defines parameters for GetStocksTrades.
type GetStocksTradesParams struct {
	// Timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty"`

	// TimestampGte Range by timestamp.
	TimestampGte *string `form:"timestamp.gte,omitempty" json:"timestamp.gte,omitempty"`

	// TimestampGt Range by timestamp.
	TimestampGt *string `form:"timestamp.gt,omitempty" json:"timestamp.gt,omitempty"`

	// TimestampLte Range by timestamp.
	TimestampLte *string `form:"timestamp.lte,omitempty" json:"timestamp.lte,omitempty"`

	// TimestampLt Range by timestamp.
	TimestampLt *string `form:"timestamp.lt,omitempty" json:"timestamp.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *GetStocksTradesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 1000 and max is 50000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *GetStocksTradesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetStocksTradesParamsOrder defines parameters for GetStocksTrades.
type GetStocksTradesParamsOrder string

// GetStocksTradesParamsSort defines parameters for GetStocksTrades.
type GetStocksTradesParamsSort string

// ListFinancialsParams defines parameters for ListFinancials.
type ListFinancialsParams struct {
	// Ticker Query by company ticker.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// Cik Query by central index key (<a rel="noopener noreferrer nofollow" target="_blank" href="https://www.sec.gov/edgar/searchedgar/cik.htm">CIK</a>) Number
	Cik *string `form:"cik,omitempty" json:"cik,omitempty"`

	// CompanyName Query by company name.
	CompanyName *string `form:"company_name,omitempty" json:"company_name,omitempty"`

	// Sic Query by standard industrial classification (<a rel="noopener noreferrer nofollow" target="_blank" href="https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list">SIC</a>)
	Sic *string `form:"sic,omitempty" json:"sic,omitempty"`

	// FilingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.
	//
	// Best used when querying over date ranges to find financials based on filings that happen in a time period.
	//
	// Examples:
	//
	// To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte=2009-01-01
	//
	// To get financials based on filings that happened in the year 2009 use the query params filing_date.gte=2009-01-01&filing_date.lt=2010-01-01
	FilingDate *openapi_types.Date `form:"filing_date,omitempty" json:"filing_date,omitempty"`

	// PeriodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format.
	PeriodOfReportDate *openapi_types.Date `form:"period_of_report_date,omitempty" json:"period_of_report_date,omitempty"`

	// Timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
	Timeframe *ListFinancialsParamsTimeframe `form:"timeframe,omitempty" json:"timeframe,omitempty"`

	// IncludeSources Whether or not to include the `xpath` and `formula` attributes for each financial data point.
	// See the `xpath` and `formula` response attributes for more info. False by default.
	IncludeSources *bool `form:"include_sources,omitempty" json:"include_sources,omitempty"`

	// CompanyNameSearch Search by company_name.
	CompanyNameSearch *string `form:"company_name.search,omitempty" json:"company_name.search,omitempty"`

	// FilingDateGte Search by filing_date.
	FilingDateGte *openapi_types.Date `form:"filing_date.gte,omitempty" json:"filing_date.gte,omitempty"`

	// FilingDateGt Search by filing_date.
	FilingDateGt *openapi_types.Date `form:"filing_date.gt,omitempty" json:"filing_date.gt,omitempty"`

	// FilingDateLte Search by filing_date.
	FilingDateLte *openapi_types.Date `form:"filing_date.lte,omitempty" json:"filing_date.lte,omitempty"`

	// FilingDateLt Search by filing_date.
	FilingDateLt *openapi_types.Date `form:"filing_date.lt,omitempty" json:"filing_date.lt,omitempty"`

	// PeriodOfReportDateGte Search by period_of_report_date.
	PeriodOfReportDateGte *openapi_types.Date `form:"period_of_report_date.gte,omitempty" json:"period_of_report_date.gte,omitempty"`

	// PeriodOfReportDateGt Search by period_of_report_date.
	PeriodOfReportDateGt *openapi_types.Date `form:"period_of_report_date.gt,omitempty" json:"period_of_report_date.gt,omitempty"`

	// PeriodOfReportDateLte Search by period_of_report_date.
	PeriodOfReportDateLte *openapi_types.Date `form:"period_of_report_date.lte,omitempty" json:"period_of_report_date.lte,omitempty"`

	// PeriodOfReportDateLt Search by period_of_report_date.
	PeriodOfReportDateLt *openapi_types.Date `form:"period_of_report_date.lt,omitempty" json:"period_of_report_date.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListFinancialsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 100.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListFinancialsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListFinancialsParamsTimeframe defines parameters for ListFinancials.
type ListFinancialsParamsTimeframe string

// ListFinancialsParamsOrder defines parameters for ListFinancials.
type ListFinancialsParamsOrder string

// ListFinancialsParamsSort defines parameters for ListFinancials.
type ListFinancialsParamsSort string

// ListIPOsParams defines parameters for ListIPOs.
type ListIPOsParams struct {
	// Ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
	Ticker *string `form:"ticker,omitempty" json:"ticker,omitempty"`

	// UsCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
	UsCode *string `form:"us_code,omitempty" json:"us_code,omitempty"`

	// Isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
	Isin *string `form:"isin,omitempty" json:"isin,omitempty"`

	// ListingDate Specify a listing date. This is the first trading date for the newly listed entity.
	ListingDate *openapi_types.Date `form:"listing_date,omitempty" json:"listing_date,omitempty"`

	// IpoStatus Specify an IPO status.
	IpoStatus *ListIPOsParamsIpoStatus `form:"ipo_status,omitempty" json:"ipo_status,omitempty"`

	// ListingDateGte Range by listing_date.
	ListingDateGte *openapi_types.Date `form:"listing_date.gte,omitempty" json:"listing_date.gte,omitempty"`

	// ListingDateGt Range by listing_date.
	ListingDateGt *openapi_types.Date `form:"listing_date.gt,omitempty" json:"listing_date.gt,omitempty"`

	// ListingDateLte Range by listing_date.
	ListingDateLte *openapi_types.Date `form:"listing_date.lte,omitempty" json:"listing_date.lte,omitempty"`

	// ListingDateLt Range by listing_date.
	ListingDateLt *openapi_types.Date `form:"listing_date.lt,omitempty" json:"listing_date.lt,omitempty"`

	// Order Order results based on the `sort` field.
	Order *ListIPOsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of results returned, default is 10 and max is 1000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Sort field used for ordering.
	Sort *ListIPOsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListIPOsParamsIpoStatus defines parameters for ListIPOs.
type ListIPOsParamsIpoStatus string

// ListIPOsParamsOrder defines parameters for ListIPOs.
type ListIPOsParamsOrder string

// ListIPOsParamsSort defines parameters for ListIPOs.
type ListIPOsParamsSort string

// GetEventsParams defines parameters for GetEvents.
type GetEventsParams struct {
	// Types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type.
	// Leave blank to return all supported event_types.
	Types *string `form:"types,omitempty" json:"types,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBenzingaV1AnalystInsights request
	GetBenzingaV1AnalystInsights(ctx context.Context, params *GetBenzingaV1AnalystInsightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1Analysts request
	GetBenzingaV1Analysts(ctx context.Context, params *GetBenzingaV1AnalystsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1BullsBearsSay request
	GetBenzingaV1BullsBearsSay(ctx context.Context, params *GetBenzingaV1BullsBearsSayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1ConsensusRatings request
	GetBenzingaV1ConsensusRatings(ctx context.Context, ticker string, params *GetBenzingaV1ConsensusRatingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1Earnings request
	GetBenzingaV1Earnings(ctx context.Context, params *GetBenzingaV1EarningsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1Firms request
	GetBenzingaV1Firms(ctx context.Context, params *GetBenzingaV1FirmsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1Guidance request
	GetBenzingaV1Guidance(ctx context.Context, params *GetBenzingaV1GuidanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV1Ratings request
	GetBenzingaV1Ratings(ctx context.Context, params *GetBenzingaV1RatingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenzingaV2News request
	GetBenzingaV2News(ctx context.Context, params *GetBenzingaV2NewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoV1Exchanges request
	GetCryptoV1Exchanges(ctx context.Context, params *GetCryptoV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEtfGlobalV1Analytics request
	GetEtfGlobalV1Analytics(ctx context.Context, params *GetEtfGlobalV1AnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEtfGlobalV1Constituents request
	GetEtfGlobalV1Constituents(ctx context.Context, params *GetEtfGlobalV1ConstituentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEtfGlobalV1FundFlows request
	GetEtfGlobalV1FundFlows(ctx context.Context, params *GetEtfGlobalV1FundFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEtfGlobalV1Profiles request
	GetEtfGlobalV1Profiles(ctx context.Context, params *GetEtfGlobalV1ProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEtfGlobalV1Taxonomies request
	GetEtfGlobalV1Taxonomies(ctx context.Context, params *GetEtfGlobalV1TaxonomiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFedV1Inflation request
	GetFedV1Inflation(ctx context.Context, params *GetFedV1InflationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFedV1InflationExpectations request
	GetFedV1InflationExpectations(ctx context.Context, params *GetFedV1InflationExpectationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFedV1LaborMarket request
	GetFedV1LaborMarket(ctx context.Context, params *GetFedV1LaborMarketParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFedV1TreasuryYields request
	GetFedV1TreasuryYields(ctx context.Context, params *GetFedV1TreasuryYieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexV1Exchanges request
	GetForexV1Exchanges(ctx context.Context, params *GetForexV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesAggregates request
	GetFuturesAggregates(ctx context.Context, ticker string, params *GetFuturesAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXContracts request
	GetFuturesVXContracts(ctx context.Context, params *GetFuturesVXContractsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXExchanges request
	GetFuturesVXExchanges(ctx context.Context, params *GetFuturesVXExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXMarketStatus request
	GetFuturesVXMarketStatus(ctx context.Context, params *GetFuturesVXMarketStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXProducts request
	GetFuturesVXProducts(ctx context.Context, params *GetFuturesVXProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXQuotesNew request
	GetFuturesVXQuotesNew(ctx context.Context, ticker string, params *GetFuturesVXQuotesNewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesQuotes request
	GetFuturesQuotes(ctx context.Context, ticker string, params *GetFuturesQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXSchedules request
	GetFuturesVXSchedules(ctx context.Context, params *GetFuturesVXSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXSnapshot request
	GetFuturesVXSnapshot(ctx context.Context, params *GetFuturesVXSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXSnapshotNative request
	GetFuturesVXSnapshotNative(ctx context.Context, params *GetFuturesVXSnapshotNativeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesVXTradesNew request
	GetFuturesVXTradesNew(ctx context.Context, ticker string, params *GetFuturesVXTradesNewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFuturesTrades request
	GetFuturesTrades(ctx context.Context, ticker string, params *GetFuturesTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsV1Exchanges request
	GetOptionsV1Exchanges(ctx context.Context, params *GetOptionsV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFilings10KVXSections request
	GetStocksFilings10KVXSections(ctx context.Context, params *GetStocksFilings10KVXSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFilingsVXIndex request
	GetStocksFilingsVXIndex(ctx context.Context, params *GetStocksFilingsVXIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFilingsVXRiskFactors request
	GetStocksFilingsVXRiskFactors(ctx context.Context, params *GetStocksFilingsVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFinancialsV1BalanceSheets request
	GetStocksFinancialsV1BalanceSheets(ctx context.Context, params *GetStocksFinancialsV1BalanceSheetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFinancialsV1CashFlowStatements request
	GetStocksFinancialsV1CashFlowStatements(ctx context.Context, params *GetStocksFinancialsV1CashFlowStatementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFinancialsV1IncomeStatements request
	GetStocksFinancialsV1IncomeStatements(ctx context.Context, params *GetStocksFinancialsV1IncomeStatementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksFinancialsV1Ratios request
	GetStocksFinancialsV1Ratios(ctx context.Context, params *GetStocksFinancialsV1RatiosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksTaxonomiesVXRiskFactors request
	GetStocksTaxonomiesVXRiskFactors(ctx context.Context, params *GetStocksTaxonomiesVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksV1Dividends request
	GetStocksV1Dividends(ctx context.Context, params *GetStocksV1DividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksV1Exchanges request
	GetStocksV1Exchanges(ctx context.Context, params *GetStocksV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksV1ShortInterest request
	GetStocksV1ShortInterest(ctx context.Context, params *GetStocksV1ShortInterestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksV1ShortVolume request
	GetStocksV1ShortVolume(ctx context.Context, params *GetStocksV1ShortVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksV1Splits request
	GetStocksV1Splits(ctx context.Context, params *GetStocksV1SplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksVXFloat request
	GetStocksVXFloat(ctx context.Context, params *GetStocksVXFloatParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTmxV1CorporateEvents request
	GetTmxV1CorporateEvents(ctx context.Context, params *GetTmxV1CorporateEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencyConversion request
	GetCurrencyConversion(ctx context.Context, from string, to string, params *GetCurrencyConversionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedGetHistoricCryptoTrades request
	DeprecatedGetHistoricCryptoTrades(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricCryptoTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedGetHistoricForexQuotes request
	DeprecatedGetHistoricForexQuotes(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricForexQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoEMA request
	GetCryptoEMA(ctx context.Context, cryptoTicker string, params *GetCryptoEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexEMA request
	GetForexEMA(ctx context.Context, fxTicker string, params *GetForexEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesEMA request
	GetIndicesEMA(ctx context.Context, indicesTicker string, params *GetIndicesEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsEMA request
	GetOptionsEMA(ctx context.Context, optionsTicker string, params *GetOptionsEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksEMA request
	GetStocksEMA(ctx context.Context, stockTicker string, params *GetStocksEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoMACD request
	GetCryptoMACD(ctx context.Context, cryptoTicker string, params *GetCryptoMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexMACD request
	GetForexMACD(ctx context.Context, fxTicker string, params *GetForexMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesMACD request
	GetIndicesMACD(ctx context.Context, indicesTicker string, params *GetIndicesMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsMACD request
	GetOptionsMACD(ctx context.Context, optionsTicker string, params *GetOptionsMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksMACD request
	GetStocksMACD(ctx context.Context, stockTicker string, params *GetStocksMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoRSI request
	GetCryptoRSI(ctx context.Context, cryptoTicker string, params *GetCryptoRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexRSI request
	GetForexRSI(ctx context.Context, fxTicker string, params *GetForexRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesRSI request
	GetIndicesRSI(ctx context.Context, indicesTicker string, params *GetIndicesRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsRSI request
	GetOptionsRSI(ctx context.Context, optionsTicker string, params *GetOptionsRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksRSI request
	GetStocksRSI(ctx context.Context, stockTicker string, params *GetStocksRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoSMA request
	GetCryptoSMA(ctx context.Context, cryptoTicker string, params *GetCryptoSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexSMA request
	GetForexSMA(ctx context.Context, fxTicker string, params *GetForexSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesSMA request
	GetIndicesSMA(ctx context.Context, indicesTicker string, params *GetIndicesSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsSMA request
	GetOptionsSMA(ctx context.Context, optionsTicker string, params *GetOptionsSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksSMA request
	GetStocksSMA(ctx context.Context, stockTicker string, params *GetStocksSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastCryptoTrade request
	GetLastCryptoTrade(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastCurrencyQuote request
	GetLastCurrencyQuote(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketStatus request
	GetMarketStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketHolidays request
	GetMarketHolidays(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoOpenClose request
	GetCryptoOpenClose(ctx context.Context, from string, to string, date openapi_types.Date, params *GetCryptoOpenCloseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesOpenClose request
	GetIndicesOpenClose(ctx context.Context, indicesTicker string, date string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsOpenClose request
	GetOptionsOpenClose(ctx context.Context, optionsTicker string, date openapi_types.Date, params *GetOptionsOpenCloseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksOpenClose request
	GetStocksOpenClose(ctx context.Context, stocksTicker string, date openapi_types.Date, params *GetStocksOpenCloseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV1ReferenceIpos request
	GetV1ReferenceIpos(ctx context.Context, params *GetV1ReferenceIposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRelatedCompanies request
	GetRelatedCompanies(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSnapshotSummary request
	GetSnapshotSummary(ctx context.Context, params *GetSnapshotSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupedCryptoAggregates request
	GetGroupedCryptoAggregates(ctx context.Context, date string, params *GetGroupedCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupedForexAggregates request
	GetGroupedForexAggregates(ctx context.Context, date string, params *GetGroupedForexAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupedStocksAggregates request
	GetGroupedStocksAggregates(ctx context.Context, date string, params *GetGroupedStocksAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreviousCryptoAggregates request
	GetPreviousCryptoAggregates(ctx context.Context, cryptoTicker string, params *GetPreviousCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoAggregates request
	GetCryptoAggregates(ctx context.Context, cryptoTicker string, multiplier int, timespan GetCryptoAggregatesParamsTimespan, from string, to string, params *GetCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreviousForexAggregates request
	GetPreviousForexAggregates(ctx context.Context, forexTicker string, params *GetPreviousForexAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexAggregates request
	GetForexAggregates(ctx context.Context, forexTicker string, multiplier int, timespan GetForexAggregatesParamsTimespan, from string, to string, params *GetForexAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreviousIndicesAggregates request
	GetPreviousIndicesAggregates(ctx context.Context, indicesTicker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesAggregates request
	GetIndicesAggregates(ctx context.Context, indicesTicker string, multiplier int, timespan GetIndicesAggregatesParamsTimespan, from string, to string, params *GetIndicesAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreviousOptionsAggregates request
	GetPreviousOptionsAggregates(ctx context.Context, optionsTicker string, params *GetPreviousOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsAggregates request
	GetOptionsAggregates(ctx context.Context, optionsTicker string, multiplier int, timespan GetOptionsAggregatesParamsTimespan, from string, to string, params *GetOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreviousStocksAggregates request
	GetPreviousStocksAggregates(ctx context.Context, stocksTicker string, params *GetPreviousStocksAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksAggregates request
	GetStocksAggregates(ctx context.Context, stocksTicker string, multiplier int, timespan GetStocksAggregatesParamsTimespan, from string, to string, params *GetStocksAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastStocksQuote request
	GetLastStocksQuote(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastOptionsTrade request
	GetLastOptionsTrade(ctx context.Context, optionsTicker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastStocksTrade request
	GetLastStocksTrade(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNews request
	ListNews(ctx context.Context, params *ListNewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoSnapshotTickers request
	GetCryptoSnapshotTickers(ctx context.Context, params *GetCryptoSnapshotTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoSnapshotTicker request
	GetCryptoSnapshotTicker(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedGetCryptoSnapshotTickerBook request
	DeprecatedGetCryptoSnapshotTickerBook(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoSnapshotDirection request
	GetCryptoSnapshotDirection(ctx context.Context, direction GetCryptoSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexSnapshotTickers request
	GetForexSnapshotTickers(ctx context.Context, params *GetForexSnapshotTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexSnapshotTicker request
	GetForexSnapshotTicker(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexSnapshotDirection request
	GetForexSnapshotDirection(ctx context.Context, direction GetForexSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksSnapshotTickers request
	GetStocksSnapshotTickers(ctx context.Context, params *GetStocksSnapshotTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksSnapshotTicker request
	GetStocksSnapshotTicker(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksSnapshotDirection request
	GetStocksSnapshotDirection(ctx context.Context, direction GetStocksSnapshotDirectionParamsDirection, params *GetStocksSnapshotDirectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedGetHistoricStocksQuotes request
	DeprecatedGetHistoricStocksQuotes(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedGetHistoricStocksTrades request
	DeprecatedGetHistoricStocksTrades(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForexQuotes request
	GetForexQuotes(ctx context.Context, fxTicker string, params *GetForexQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsQuotes request
	GetOptionsQuotes(ctx context.Context, optionsTicker string, params *GetOptionsQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksQuotes request
	GetStocksQuotes(ctx context.Context, stockTicker string, params *GetStocksQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConditions request
	ListConditions(ctx context.Context, params *ListConditionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDividends request
	ListDividends(ctx context.Context, params *ListDividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExchanges request
	ListExchanges(ctx context.Context, params *ListExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOptionsContracts request
	ListOptionsContracts(ctx context.Context, params *ListOptionsContractsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsContract request
	GetOptionsContract(ctx context.Context, optionsTicker string, params *GetOptionsContractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStockSplits request
	ListStockSplits(ctx context.Context, params *ListStockSplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTickers request
	ListTickers(ctx context.Context, params *ListTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTickerTypes request
	ListTickerTypes(ctx context.Context, params *ListTickerTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTicker request
	GetTicker(ctx context.Context, ticker string, params *GetTickerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSnapshots request
	GetSnapshots(ctx context.Context, params *GetSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndicesSnapshot request
	GetIndicesSnapshot(ctx context.Context, params *GetIndicesSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsChain request
	GetOptionsChain(ctx context.Context, underlyingAsset string, params *GetOptionsChainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionContract request
	GetOptionContract(ctx context.Context, underlyingAsset string, optionContract string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoTrades request
	GetCryptoTrades(ctx context.Context, cryptoTicker string, params *GetCryptoTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptionsTrades request
	GetOptionsTrades(ctx context.Context, optionsTicker string, params *GetOptionsTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStocksTrades request
	GetStocksTrades(ctx context.Context, stockTicker string, params *GetStocksTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFinancials request
	ListFinancials(ctx context.Context, params *ListFinancialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIPOs request
	ListIPOs(ctx context.Context, params *ListIPOsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvents request
	GetEvents(ctx context.Context, id string, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBenzingaV1AnalystInsights(ctx context.Context, params *GetBenzingaV1AnalystInsightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1AnalystInsightsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1Analysts(ctx context.Context, params *GetBenzingaV1AnalystsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1AnalystsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1BullsBearsSay(ctx context.Context, params *GetBenzingaV1BullsBearsSayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1BullsBearsSayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1ConsensusRatings(ctx context.Context, ticker string, params *GetBenzingaV1ConsensusRatingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1ConsensusRatingsRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1Earnings(ctx context.Context, params *GetBenzingaV1EarningsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1EarningsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1Firms(ctx context.Context, params *GetBenzingaV1FirmsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1FirmsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1Guidance(ctx context.Context, params *GetBenzingaV1GuidanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1GuidanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV1Ratings(ctx context.Context, params *GetBenzingaV1RatingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV1RatingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenzingaV2News(ctx context.Context, params *GetBenzingaV2NewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenzingaV2NewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoV1Exchanges(ctx context.Context, params *GetCryptoV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoV1ExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEtfGlobalV1Analytics(ctx context.Context, params *GetEtfGlobalV1AnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEtfGlobalV1AnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEtfGlobalV1Constituents(ctx context.Context, params *GetEtfGlobalV1ConstituentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEtfGlobalV1ConstituentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEtfGlobalV1FundFlows(ctx context.Context, params *GetEtfGlobalV1FundFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEtfGlobalV1FundFlowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEtfGlobalV1Profiles(ctx context.Context, params *GetEtfGlobalV1ProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEtfGlobalV1ProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEtfGlobalV1Taxonomies(ctx context.Context, params *GetEtfGlobalV1TaxonomiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEtfGlobalV1TaxonomiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFedV1Inflation(ctx context.Context, params *GetFedV1InflationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFedV1InflationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFedV1InflationExpectations(ctx context.Context, params *GetFedV1InflationExpectationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFedV1InflationExpectationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFedV1LaborMarket(ctx context.Context, params *GetFedV1LaborMarketParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFedV1LaborMarketRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFedV1TreasuryYields(ctx context.Context, params *GetFedV1TreasuryYieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFedV1TreasuryYieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexV1Exchanges(ctx context.Context, params *GetForexV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexV1ExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesAggregates(ctx context.Context, ticker string, params *GetFuturesAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesAggregatesRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXContracts(ctx context.Context, params *GetFuturesVXContractsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXContractsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXExchanges(ctx context.Context, params *GetFuturesVXExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXMarketStatus(ctx context.Context, params *GetFuturesVXMarketStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXMarketStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXProducts(ctx context.Context, params *GetFuturesVXProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXQuotesNew(ctx context.Context, ticker string, params *GetFuturesVXQuotesNewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXQuotesNewRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesQuotes(ctx context.Context, ticker string, params *GetFuturesQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesQuotesRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXSchedules(ctx context.Context, params *GetFuturesVXSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXSnapshot(ctx context.Context, params *GetFuturesVXSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXSnapshotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXSnapshotNative(ctx context.Context, params *GetFuturesVXSnapshotNativeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXSnapshotNativeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesVXTradesNew(ctx context.Context, ticker string, params *GetFuturesVXTradesNewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesVXTradesNewRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFuturesTrades(ctx context.Context, ticker string, params *GetFuturesTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFuturesTradesRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsV1Exchanges(ctx context.Context, params *GetOptionsV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsV1ExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFilings10KVXSections(ctx context.Context, params *GetStocksFilings10KVXSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFilings10KVXSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFilingsVXIndex(ctx context.Context, params *GetStocksFilingsVXIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFilingsVXIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFilingsVXRiskFactors(ctx context.Context, params *GetStocksFilingsVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFilingsVXRiskFactorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFinancialsV1BalanceSheets(ctx context.Context, params *GetStocksFinancialsV1BalanceSheetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFinancialsV1BalanceSheetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFinancialsV1CashFlowStatements(ctx context.Context, params *GetStocksFinancialsV1CashFlowStatementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFinancialsV1CashFlowStatementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFinancialsV1IncomeStatements(ctx context.Context, params *GetStocksFinancialsV1IncomeStatementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFinancialsV1IncomeStatementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksFinancialsV1Ratios(ctx context.Context, params *GetStocksFinancialsV1RatiosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksFinancialsV1RatiosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksTaxonomiesVXRiskFactors(ctx context.Context, params *GetStocksTaxonomiesVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksTaxonomiesVXRiskFactorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksV1Dividends(ctx context.Context, params *GetStocksV1DividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksV1DividendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksV1Exchanges(ctx context.Context, params *GetStocksV1ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksV1ExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksV1ShortInterest(ctx context.Context, params *GetStocksV1ShortInterestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksV1ShortInterestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksV1ShortVolume(ctx context.Context, params *GetStocksV1ShortVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksV1ShortVolumeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksV1Splits(ctx context.Context, params *GetStocksV1SplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksV1SplitsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksVXFloat(ctx context.Context, params *GetStocksVXFloatParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksVXFloatRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTmxV1CorporateEvents(ctx context.Context, params *GetTmxV1CorporateEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTmxV1CorporateEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencyConversion(ctx context.Context, from string, to string, params *GetCurrencyConversionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrencyConversionRequest(c.Server, from, to, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedGetHistoricCryptoTrades(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricCryptoTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedGetHistoricCryptoTradesRequest(c.Server, from, to, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedGetHistoricForexQuotes(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricForexQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedGetHistoricForexQuotesRequest(c.Server, from, to, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoEMA(ctx context.Context, cryptoTicker string, params *GetCryptoEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoEMARequest(c.Server, cryptoTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexEMA(ctx context.Context, fxTicker string, params *GetForexEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexEMARequest(c.Server, fxTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesEMA(ctx context.Context, indicesTicker string, params *GetIndicesEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesEMARequest(c.Server, indicesTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsEMA(ctx context.Context, optionsTicker string, params *GetOptionsEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsEMARequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksEMA(ctx context.Context, stockTicker string, params *GetStocksEMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksEMARequest(c.Server, stockTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoMACD(ctx context.Context, cryptoTicker string, params *GetCryptoMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoMACDRequest(c.Server, cryptoTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexMACD(ctx context.Context, fxTicker string, params *GetForexMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexMACDRequest(c.Server, fxTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesMACD(ctx context.Context, indicesTicker string, params *GetIndicesMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesMACDRequest(c.Server, indicesTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsMACD(ctx context.Context, optionsTicker string, params *GetOptionsMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsMACDRequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksMACD(ctx context.Context, stockTicker string, params *GetStocksMACDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksMACDRequest(c.Server, stockTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoRSI(ctx context.Context, cryptoTicker string, params *GetCryptoRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoRSIRequest(c.Server, cryptoTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexRSI(ctx context.Context, fxTicker string, params *GetForexRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexRSIRequest(c.Server, fxTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesRSI(ctx context.Context, indicesTicker string, params *GetIndicesRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesRSIRequest(c.Server, indicesTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsRSI(ctx context.Context, optionsTicker string, params *GetOptionsRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsRSIRequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksRSI(ctx context.Context, stockTicker string, params *GetStocksRSIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksRSIRequest(c.Server, stockTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoSMA(ctx context.Context, cryptoTicker string, params *GetCryptoSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoSMARequest(c.Server, cryptoTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexSMA(ctx context.Context, fxTicker string, params *GetForexSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexSMARequest(c.Server, fxTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesSMA(ctx context.Context, indicesTicker string, params *GetIndicesSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesSMARequest(c.Server, indicesTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsSMA(ctx context.Context, optionsTicker string, params *GetOptionsSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsSMARequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksSMA(ctx context.Context, stockTicker string, params *GetStocksSMAParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksSMARequest(c.Server, stockTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastCryptoTrade(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastCryptoTradeRequest(c.Server, from, to)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastCurrencyQuote(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastCurrencyQuoteRequest(c.Server, from, to)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketHolidays(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketHolidaysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoOpenClose(ctx context.Context, from string, to string, date openapi_types.Date, params *GetCryptoOpenCloseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoOpenCloseRequest(c.Server, from, to, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesOpenClose(ctx context.Context, indicesTicker string, date string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesOpenCloseRequest(c.Server, indicesTicker, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsOpenClose(ctx context.Context, optionsTicker string, date openapi_types.Date, params *GetOptionsOpenCloseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsOpenCloseRequest(c.Server, optionsTicker, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksOpenClose(ctx context.Context, stocksTicker string, date openapi_types.Date, params *GetStocksOpenCloseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksOpenCloseRequest(c.Server, stocksTicker, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV1ReferenceIpos(ctx context.Context, params *GetV1ReferenceIposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV1ReferenceIposRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRelatedCompanies(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRelatedCompaniesRequest(c.Server, ticker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSnapshotSummary(ctx context.Context, params *GetSnapshotSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSnapshotSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupedCryptoAggregates(ctx context.Context, date string, params *GetGroupedCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupedCryptoAggregatesRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupedForexAggregates(ctx context.Context, date string, params *GetGroupedForexAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupedForexAggregatesRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupedStocksAggregates(ctx context.Context, date string, params *GetGroupedStocksAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupedStocksAggregatesRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreviousCryptoAggregates(ctx context.Context, cryptoTicker string, params *GetPreviousCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreviousCryptoAggregatesRequest(c.Server, cryptoTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoAggregates(ctx context.Context, cryptoTicker string, multiplier int, timespan GetCryptoAggregatesParamsTimespan, from string, to string, params *GetCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoAggregatesRequest(c.Server, cryptoTicker, multiplier, timespan, from, to, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreviousForexAggregates(ctx context.Context, forexTicker string, params *GetPreviousForexAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreviousForexAggregatesRequest(c.Server, forexTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexAggregates(ctx context.Context, forexTicker string, multiplier int, timespan GetForexAggregatesParamsTimespan, from string, to string, params *GetForexAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexAggregatesRequest(c.Server, forexTicker, multiplier, timespan, from, to, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreviousIndicesAggregates(ctx context.Context, indicesTicker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreviousIndicesAggregatesRequest(c.Server, indicesTicker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesAggregates(ctx context.Context, indicesTicker string, multiplier int, timespan GetIndicesAggregatesParamsTimespan, from string, to string, params *GetIndicesAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesAggregatesRequest(c.Server, indicesTicker, multiplier, timespan, from, to, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreviousOptionsAggregates(ctx context.Context, optionsTicker string, params *GetPreviousOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreviousOptionsAggregatesRequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsAggregates(ctx context.Context, optionsTicker string, multiplier int, timespan GetOptionsAggregatesParamsTimespan, from string, to string, params *GetOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsAggregatesRequest(c.Server, optionsTicker, multiplier, timespan, from, to, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreviousStocksAggregates(ctx context.Context, stocksTicker string, params *GetPreviousStocksAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreviousStocksAggregatesRequest(c.Server, stocksTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksAggregates(ctx context.Context, stocksTicker string, multiplier int, timespan GetStocksAggregatesParamsTimespan, from string, to string, params *GetStocksAggregatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksAggregatesRequest(c.Server, stocksTicker, multiplier, timespan, from, to, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastStocksQuote(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastStocksQuoteRequest(c.Server, stocksTicker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastOptionsTrade(ctx context.Context, optionsTicker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastOptionsTradeRequest(c.Server, optionsTicker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastStocksTrade(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastStocksTradeRequest(c.Server, stocksTicker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNews(ctx context.Context, params *ListNewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoSnapshotTickers(ctx context.Context, params *GetCryptoSnapshotTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoSnapshotTickersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoSnapshotTicker(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoSnapshotTickerRequest(c.Server, ticker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedGetCryptoSnapshotTickerBook(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedGetCryptoSnapshotTickerBookRequest(c.Server, ticker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoSnapshotDirection(ctx context.Context, direction GetCryptoSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoSnapshotDirectionRequest(c.Server, direction)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexSnapshotTickers(ctx context.Context, params *GetForexSnapshotTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexSnapshotTickersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexSnapshotTicker(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexSnapshotTickerRequest(c.Server, ticker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexSnapshotDirection(ctx context.Context, direction GetForexSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexSnapshotDirectionRequest(c.Server, direction)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksSnapshotTickers(ctx context.Context, params *GetStocksSnapshotTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksSnapshotTickersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksSnapshotTicker(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksSnapshotTickerRequest(c.Server, stocksTicker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksSnapshotDirection(ctx context.Context, direction GetStocksSnapshotDirectionParamsDirection, params *GetStocksSnapshotDirectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksSnapshotDirectionRequest(c.Server, direction, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedGetHistoricStocksQuotes(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedGetHistoricStocksQuotesRequest(c.Server, ticker, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedGetHistoricStocksTrades(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedGetHistoricStocksTradesRequest(c.Server, ticker, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForexQuotes(ctx context.Context, fxTicker string, params *GetForexQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForexQuotesRequest(c.Server, fxTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsQuotes(ctx context.Context, optionsTicker string, params *GetOptionsQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsQuotesRequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksQuotes(ctx context.Context, stockTicker string, params *GetStocksQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksQuotesRequest(c.Server, stockTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConditions(ctx context.Context, params *ListConditionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConditionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDividends(ctx context.Context, params *ListDividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDividendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExchanges(ctx context.Context, params *ListExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOptionsContracts(ctx context.Context, params *ListOptionsContractsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOptionsContractsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsContract(ctx context.Context, optionsTicker string, params *GetOptionsContractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsContractRequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStockSplits(ctx context.Context, params *ListStockSplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStockSplitsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTickers(ctx context.Context, params *ListTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTickersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTickerTypes(ctx context.Context, params *ListTickerTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTickerTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTicker(ctx context.Context, ticker string, params *GetTickerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTickerRequest(c.Server, ticker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSnapshots(ctx context.Context, params *GetSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSnapshotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndicesSnapshot(ctx context.Context, params *GetIndicesSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndicesSnapshotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsChain(ctx context.Context, underlyingAsset string, params *GetOptionsChainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsChainRequest(c.Server, underlyingAsset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionContract(ctx context.Context, underlyingAsset string, optionContract string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionContractRequest(c.Server, underlyingAsset, optionContract)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCryptoTrades(ctx context.Context, cryptoTicker string, params *GetCryptoTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoTradesRequest(c.Server, cryptoTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptionsTrades(ctx context.Context, optionsTicker string, params *GetOptionsTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptionsTradesRequest(c.Server, optionsTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStocksTrades(ctx context.Context, stockTicker string, params *GetStocksTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStocksTradesRequest(c.Server, stockTicker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFinancials(ctx context.Context, params *ListFinancialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFinancialsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIPOs(ctx context.Context, params *ListIPOsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIPOsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvents(ctx context.Context, id string, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBenzingaV1AnalystInsightsRequest generates requests for GetBenzingaV1AnalystInsights
func NewGetBenzingaV1AnalystInsightsRequest(server string, params *GetBenzingaV1AnalystInsightsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/analyst-insights")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated", runtime.ParamLocationQuery, *params.LastUpdated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gt", runtime.ParamLocationQuery, *params.LastUpdatedGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gte", runtime.ParamLocationQuery, *params.LastUpdatedGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lt", runtime.ParamLocationQuery, *params.LastUpdatedLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lte", runtime.ParamLocationQuery, *params.LastUpdatedLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Firm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm", runtime.ParamLocationQuery, *params.Firm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm.any_of", runtime.ParamLocationQuery, *params.FirmAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm.gt", runtime.ParamLocationQuery, *params.FirmGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm.gte", runtime.ParamLocationQuery, *params.FirmGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm.lt", runtime.ParamLocationQuery, *params.FirmLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm.lte", runtime.ParamLocationQuery, *params.FirmLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingAction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action", runtime.ParamLocationQuery, *params.RatingAction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.any_of", runtime.ParamLocationQuery, *params.RatingActionAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.gt", runtime.ParamLocationQuery, *params.RatingActionGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.gte", runtime.ParamLocationQuery, *params.RatingActionGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.lt", runtime.ParamLocationQuery, *params.RatingActionLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.lte", runtime.ParamLocationQuery, *params.RatingActionLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id", runtime.ParamLocationQuery, *params.BenzingaFirmId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.any_of", runtime.ParamLocationQuery, *params.BenzingaFirmIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.gt", runtime.ParamLocationQuery, *params.BenzingaFirmIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.gte", runtime.ParamLocationQuery, *params.BenzingaFirmIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.lt", runtime.ParamLocationQuery, *params.BenzingaFirmIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.lte", runtime.ParamLocationQuery, *params.BenzingaFirmIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaRatingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_rating_id", runtime.ParamLocationQuery, *params.BenzingaRatingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaRatingIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_rating_id.any_of", runtime.ParamLocationQuery, *params.BenzingaRatingIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaRatingIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_rating_id.gt", runtime.ParamLocationQuery, *params.BenzingaRatingIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaRatingIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_rating_id.gte", runtime.ParamLocationQuery, *params.BenzingaRatingIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaRatingIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_rating_id.lt", runtime.ParamLocationQuery, *params.BenzingaRatingIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaRatingIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_rating_id.lte", runtime.ParamLocationQuery, *params.BenzingaRatingIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1AnalystsRequest generates requests for GetBenzingaV1Analysts
func NewGetBenzingaV1AnalystsRequest(server string, params *GetBenzingaV1AnalystsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/analysts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BenzingaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id", runtime.ParamLocationQuery, *params.BenzingaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.any_of", runtime.ParamLocationQuery, *params.BenzingaIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gt", runtime.ParamLocationQuery, *params.BenzingaIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gte", runtime.ParamLocationQuery, *params.BenzingaIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lt", runtime.ParamLocationQuery, *params.BenzingaIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lte", runtime.ParamLocationQuery, *params.BenzingaIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id", runtime.ParamLocationQuery, *params.BenzingaFirmId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.any_of", runtime.ParamLocationQuery, *params.BenzingaFirmIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.gt", runtime.ParamLocationQuery, *params.BenzingaFirmIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.gte", runtime.ParamLocationQuery, *params.BenzingaFirmIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.lt", runtime.ParamLocationQuery, *params.BenzingaFirmIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.lte", runtime.ParamLocationQuery, *params.BenzingaFirmIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm_name", runtime.ParamLocationQuery, *params.FirmName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmNameAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm_name.any_of", runtime.ParamLocationQuery, *params.FirmNameAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmNameGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm_name.gt", runtime.ParamLocationQuery, *params.FirmNameGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmNameGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm_name.gte", runtime.ParamLocationQuery, *params.FirmNameGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmNameLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm_name.lt", runtime.ParamLocationQuery, *params.FirmNameLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirmNameLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm_name.lte", runtime.ParamLocationQuery, *params.FirmNameLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_name", runtime.ParamLocationQuery, *params.FullName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullNameAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_name.any_of", runtime.ParamLocationQuery, *params.FullNameAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullNameGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_name.gt", runtime.ParamLocationQuery, *params.FullNameGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullNameGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_name.gte", runtime.ParamLocationQuery, *params.FullNameGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullNameLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_name.lt", runtime.ParamLocationQuery, *params.FullNameLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullNameLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_name.lte", runtime.ParamLocationQuery, *params.FullNameLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1BullsBearsSayRequest generates requests for GetBenzingaV1BullsBearsSay
func NewGetBenzingaV1BullsBearsSayRequest(server string, params *GetBenzingaV1BullsBearsSayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/bulls-bears-say")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id", runtime.ParamLocationQuery, *params.BenzingaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.any_of", runtime.ParamLocationQuery, *params.BenzingaIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gt", runtime.ParamLocationQuery, *params.BenzingaIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gte", runtime.ParamLocationQuery, *params.BenzingaIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lt", runtime.ParamLocationQuery, *params.BenzingaIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lte", runtime.ParamLocationQuery, *params.BenzingaIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated", runtime.ParamLocationQuery, *params.LastUpdated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gt", runtime.ParamLocationQuery, *params.LastUpdatedGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gte", runtime.ParamLocationQuery, *params.LastUpdatedGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lt", runtime.ParamLocationQuery, *params.LastUpdatedLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lte", runtime.ParamLocationQuery, *params.LastUpdatedLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1ConsensusRatingsRequest generates requests for GetBenzingaV1ConsensusRatings
func NewGetBenzingaV1ConsensusRatingsRequest(server string, ticker string, params *GetBenzingaV1ConsensusRatingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/consensus-ratings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1EarningsRequest generates requests for GetBenzingaV1Earnings
func NewGetBenzingaV1EarningsRequest(server string, params *GetBenzingaV1EarningsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/earnings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Importance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance", runtime.ParamLocationQuery, *params.Importance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.any_of", runtime.ParamLocationQuery, *params.ImportanceAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.gt", runtime.ParamLocationQuery, *params.ImportanceGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.gte", runtime.ParamLocationQuery, *params.ImportanceGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.lt", runtime.ParamLocationQuery, *params.ImportanceLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.lte", runtime.ParamLocationQuery, *params.ImportanceLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated", runtime.ParamLocationQuery, *params.LastUpdated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.any_of", runtime.ParamLocationQuery, *params.LastUpdatedAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gt", runtime.ParamLocationQuery, *params.LastUpdatedGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gte", runtime.ParamLocationQuery, *params.LastUpdatedGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lt", runtime.ParamLocationQuery, *params.LastUpdatedLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lte", runtime.ParamLocationQuery, *params.LastUpdatedLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_status", runtime.ParamLocationQuery, *params.DateStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateStatusAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_status.any_of", runtime.ParamLocationQuery, *params.DateStatusAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateStatusGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_status.gt", runtime.ParamLocationQuery, *params.DateStatusGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateStatusGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_status.gte", runtime.ParamLocationQuery, *params.DateStatusGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateStatusLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_status.lt", runtime.ParamLocationQuery, *params.DateStatusLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateStatusLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_status.lte", runtime.ParamLocationQuery, *params.DateStatusLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpsSurprisePercent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eps_surprise_percent", runtime.ParamLocationQuery, *params.EpsSurprisePercent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpsSurprisePercentAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eps_surprise_percent.any_of", runtime.ParamLocationQuery, *params.EpsSurprisePercentAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpsSurprisePercentGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eps_surprise_percent.gt", runtime.ParamLocationQuery, *params.EpsSurprisePercentGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpsSurprisePercentGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eps_surprise_percent.gte", runtime.ParamLocationQuery, *params.EpsSurprisePercentGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpsSurprisePercentLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eps_surprise_percent.lt", runtime.ParamLocationQuery, *params.EpsSurprisePercentLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpsSurprisePercentLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eps_surprise_percent.lte", runtime.ParamLocationQuery, *params.EpsSurprisePercentLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevenueSurprisePercent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue_surprise_percent", runtime.ParamLocationQuery, *params.RevenueSurprisePercent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevenueSurprisePercentAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue_surprise_percent.any_of", runtime.ParamLocationQuery, *params.RevenueSurprisePercentAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevenueSurprisePercentGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue_surprise_percent.gt", runtime.ParamLocationQuery, *params.RevenueSurprisePercentGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevenueSurprisePercentGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue_surprise_percent.gte", runtime.ParamLocationQuery, *params.RevenueSurprisePercentGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevenueSurprisePercentLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue_surprise_percent.lt", runtime.ParamLocationQuery, *params.RevenueSurprisePercentLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevenueSurprisePercentLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue_surprise_percent.lte", runtime.ParamLocationQuery, *params.RevenueSurprisePercentLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year", runtime.ParamLocationQuery, *params.FiscalYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.any_of", runtime.ParamLocationQuery, *params.FiscalYearAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gt", runtime.ParamLocationQuery, *params.FiscalYearGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gte", runtime.ParamLocationQuery, *params.FiscalYearGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lt", runtime.ParamLocationQuery, *params.FiscalYearLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lte", runtime.ParamLocationQuery, *params.FiscalYearLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period", runtime.ParamLocationQuery, *params.FiscalPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.any_of", runtime.ParamLocationQuery, *params.FiscalPeriodAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.gt", runtime.ParamLocationQuery, *params.FiscalPeriodGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.gte", runtime.ParamLocationQuery, *params.FiscalPeriodGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.lt", runtime.ParamLocationQuery, *params.FiscalPeriodLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.lte", runtime.ParamLocationQuery, *params.FiscalPeriodLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1FirmsRequest generates requests for GetBenzingaV1Firms
func NewGetBenzingaV1FirmsRequest(server string, params *GetBenzingaV1FirmsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/firms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BenzingaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id", runtime.ParamLocationQuery, *params.BenzingaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.any_of", runtime.ParamLocationQuery, *params.BenzingaIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gt", runtime.ParamLocationQuery, *params.BenzingaIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gte", runtime.ParamLocationQuery, *params.BenzingaIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lt", runtime.ParamLocationQuery, *params.BenzingaIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lte", runtime.ParamLocationQuery, *params.BenzingaIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1GuidanceRequest generates requests for GetBenzingaV1Guidance
func NewGetBenzingaV1GuidanceRequest(server string, params *GetBenzingaV1GuidanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/guidance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Positioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positioning", runtime.ParamLocationQuery, *params.Positioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositioningAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positioning.any_of", runtime.ParamLocationQuery, *params.PositioningAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositioningGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positioning.gt", runtime.ParamLocationQuery, *params.PositioningGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositioningGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positioning.gte", runtime.ParamLocationQuery, *params.PositioningGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositioningLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positioning.lt", runtime.ParamLocationQuery, *params.PositioningLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositioningLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positioning.lte", runtime.ParamLocationQuery, *params.PositioningLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Importance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance", runtime.ParamLocationQuery, *params.Importance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.any_of", runtime.ParamLocationQuery, *params.ImportanceAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.gt", runtime.ParamLocationQuery, *params.ImportanceGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.gte", runtime.ParamLocationQuery, *params.ImportanceGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.lt", runtime.ParamLocationQuery, *params.ImportanceLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.lte", runtime.ParamLocationQuery, *params.ImportanceLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated", runtime.ParamLocationQuery, *params.LastUpdated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.any_of", runtime.ParamLocationQuery, *params.LastUpdatedAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gt", runtime.ParamLocationQuery, *params.LastUpdatedGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gte", runtime.ParamLocationQuery, *params.LastUpdatedGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lt", runtime.ParamLocationQuery, *params.LastUpdatedLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lte", runtime.ParamLocationQuery, *params.LastUpdatedLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year", runtime.ParamLocationQuery, *params.FiscalYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.any_of", runtime.ParamLocationQuery, *params.FiscalYearAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gt", runtime.ParamLocationQuery, *params.FiscalYearGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gte", runtime.ParamLocationQuery, *params.FiscalYearGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lt", runtime.ParamLocationQuery, *params.FiscalYearLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lte", runtime.ParamLocationQuery, *params.FiscalYearLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period", runtime.ParamLocationQuery, *params.FiscalPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.any_of", runtime.ParamLocationQuery, *params.FiscalPeriodAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.gt", runtime.ParamLocationQuery, *params.FiscalPeriodGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.gte", runtime.ParamLocationQuery, *params.FiscalPeriodGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.lt", runtime.ParamLocationQuery, *params.FiscalPeriodLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalPeriodLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_period.lte", runtime.ParamLocationQuery, *params.FiscalPeriodLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV1RatingsRequest generates requests for GetBenzingaV1Ratings
func NewGetBenzingaV1RatingsRequest(server string, params *GetBenzingaV1RatingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v1/ratings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Importance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance", runtime.ParamLocationQuery, *params.Importance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.gt", runtime.ParamLocationQuery, *params.ImportanceGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.gte", runtime.ParamLocationQuery, *params.ImportanceGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.lt", runtime.ParamLocationQuery, *params.ImportanceLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportanceLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "importance.lte", runtime.ParamLocationQuery, *params.ImportanceLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated", runtime.ParamLocationQuery, *params.LastUpdated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gt", runtime.ParamLocationQuery, *params.LastUpdatedGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.gte", runtime.ParamLocationQuery, *params.LastUpdatedGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lt", runtime.ParamLocationQuery, *params.LastUpdatedLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated.lte", runtime.ParamLocationQuery, *params.LastUpdatedLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingAction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action", runtime.ParamLocationQuery, *params.RatingAction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.any_of", runtime.ParamLocationQuery, *params.RatingActionAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.gt", runtime.ParamLocationQuery, *params.RatingActionGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.gte", runtime.ParamLocationQuery, *params.RatingActionGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.lt", runtime.ParamLocationQuery, *params.RatingActionLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RatingActionLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating_action.lte", runtime.ParamLocationQuery, *params.RatingActionLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTargetAction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_target_action", runtime.ParamLocationQuery, *params.PriceTargetAction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTargetActionAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_target_action.any_of", runtime.ParamLocationQuery, *params.PriceTargetActionAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTargetActionGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_target_action.gt", runtime.ParamLocationQuery, *params.PriceTargetActionGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTargetActionGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_target_action.gte", runtime.ParamLocationQuery, *params.PriceTargetActionGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTargetActionLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_target_action.lt", runtime.ParamLocationQuery, *params.PriceTargetActionLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTargetActionLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_target_action.lte", runtime.ParamLocationQuery, *params.PriceTargetActionLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id", runtime.ParamLocationQuery, *params.BenzingaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.any_of", runtime.ParamLocationQuery, *params.BenzingaIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gt", runtime.ParamLocationQuery, *params.BenzingaIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.gte", runtime.ParamLocationQuery, *params.BenzingaIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lt", runtime.ParamLocationQuery, *params.BenzingaIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_id.lte", runtime.ParamLocationQuery, *params.BenzingaIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaAnalystId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_analyst_id", runtime.ParamLocationQuery, *params.BenzingaAnalystId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaAnalystIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_analyst_id.any_of", runtime.ParamLocationQuery, *params.BenzingaAnalystIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaAnalystIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_analyst_id.gt", runtime.ParamLocationQuery, *params.BenzingaAnalystIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaAnalystIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_analyst_id.gte", runtime.ParamLocationQuery, *params.BenzingaAnalystIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaAnalystIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_analyst_id.lt", runtime.ParamLocationQuery, *params.BenzingaAnalystIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaAnalystIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_analyst_id.lte", runtime.ParamLocationQuery, *params.BenzingaAnalystIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id", runtime.ParamLocationQuery, *params.BenzingaFirmId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.any_of", runtime.ParamLocationQuery, *params.BenzingaFirmIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.gt", runtime.ParamLocationQuery, *params.BenzingaFirmIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.gte", runtime.ParamLocationQuery, *params.BenzingaFirmIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.lt", runtime.ParamLocationQuery, *params.BenzingaFirmIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BenzingaFirmIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "benzinga_firm_id.lte", runtime.ParamLocationQuery, *params.BenzingaFirmIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBenzingaV2NewsRequest generates requests for GetBenzingaV2News
func NewGetBenzingaV2NewsRequest(server string, params *GetBenzingaV2NewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/benzinga/v2/news")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Published != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published", runtime.ParamLocationQuery, *params.Published); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published.gt", runtime.ParamLocationQuery, *params.PublishedGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published.gte", runtime.ParamLocationQuery, *params.PublishedGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published.lt", runtime.ParamLocationQuery, *params.PublishedLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published.lte", runtime.ParamLocationQuery, *params.PublishedLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channels", runtime.ParamLocationQuery, *params.Channels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelsAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channels.all_of", runtime.ParamLocationQuery, *params.ChannelsAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channels.any_of", runtime.ParamLocationQuery, *params.ChannelsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags.all_of", runtime.ParamLocationQuery, *params.TagsAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags.any_of", runtime.ParamLocationQuery, *params.TagsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Author != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author", runtime.ParamLocationQuery, *params.Author); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author.any_of", runtime.ParamLocationQuery, *params.AuthorAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author.gt", runtime.ParamLocationQuery, *params.AuthorGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author.gte", runtime.ParamLocationQuery, *params.AuthorGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author.lt", runtime.ParamLocationQuery, *params.AuthorLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author.lte", runtime.ParamLocationQuery, *params.AuthorLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stocks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stocks", runtime.ParamLocationQuery, *params.Stocks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StocksAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stocks.all_of", runtime.ParamLocationQuery, *params.StocksAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StocksAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stocks.any_of", runtime.ParamLocationQuery, *params.StocksAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.all_of", runtime.ParamLocationQuery, *params.TickersAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.any_of", runtime.ParamLocationQuery, *params.TickersAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoV1ExchangesRequest generates requests for GetCryptoV1Exchanges
func NewGetCryptoV1ExchangesRequest(server string, params *GetCryptoV1ExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/crypto/v1/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEtfGlobalV1AnalyticsRequest generates requests for GetEtfGlobalV1Analytics
func NewGetEtfGlobalV1AnalyticsRequest(server string, params *GetEtfGlobalV1AnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/etf-global/v1/analytics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompositeTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker", runtime.ParamLocationQuery, *params.CompositeTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.any_of", runtime.ParamLocationQuery, *params.CompositeTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gt", runtime.ParamLocationQuery, *params.CompositeTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gte", runtime.ParamLocationQuery, *params.CompositeTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lt", runtime.ParamLocationQuery, *params.CompositeTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lte", runtime.ParamLocationQuery, *params.CompositeTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date", runtime.ParamLocationQuery, *params.ProcessedDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gt", runtime.ParamLocationQuery, *params.ProcessedDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gte", runtime.ParamLocationQuery, *params.ProcessedDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lt", runtime.ParamLocationQuery, *params.ProcessedDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lte", runtime.ParamLocationQuery, *params.ProcessedDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date", runtime.ParamLocationQuery, *params.EffectiveDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gt", runtime.ParamLocationQuery, *params.EffectiveDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gte", runtime.ParamLocationQuery, *params.EffectiveDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lt", runtime.ParamLocationQuery, *params.EffectiveDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lte", runtime.ParamLocationQuery, *params.EffectiveDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RiskTotalScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_total_score", runtime.ParamLocationQuery, *params.RiskTotalScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RiskTotalScoreGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_total_score.gt", runtime.ParamLocationQuery, *params.RiskTotalScoreGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RiskTotalScoreGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_total_score.gte", runtime.ParamLocationQuery, *params.RiskTotalScoreGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RiskTotalScoreLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_total_score.lt", runtime.ParamLocationQuery, *params.RiskTotalScoreLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RiskTotalScoreLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_total_score.lte", runtime.ParamLocationQuery, *params.RiskTotalScoreLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RewardScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_score", runtime.ParamLocationQuery, *params.RewardScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RewardScoreGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_score.gt", runtime.ParamLocationQuery, *params.RewardScoreGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RewardScoreGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_score.gte", runtime.ParamLocationQuery, *params.RewardScoreGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RewardScoreLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_score.lt", runtime.ParamLocationQuery, *params.RewardScoreLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RewardScoreLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_score.lte", runtime.ParamLocationQuery, *params.RewardScoreLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantTotalScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_total_score", runtime.ParamLocationQuery, *params.QuantTotalScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantTotalScoreGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_total_score.gt", runtime.ParamLocationQuery, *params.QuantTotalScoreGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantTotalScoreGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_total_score.gte", runtime.ParamLocationQuery, *params.QuantTotalScoreGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantTotalScoreLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_total_score.lt", runtime.ParamLocationQuery, *params.QuantTotalScoreLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantTotalScoreLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_total_score.lte", runtime.ParamLocationQuery, *params.QuantTotalScoreLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantGrade != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_grade", runtime.ParamLocationQuery, *params.QuantGrade); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantGradeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_grade.any_of", runtime.ParamLocationQuery, *params.QuantGradeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantGradeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_grade.gt", runtime.ParamLocationQuery, *params.QuantGradeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantGradeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_grade.gte", runtime.ParamLocationQuery, *params.QuantGradeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantGradeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_grade.lt", runtime.ParamLocationQuery, *params.QuantGradeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantGradeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_grade.lte", runtime.ParamLocationQuery, *params.QuantGradeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeTechnical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_technical", runtime.ParamLocationQuery, *params.QuantCompositeTechnical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeTechnicalGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_technical.gt", runtime.ParamLocationQuery, *params.QuantCompositeTechnicalGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeTechnicalGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_technical.gte", runtime.ParamLocationQuery, *params.QuantCompositeTechnicalGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeTechnicalLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_technical.lt", runtime.ParamLocationQuery, *params.QuantCompositeTechnicalLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeTechnicalLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_technical.lte", runtime.ParamLocationQuery, *params.QuantCompositeTechnicalLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeSentiment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_sentiment", runtime.ParamLocationQuery, *params.QuantCompositeSentiment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeSentimentGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_sentiment.gt", runtime.ParamLocationQuery, *params.QuantCompositeSentimentGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeSentimentGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_sentiment.gte", runtime.ParamLocationQuery, *params.QuantCompositeSentimentGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeSentimentLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_sentiment.lt", runtime.ParamLocationQuery, *params.QuantCompositeSentimentLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeSentimentLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_sentiment.lte", runtime.ParamLocationQuery, *params.QuantCompositeSentimentLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeBehavioral != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_behavioral", runtime.ParamLocationQuery, *params.QuantCompositeBehavioral); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeBehavioralGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_behavioral.gt", runtime.ParamLocationQuery, *params.QuantCompositeBehavioralGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeBehavioralGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_behavioral.gte", runtime.ParamLocationQuery, *params.QuantCompositeBehavioralGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeBehavioralLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_behavioral.lt", runtime.ParamLocationQuery, *params.QuantCompositeBehavioralLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeBehavioralLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_behavioral.lte", runtime.ParamLocationQuery, *params.QuantCompositeBehavioralLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeFundamental != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_fundamental", runtime.ParamLocationQuery, *params.QuantCompositeFundamental); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeFundamentalGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_fundamental.gt", runtime.ParamLocationQuery, *params.QuantCompositeFundamentalGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeFundamentalGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_fundamental.gte", runtime.ParamLocationQuery, *params.QuantCompositeFundamentalGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeFundamentalLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_fundamental.lt", runtime.ParamLocationQuery, *params.QuantCompositeFundamentalLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeFundamentalLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_fundamental.lte", runtime.ParamLocationQuery, *params.QuantCompositeFundamentalLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_global", runtime.ParamLocationQuery, *params.QuantCompositeGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeGlobalGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_global.gt", runtime.ParamLocationQuery, *params.QuantCompositeGlobalGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeGlobalGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_global.gte", runtime.ParamLocationQuery, *params.QuantCompositeGlobalGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeGlobalLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_global.lt", runtime.ParamLocationQuery, *params.QuantCompositeGlobalLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeGlobalLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_global.lte", runtime.ParamLocationQuery, *params.QuantCompositeGlobalLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeQuality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_quality", runtime.ParamLocationQuery, *params.QuantCompositeQuality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeQualityGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_quality.gt", runtime.ParamLocationQuery, *params.QuantCompositeQualityGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeQualityGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_quality.gte", runtime.ParamLocationQuery, *params.QuantCompositeQualityGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeQualityLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_quality.lt", runtime.ParamLocationQuery, *params.QuantCompositeQualityLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuantCompositeQualityLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quant_composite_quality.lte", runtime.ParamLocationQuery, *params.QuantCompositeQualityLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEtfGlobalV1ConstituentsRequest generates requests for GetEtfGlobalV1Constituents
func NewGetEtfGlobalV1ConstituentsRequest(server string, params *GetEtfGlobalV1ConstituentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/etf-global/v1/constituents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompositeTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker", runtime.ParamLocationQuery, *params.CompositeTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.any_of", runtime.ParamLocationQuery, *params.CompositeTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gt", runtime.ParamLocationQuery, *params.CompositeTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gte", runtime.ParamLocationQuery, *params.CompositeTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lt", runtime.ParamLocationQuery, *params.CompositeTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lte", runtime.ParamLocationQuery, *params.CompositeTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConstituentTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "constituent_ticker", runtime.ParamLocationQuery, *params.ConstituentTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConstituentTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "constituent_ticker.any_of", runtime.ParamLocationQuery, *params.ConstituentTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConstituentTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "constituent_ticker.gt", runtime.ParamLocationQuery, *params.ConstituentTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConstituentTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "constituent_ticker.gte", runtime.ParamLocationQuery, *params.ConstituentTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConstituentTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "constituent_ticker.lt", runtime.ParamLocationQuery, *params.ConstituentTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConstituentTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "constituent_ticker.lte", runtime.ParamLocationQuery, *params.ConstituentTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date", runtime.ParamLocationQuery, *params.EffectiveDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gt", runtime.ParamLocationQuery, *params.EffectiveDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gte", runtime.ParamLocationQuery, *params.EffectiveDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lt", runtime.ParamLocationQuery, *params.EffectiveDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lte", runtime.ParamLocationQuery, *params.EffectiveDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date", runtime.ParamLocationQuery, *params.ProcessedDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gt", runtime.ParamLocationQuery, *params.ProcessedDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gte", runtime.ParamLocationQuery, *params.ProcessedDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lt", runtime.ParamLocationQuery, *params.ProcessedDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lte", runtime.ParamLocationQuery, *params.ProcessedDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code", runtime.ParamLocationQuery, *params.UsCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.any_of", runtime.ParamLocationQuery, *params.UsCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.gt", runtime.ParamLocationQuery, *params.UsCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.gte", runtime.ParamLocationQuery, *params.UsCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.lt", runtime.ParamLocationQuery, *params.UsCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.lte", runtime.ParamLocationQuery, *params.UsCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Isin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin", runtime.ParamLocationQuery, *params.Isin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.any_of", runtime.ParamLocationQuery, *params.IsinAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.gt", runtime.ParamLocationQuery, *params.IsinGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.gte", runtime.ParamLocationQuery, *params.IsinGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.lt", runtime.ParamLocationQuery, *params.IsinLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.lte", runtime.ParamLocationQuery, *params.IsinLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Figi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "figi", runtime.ParamLocationQuery, *params.Figi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FigiAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "figi.any_of", runtime.ParamLocationQuery, *params.FigiAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FigiGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "figi.gt", runtime.ParamLocationQuery, *params.FigiGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FigiGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "figi.gte", runtime.ParamLocationQuery, *params.FigiGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FigiLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "figi.lt", runtime.ParamLocationQuery, *params.FigiLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FigiLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "figi.lte", runtime.ParamLocationQuery, *params.FigiLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sedol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sedol", runtime.ParamLocationQuery, *params.Sedol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SedolAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sedol.any_of", runtime.ParamLocationQuery, *params.SedolAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SedolGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sedol.gt", runtime.ParamLocationQuery, *params.SedolGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SedolGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sedol.gte", runtime.ParamLocationQuery, *params.SedolGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SedolLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sedol.lt", runtime.ParamLocationQuery, *params.SedolLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SedolLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sedol.lte", runtime.ParamLocationQuery, *params.SedolLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEtfGlobalV1FundFlowsRequest generates requests for GetEtfGlobalV1FundFlows
func NewGetEtfGlobalV1FundFlowsRequest(server string, params *GetEtfGlobalV1FundFlowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/etf-global/v1/fund-flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProcessedDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date", runtime.ParamLocationQuery, *params.ProcessedDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gt", runtime.ParamLocationQuery, *params.ProcessedDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gte", runtime.ParamLocationQuery, *params.ProcessedDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lt", runtime.ParamLocationQuery, *params.ProcessedDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lte", runtime.ParamLocationQuery, *params.ProcessedDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date", runtime.ParamLocationQuery, *params.EffectiveDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gt", runtime.ParamLocationQuery, *params.EffectiveDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gte", runtime.ParamLocationQuery, *params.EffectiveDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lt", runtime.ParamLocationQuery, *params.EffectiveDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lte", runtime.ParamLocationQuery, *params.EffectiveDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker", runtime.ParamLocationQuery, *params.CompositeTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.any_of", runtime.ParamLocationQuery, *params.CompositeTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gt", runtime.ParamLocationQuery, *params.CompositeTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gte", runtime.ParamLocationQuery, *params.CompositeTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lt", runtime.ParamLocationQuery, *params.CompositeTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lte", runtime.ParamLocationQuery, *params.CompositeTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEtfGlobalV1ProfilesRequest generates requests for GetEtfGlobalV1Profiles
func NewGetEtfGlobalV1ProfilesRequest(server string, params *GetEtfGlobalV1ProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/etf-global/v1/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProcessedDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date", runtime.ParamLocationQuery, *params.ProcessedDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gt", runtime.ParamLocationQuery, *params.ProcessedDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gte", runtime.ParamLocationQuery, *params.ProcessedDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lt", runtime.ParamLocationQuery, *params.ProcessedDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lte", runtime.ParamLocationQuery, *params.ProcessedDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date", runtime.ParamLocationQuery, *params.EffectiveDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gt", runtime.ParamLocationQuery, *params.EffectiveDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gte", runtime.ParamLocationQuery, *params.EffectiveDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lt", runtime.ParamLocationQuery, *params.EffectiveDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lte", runtime.ParamLocationQuery, *params.EffectiveDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker", runtime.ParamLocationQuery, *params.CompositeTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.any_of", runtime.ParamLocationQuery, *params.CompositeTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gt", runtime.ParamLocationQuery, *params.CompositeTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gte", runtime.ParamLocationQuery, *params.CompositeTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lt", runtime.ParamLocationQuery, *params.CompositeTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lte", runtime.ParamLocationQuery, *params.CompositeTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEtfGlobalV1TaxonomiesRequest generates requests for GetEtfGlobalV1Taxonomies
func NewGetEtfGlobalV1TaxonomiesRequest(server string, params *GetEtfGlobalV1TaxonomiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/etf-global/v1/taxonomies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProcessedDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date", runtime.ParamLocationQuery, *params.ProcessedDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gt", runtime.ParamLocationQuery, *params.ProcessedDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.gte", runtime.ParamLocationQuery, *params.ProcessedDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lt", runtime.ParamLocationQuery, *params.ProcessedDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processed_date.lte", runtime.ParamLocationQuery, *params.ProcessedDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date", runtime.ParamLocationQuery, *params.EffectiveDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gt", runtime.ParamLocationQuery, *params.EffectiveDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.gte", runtime.ParamLocationQuery, *params.EffectiveDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lt", runtime.ParamLocationQuery, *params.EffectiveDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_date.lte", runtime.ParamLocationQuery, *params.EffectiveDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker", runtime.ParamLocationQuery, *params.CompositeTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.any_of", runtime.ParamLocationQuery, *params.CompositeTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gt", runtime.ParamLocationQuery, *params.CompositeTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.gte", runtime.ParamLocationQuery, *params.CompositeTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lt", runtime.ParamLocationQuery, *params.CompositeTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompositeTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "composite_ticker.lte", runtime.ParamLocationQuery, *params.CompositeTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFedV1InflationRequest generates requests for GetFedV1Inflation
func NewGetFedV1InflationRequest(server string, params *GetFedV1InflationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fed/v1/inflation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFedV1InflationExpectationsRequest generates requests for GetFedV1InflationExpectations
func NewGetFedV1InflationExpectationsRequest(server string, params *GetFedV1InflationExpectationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fed/v1/inflation-expectations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFedV1LaborMarketRequest generates requests for GetFedV1LaborMarket
func NewGetFedV1LaborMarketRequest(server string, params *GetFedV1LaborMarketParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fed/v1/labor-market")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFedV1TreasuryYieldsRequest generates requests for GetFedV1TreasuryYields
func NewGetFedV1TreasuryYieldsRequest(server string, params *GetFedV1TreasuryYieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fed/v1/treasury-yields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexV1ExchangesRequest generates requests for GetForexV1Exchanges
func NewGetForexV1ExchangesRequest(server string, params *GetForexV1ExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forex/v1/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesAggregatesRequest generates requests for GetFuturesAggregates
func NewGetFuturesAggregatesRequest(server string, ticker string, params *GetFuturesAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/aggs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window_start", runtime.ParamLocationQuery, *params.WindowStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowStartGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window_start.gte", runtime.ParamLocationQuery, *params.WindowStartGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowStartGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window_start.gt", runtime.ParamLocationQuery, *params.WindowStartGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowStartLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window_start.lte", runtime.ParamLocationQuery, *params.WindowStartLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowStartLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window_start.lt", runtime.ParamLocationQuery, *params.WindowStartLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXContractsRequest generates requests for GetFuturesVXContracts
func NewGetFuturesVXContractsRequest(server string, params *GetFuturesVXContractsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/contracts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code", runtime.ParamLocationQuery, *params.ProductCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.any_of", runtime.ParamLocationQuery, *params.ProductCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gt", runtime.ParamLocationQuery, *params.ProductCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gte", runtime.ParamLocationQuery, *params.ProductCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lt", runtime.ParamLocationQuery, *params.ProductCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lte", runtime.ParamLocationQuery, *params.ProductCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.any_of", runtime.ParamLocationQuery, *params.TypeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstTradeDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_trade_date", runtime.ParamLocationQuery, *params.FirstTradeDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstTradeDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_trade_date.gt", runtime.ParamLocationQuery, *params.FirstTradeDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstTradeDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_trade_date.gte", runtime.ParamLocationQuery, *params.FirstTradeDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstTradeDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_trade_date.lt", runtime.ParamLocationQuery, *params.FirstTradeDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstTradeDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_trade_date.lte", runtime.ParamLocationQuery, *params.FirstTradeDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastTradeDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_trade_date", runtime.ParamLocationQuery, *params.LastTradeDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastTradeDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_trade_date.gt", runtime.ParamLocationQuery, *params.LastTradeDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastTradeDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_trade_date.gte", runtime.ParamLocationQuery, *params.LastTradeDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastTradeDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_trade_date.lt", runtime.ParamLocationQuery, *params.LastTradeDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastTradeDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_trade_date.lte", runtime.ParamLocationQuery, *params.LastTradeDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXExchangesRequest generates requests for GetFuturesVXExchanges
func NewGetFuturesVXExchangesRequest(server string, params *GetFuturesVXExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXMarketStatusRequest generates requests for GetFuturesVXMarketStatus
func NewGetFuturesVXMarketStatusRequest(server string, params *GetFuturesVXMarketStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/market-status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code", runtime.ParamLocationQuery, *params.ProductCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.any_of", runtime.ParamLocationQuery, *params.ProductCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gt", runtime.ParamLocationQuery, *params.ProductCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gte", runtime.ParamLocationQuery, *params.ProductCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lt", runtime.ParamLocationQuery, *params.ProductCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lte", runtime.ParamLocationQuery, *params.ProductCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXProductsRequest generates requests for GetFuturesVXProducts
func NewGetFuturesVXProductsRequest(server string, params *GetFuturesVXProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name.any_of", runtime.ParamLocationQuery, *params.NameAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name.gt", runtime.ParamLocationQuery, *params.NameGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name.gte", runtime.ParamLocationQuery, *params.NameGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name.lt", runtime.ParamLocationQuery, *params.NameLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name.lte", runtime.ParamLocationQuery, *params.NameLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code", runtime.ParamLocationQuery, *params.ProductCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.any_of", runtime.ParamLocationQuery, *params.ProductCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gt", runtime.ParamLocationQuery, *params.ProductCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gte", runtime.ParamLocationQuery, *params.ProductCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lt", runtime.ParamLocationQuery, *params.ProductCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lte", runtime.ParamLocationQuery, *params.ProductCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue", runtime.ParamLocationQuery, *params.TradingVenue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.any_of", runtime.ParamLocationQuery, *params.TradingVenueAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.gt", runtime.ParamLocationQuery, *params.TradingVenueGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.gte", runtime.ParamLocationQuery, *params.TradingVenueGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.lt", runtime.ParamLocationQuery, *params.TradingVenueLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.lte", runtime.ParamLocationQuery, *params.TradingVenueLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sector != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sector", runtime.ParamLocationQuery, *params.Sector); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SectorAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sector.any_of", runtime.ParamLocationQuery, *params.SectorAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubSector != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_sector", runtime.ParamLocationQuery, *params.SubSector); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubSectorAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_sector.any_of", runtime.ParamLocationQuery, *params.SubSectorAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_class", runtime.ParamLocationQuery, *params.AssetClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetClassAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_class.any_of", runtime.ParamLocationQuery, *params.AssetClassAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetSubClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_sub_class", runtime.ParamLocationQuery, *params.AssetSubClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetSubClassAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_sub_class.any_of", runtime.ParamLocationQuery, *params.AssetSubClassAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.any_of", runtime.ParamLocationQuery, *params.TypeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXQuotesNewRequest generates requests for GetFuturesVXQuotesNew
func NewGetFuturesVXQuotesNewRequest(server string, ticker string, params *GetFuturesVXQuotesNewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/quotes-new/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date", runtime.ParamLocationQuery, *params.SessionEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesQuotesRequest generates requests for GetFuturesQuotes
func NewGetFuturesQuotesRequest(server string, ticker string, params *GetFuturesQuotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/quotes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date", runtime.ParamLocationQuery, *params.SessionEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.gte", runtime.ParamLocationQuery, *params.SessionEndDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.gt", runtime.ParamLocationQuery, *params.SessionEndDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.lte", runtime.ParamLocationQuery, *params.SessionEndDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.lt", runtime.ParamLocationQuery, *params.SessionEndDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXSchedulesRequest generates requests for GetFuturesVXSchedules
func NewGetFuturesVXSchedulesRequest(server string, params *GetFuturesVXSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code", runtime.ParamLocationQuery, *params.ProductCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.any_of", runtime.ParamLocationQuery, *params.ProductCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gt", runtime.ParamLocationQuery, *params.ProductCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gte", runtime.ParamLocationQuery, *params.ProductCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lt", runtime.ParamLocationQuery, *params.ProductCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lte", runtime.ParamLocationQuery, *params.ProductCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date", runtime.ParamLocationQuery, *params.SessionEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.any_of", runtime.ParamLocationQuery, *params.SessionEndDateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.gt", runtime.ParamLocationQuery, *params.SessionEndDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.gte", runtime.ParamLocationQuery, *params.SessionEndDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.lt", runtime.ParamLocationQuery, *params.SessionEndDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.lte", runtime.ParamLocationQuery, *params.SessionEndDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue", runtime.ParamLocationQuery, *params.TradingVenue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.any_of", runtime.ParamLocationQuery, *params.TradingVenueAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.gt", runtime.ParamLocationQuery, *params.TradingVenueGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.gte", runtime.ParamLocationQuery, *params.TradingVenueGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.lt", runtime.ParamLocationQuery, *params.TradingVenueLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.lte", runtime.ParamLocationQuery, *params.TradingVenueLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXSnapshotRequest generates requests for GetFuturesVXSnapshot
func NewGetFuturesVXSnapshotRequest(server string, params *GetFuturesVXSnapshotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/snapshot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code", runtime.ParamLocationQuery, *params.ProductCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.any_of", runtime.ParamLocationQuery, *params.ProductCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gt", runtime.ParamLocationQuery, *params.ProductCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gte", runtime.ParamLocationQuery, *params.ProductCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lt", runtime.ParamLocationQuery, *params.ProductCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lte", runtime.ParamLocationQuery, *params.ProductCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXSnapshotNativeRequest generates requests for GetFuturesVXSnapshotNative
func NewGetFuturesVXSnapshotNativeRequest(server string, params *GetFuturesVXSnapshotNativeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/snapshot-native")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code", runtime.ParamLocationQuery, *params.ProductCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.any_of", runtime.ParamLocationQuery, *params.ProductCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gt", runtime.ParamLocationQuery, *params.ProductCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.gte", runtime.ParamLocationQuery, *params.ProductCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lt", runtime.ParamLocationQuery, *params.ProductCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_code.lte", runtime.ParamLocationQuery, *params.ProductCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesVXTradesNewRequest generates requests for GetFuturesVXTradesNew
func NewGetFuturesVXTradesNewRequest(server string, ticker string, params *GetFuturesVXTradesNewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/trades-new/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date", runtime.ParamLocationQuery, *params.SessionEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFuturesTradesRequest generates requests for GetFuturesTrades
func NewGetFuturesTradesRequest(server string, ticker string, params *GetFuturesTradesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/futures/vX/trades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date", runtime.ParamLocationQuery, *params.SessionEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.gte", runtime.ParamLocationQuery, *params.SessionEndDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.gt", runtime.ParamLocationQuery, *params.SessionEndDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.lte", runtime.ParamLocationQuery, *params.SessionEndDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionEndDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_end_date.lt", runtime.ParamLocationQuery, *params.SessionEndDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsV1ExchangesRequest generates requests for GetOptionsV1Exchanges
func NewGetOptionsV1ExchangesRequest(server string, params *GetOptionsV1ExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/options/v1/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFilings10KVXSectionsRequest generates requests for GetStocksFilings10KVXSections
func NewGetStocksFilings10KVXSectionsRequest(server string, params *GetStocksFilings10KVXSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/filings/10-K/vX/sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Section != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "section", runtime.ParamLocationQuery, *params.Section); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SectionAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "section.any_of", runtime.ParamLocationQuery, *params.SectionAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end", runtime.ParamLocationQuery, *params.PeriodEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gt", runtime.ParamLocationQuery, *params.PeriodEndGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gte", runtime.ParamLocationQuery, *params.PeriodEndGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lt", runtime.ParamLocationQuery, *params.PeriodEndLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lte", runtime.ParamLocationQuery, *params.PeriodEndLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFilingsVXIndexRequest generates requests for GetStocksFilingsVXIndex
func NewGetStocksFilingsVXIndexRequest(server string, params *GetStocksFilingsVXIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/filings/vX/index")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "form_type", runtime.ParamLocationQuery, *params.FormType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormTypeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "form_type.any_of", runtime.ParamLocationQuery, *params.FormTypeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormTypeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "form_type.gt", runtime.ParamLocationQuery, *params.FormTypeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormTypeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "form_type.gte", runtime.ParamLocationQuery, *params.FormTypeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormTypeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "form_type.lt", runtime.ParamLocationQuery, *params.FormTypeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormTypeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "form_type.lte", runtime.ParamLocationQuery, *params.FormTypeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFilingsVXRiskFactorsRequest generates requests for GetStocksFilingsVXRiskFactors
func NewGetStocksFilingsVXRiskFactorsRequest(server string, params *GetStocksFilingsVXRiskFactorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/filings/vX/risk-factors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.any_of", runtime.ParamLocationQuery, *params.FilingDateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFinancialsV1BalanceSheetsRequest generates requests for GetStocksFinancialsV1BalanceSheets
func NewGetStocksFinancialsV1BalanceSheetsRequest(server string, params *GetStocksFinancialsV1BalanceSheetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/financials/v1/balance-sheets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.all_of", runtime.ParamLocationQuery, *params.TickersAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.any_of", runtime.ParamLocationQuery, *params.TickersAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end", runtime.ParamLocationQuery, *params.PeriodEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gt", runtime.ParamLocationQuery, *params.PeriodEndGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gte", runtime.ParamLocationQuery, *params.PeriodEndGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lt", runtime.ParamLocationQuery, *params.PeriodEndLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lte", runtime.ParamLocationQuery, *params.PeriodEndLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year", runtime.ParamLocationQuery, *params.FiscalYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gt", runtime.ParamLocationQuery, *params.FiscalYearGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gte", runtime.ParamLocationQuery, *params.FiscalYearGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lt", runtime.ParamLocationQuery, *params.FiscalYearLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lte", runtime.ParamLocationQuery, *params.FiscalYearLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter", runtime.ParamLocationQuery, *params.FiscalQuarter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.gt", runtime.ParamLocationQuery, *params.FiscalQuarterGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.gte", runtime.ParamLocationQuery, *params.FiscalQuarterGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.lt", runtime.ParamLocationQuery, *params.FiscalQuarterLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.lte", runtime.ParamLocationQuery, *params.FiscalQuarterLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeframe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe", runtime.ParamLocationQuery, *params.Timeframe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.any_of", runtime.ParamLocationQuery, *params.TimeframeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.gt", runtime.ParamLocationQuery, *params.TimeframeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.gte", runtime.ParamLocationQuery, *params.TimeframeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.lt", runtime.ParamLocationQuery, *params.TimeframeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.lte", runtime.ParamLocationQuery, *params.TimeframeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker", runtime.ParamLocationQuery, *params.MaxTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.any_of", runtime.ParamLocationQuery, *params.MaxTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.gt", runtime.ParamLocationQuery, *params.MaxTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.gte", runtime.ParamLocationQuery, *params.MaxTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.lt", runtime.ParamLocationQuery, *params.MaxTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.lte", runtime.ParamLocationQuery, *params.MaxTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker", runtime.ParamLocationQuery, *params.MinTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.any_of", runtime.ParamLocationQuery, *params.MinTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.gt", runtime.ParamLocationQuery, *params.MinTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.gte", runtime.ParamLocationQuery, *params.MinTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.lt", runtime.ParamLocationQuery, *params.MinTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.lte", runtime.ParamLocationQuery, *params.MinTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFinancialsV1CashFlowStatementsRequest generates requests for GetStocksFinancialsV1CashFlowStatements
func NewGetStocksFinancialsV1CashFlowStatementsRequest(server string, params *GetStocksFinancialsV1CashFlowStatementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/financials/v1/cash-flow-statements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end", runtime.ParamLocationQuery, *params.PeriodEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gt", runtime.ParamLocationQuery, *params.PeriodEndGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gte", runtime.ParamLocationQuery, *params.PeriodEndGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lt", runtime.ParamLocationQuery, *params.PeriodEndLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lte", runtime.ParamLocationQuery, *params.PeriodEndLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.all_of", runtime.ParamLocationQuery, *params.TickersAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.any_of", runtime.ParamLocationQuery, *params.TickersAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year", runtime.ParamLocationQuery, *params.FiscalYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gt", runtime.ParamLocationQuery, *params.FiscalYearGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gte", runtime.ParamLocationQuery, *params.FiscalYearGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lt", runtime.ParamLocationQuery, *params.FiscalYearLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lte", runtime.ParamLocationQuery, *params.FiscalYearLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter", runtime.ParamLocationQuery, *params.FiscalQuarter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.gt", runtime.ParamLocationQuery, *params.FiscalQuarterGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.gte", runtime.ParamLocationQuery, *params.FiscalQuarterGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.lt", runtime.ParamLocationQuery, *params.FiscalQuarterLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.lte", runtime.ParamLocationQuery, *params.FiscalQuarterLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeframe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe", runtime.ParamLocationQuery, *params.Timeframe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.any_of", runtime.ParamLocationQuery, *params.TimeframeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.gt", runtime.ParamLocationQuery, *params.TimeframeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.gte", runtime.ParamLocationQuery, *params.TimeframeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.lt", runtime.ParamLocationQuery, *params.TimeframeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.lte", runtime.ParamLocationQuery, *params.TimeframeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker", runtime.ParamLocationQuery, *params.MaxTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.any_of", runtime.ParamLocationQuery, *params.MaxTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.gt", runtime.ParamLocationQuery, *params.MaxTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.gte", runtime.ParamLocationQuery, *params.MaxTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.lt", runtime.ParamLocationQuery, *params.MaxTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.lte", runtime.ParamLocationQuery, *params.MaxTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker", runtime.ParamLocationQuery, *params.MinTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.any_of", runtime.ParamLocationQuery, *params.MinTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.gt", runtime.ParamLocationQuery, *params.MinTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.gte", runtime.ParamLocationQuery, *params.MinTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.lt", runtime.ParamLocationQuery, *params.MinTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.lte", runtime.ParamLocationQuery, *params.MinTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFinancialsV1IncomeStatementsRequest generates requests for GetStocksFinancialsV1IncomeStatements
func NewGetStocksFinancialsV1IncomeStatementsRequest(server string, params *GetStocksFinancialsV1IncomeStatementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/financials/v1/income-statements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.all_of", runtime.ParamLocationQuery, *params.TickersAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickersAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers.any_of", runtime.ParamLocationQuery, *params.TickersAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end", runtime.ParamLocationQuery, *params.PeriodEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gt", runtime.ParamLocationQuery, *params.PeriodEndGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.gte", runtime.ParamLocationQuery, *params.PeriodEndGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lt", runtime.ParamLocationQuery, *params.PeriodEndLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEndLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_end.lte", runtime.ParamLocationQuery, *params.PeriodEndLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year", runtime.ParamLocationQuery, *params.FiscalYear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gt", runtime.ParamLocationQuery, *params.FiscalYearGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.gte", runtime.ParamLocationQuery, *params.FiscalYearGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lt", runtime.ParamLocationQuery, *params.FiscalYearLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalYearLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_year.lte", runtime.ParamLocationQuery, *params.FiscalYearLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter", runtime.ParamLocationQuery, *params.FiscalQuarter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.gt", runtime.ParamLocationQuery, *params.FiscalQuarterGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.gte", runtime.ParamLocationQuery, *params.FiscalQuarterGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.lt", runtime.ParamLocationQuery, *params.FiscalQuarterLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FiscalQuarterLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_quarter.lte", runtime.ParamLocationQuery, *params.FiscalQuarterLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeframe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe", runtime.ParamLocationQuery, *params.Timeframe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.any_of", runtime.ParamLocationQuery, *params.TimeframeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.gt", runtime.ParamLocationQuery, *params.TimeframeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.gte", runtime.ParamLocationQuery, *params.TimeframeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.lt", runtime.ParamLocationQuery, *params.TimeframeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeframeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe.lte", runtime.ParamLocationQuery, *params.TimeframeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker", runtime.ParamLocationQuery, *params.MaxTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.any_of", runtime.ParamLocationQuery, *params.MaxTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.gt", runtime.ParamLocationQuery, *params.MaxTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.gte", runtime.ParamLocationQuery, *params.MaxTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.lt", runtime.ParamLocationQuery, *params.MaxTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ticker.lte", runtime.ParamLocationQuery, *params.MaxTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker", runtime.ParamLocationQuery, *params.MinTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.any_of", runtime.ParamLocationQuery, *params.MinTickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.gt", runtime.ParamLocationQuery, *params.MinTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.gte", runtime.ParamLocationQuery, *params.MinTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.lt", runtime.ParamLocationQuery, *params.MinTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ticker.lte", runtime.ParamLocationQuery, *params.MinTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksFinancialsV1RatiosRequest generates requests for GetStocksFinancialsV1Ratios
func NewGetStocksFinancialsV1RatiosRequest(server string, params *GetStocksFinancialsV1RatiosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/financials/v1/ratios")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.any_of", runtime.ParamLocationQuery, *params.CikAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gt", runtime.ParamLocationQuery, *params.CikGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.gte", runtime.ParamLocationQuery, *params.CikGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lt", runtime.ParamLocationQuery, *params.CikLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CikLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik.lte", runtime.ParamLocationQuery, *params.CikLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Price != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price", runtime.ParamLocationQuery, *params.Price); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price.gt", runtime.ParamLocationQuery, *params.PriceGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price.gte", runtime.ParamLocationQuery, *params.PriceGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price.lt", runtime.ParamLocationQuery, *params.PriceLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price.lte", runtime.ParamLocationQuery, *params.PriceLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AverageVolume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "average_volume", runtime.ParamLocationQuery, *params.AverageVolume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AverageVolumeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "average_volume.gt", runtime.ParamLocationQuery, *params.AverageVolumeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AverageVolumeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "average_volume.gte", runtime.ParamLocationQuery, *params.AverageVolumeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AverageVolumeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "average_volume.lt", runtime.ParamLocationQuery, *params.AverageVolumeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AverageVolumeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "average_volume.lte", runtime.ParamLocationQuery, *params.AverageVolumeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketCap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_cap", runtime.ParamLocationQuery, *params.MarketCap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketCapGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_cap.gt", runtime.ParamLocationQuery, *params.MarketCapGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketCapGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_cap.gte", runtime.ParamLocationQuery, *params.MarketCapGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketCapLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_cap.lt", runtime.ParamLocationQuery, *params.MarketCapLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketCapLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_cap.lte", runtime.ParamLocationQuery, *params.MarketCapLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarningsPerShare != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earnings_per_share", runtime.ParamLocationQuery, *params.EarningsPerShare); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarningsPerShareGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earnings_per_share.gt", runtime.ParamLocationQuery, *params.EarningsPerShareGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarningsPerShareGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earnings_per_share.gte", runtime.ParamLocationQuery, *params.EarningsPerShareGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarningsPerShareLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earnings_per_share.lt", runtime.ParamLocationQuery, *params.EarningsPerShareLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarningsPerShareLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earnings_per_share.lte", runtime.ParamLocationQuery, *params.EarningsPerShareLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToEarnings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_earnings", runtime.ParamLocationQuery, *params.PriceToEarnings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToEarningsGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_earnings.gt", runtime.ParamLocationQuery, *params.PriceToEarningsGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToEarningsGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_earnings.gte", runtime.ParamLocationQuery, *params.PriceToEarningsGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToEarningsLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_earnings.lt", runtime.ParamLocationQuery, *params.PriceToEarningsLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToEarningsLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_earnings.lte", runtime.ParamLocationQuery, *params.PriceToEarningsLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToBook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_book", runtime.ParamLocationQuery, *params.PriceToBook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToBookGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_book.gt", runtime.ParamLocationQuery, *params.PriceToBookGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToBookGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_book.gte", runtime.ParamLocationQuery, *params.PriceToBookGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToBookLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_book.lt", runtime.ParamLocationQuery, *params.PriceToBookLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToBookLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_book.lte", runtime.ParamLocationQuery, *params.PriceToBookLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToSales != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_sales", runtime.ParamLocationQuery, *params.PriceToSales); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToSalesGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_sales.gt", runtime.ParamLocationQuery, *params.PriceToSalesGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToSalesGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_sales.gte", runtime.ParamLocationQuery, *params.PriceToSalesGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToSalesLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_sales.lt", runtime.ParamLocationQuery, *params.PriceToSalesLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToSalesLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_sales.lte", runtime.ParamLocationQuery, *params.PriceToSalesLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToCashFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_cash_flow", runtime.ParamLocationQuery, *params.PriceToCashFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToCashFlowGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_cash_flow.gt", runtime.ParamLocationQuery, *params.PriceToCashFlowGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToCashFlowGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_cash_flow.gte", runtime.ParamLocationQuery, *params.PriceToCashFlowGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToCashFlowLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_cash_flow.lt", runtime.ParamLocationQuery, *params.PriceToCashFlowLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToCashFlowLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_cash_flow.lte", runtime.ParamLocationQuery, *params.PriceToCashFlowLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToFreeCashFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_free_cash_flow", runtime.ParamLocationQuery, *params.PriceToFreeCashFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToFreeCashFlowGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_free_cash_flow.gt", runtime.ParamLocationQuery, *params.PriceToFreeCashFlowGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToFreeCashFlowGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_free_cash_flow.gte", runtime.ParamLocationQuery, *params.PriceToFreeCashFlowGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToFreeCashFlowLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_free_cash_flow.lt", runtime.ParamLocationQuery, *params.PriceToFreeCashFlowLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceToFreeCashFlowLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to_free_cash_flow.lte", runtime.ParamLocationQuery, *params.PriceToFreeCashFlowLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DividendYield != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dividend_yield", runtime.ParamLocationQuery, *params.DividendYield); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DividendYieldGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dividend_yield.gt", runtime.ParamLocationQuery, *params.DividendYieldGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DividendYieldGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dividend_yield.gte", runtime.ParamLocationQuery, *params.DividendYieldGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DividendYieldLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dividend_yield.lt", runtime.ParamLocationQuery, *params.DividendYieldLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DividendYieldLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dividend_yield.lte", runtime.ParamLocationQuery, *params.DividendYieldLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnAssets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_assets", runtime.ParamLocationQuery, *params.ReturnOnAssets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnAssetsGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_assets.gt", runtime.ParamLocationQuery, *params.ReturnOnAssetsGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnAssetsGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_assets.gte", runtime.ParamLocationQuery, *params.ReturnOnAssetsGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnAssetsLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_assets.lt", runtime.ParamLocationQuery, *params.ReturnOnAssetsLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnAssetsLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_assets.lte", runtime.ParamLocationQuery, *params.ReturnOnAssetsLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnEquity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_equity", runtime.ParamLocationQuery, *params.ReturnOnEquity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnEquityGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_equity.gt", runtime.ParamLocationQuery, *params.ReturnOnEquityGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnEquityGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_equity.gte", runtime.ParamLocationQuery, *params.ReturnOnEquityGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnEquityLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_equity.lt", runtime.ParamLocationQuery, *params.ReturnOnEquityLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnOnEquityLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_on_equity.lte", runtime.ParamLocationQuery, *params.ReturnOnEquityLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DebtToEquity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debt_to_equity", runtime.ParamLocationQuery, *params.DebtToEquity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DebtToEquityGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debt_to_equity.gt", runtime.ParamLocationQuery, *params.DebtToEquityGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DebtToEquityGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debt_to_equity.gte", runtime.ParamLocationQuery, *params.DebtToEquityGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DebtToEquityLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debt_to_equity.lt", runtime.ParamLocationQuery, *params.DebtToEquityLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DebtToEquityLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debt_to_equity.lte", runtime.ParamLocationQuery, *params.DebtToEquityLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Current != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current", runtime.ParamLocationQuery, *params.Current); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current.gt", runtime.ParamLocationQuery, *params.CurrentGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current.gte", runtime.ParamLocationQuery, *params.CurrentGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current.lt", runtime.ParamLocationQuery, *params.CurrentLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current.lte", runtime.ParamLocationQuery, *params.CurrentLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quick != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quick", runtime.ParamLocationQuery, *params.Quick); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuickGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quick.gt", runtime.ParamLocationQuery, *params.QuickGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuickGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quick.gte", runtime.ParamLocationQuery, *params.QuickGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuickLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quick.lt", runtime.ParamLocationQuery, *params.QuickLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuickLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quick.lte", runtime.ParamLocationQuery, *params.QuickLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash", runtime.ParamLocationQuery, *params.Cash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash.gt", runtime.ParamLocationQuery, *params.CashGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash.gte", runtime.ParamLocationQuery, *params.CashGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash.lt", runtime.ParamLocationQuery, *params.CashLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash.lte", runtime.ParamLocationQuery, *params.CashLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToSales != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_sales", runtime.ParamLocationQuery, *params.EvToSales); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToSalesGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_sales.gt", runtime.ParamLocationQuery, *params.EvToSalesGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToSalesGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_sales.gte", runtime.ParamLocationQuery, *params.EvToSalesGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToSalesLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_sales.lt", runtime.ParamLocationQuery, *params.EvToSalesLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToSalesLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_sales.lte", runtime.ParamLocationQuery, *params.EvToSalesLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToEbitda != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_ebitda", runtime.ParamLocationQuery, *params.EvToEbitda); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToEbitdaGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_ebitda.gt", runtime.ParamLocationQuery, *params.EvToEbitdaGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToEbitdaGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_ebitda.gte", runtime.ParamLocationQuery, *params.EvToEbitdaGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToEbitdaLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_ebitda.lt", runtime.ParamLocationQuery, *params.EvToEbitdaLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EvToEbitdaLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ev_to_ebitda.lte", runtime.ParamLocationQuery, *params.EvToEbitdaLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnterpriseValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enterprise_value", runtime.ParamLocationQuery, *params.EnterpriseValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnterpriseValueGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enterprise_value.gt", runtime.ParamLocationQuery, *params.EnterpriseValueGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnterpriseValueGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enterprise_value.gte", runtime.ParamLocationQuery, *params.EnterpriseValueGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnterpriseValueLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enterprise_value.lt", runtime.ParamLocationQuery, *params.EnterpriseValueLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnterpriseValueLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enterprise_value.lte", runtime.ParamLocationQuery, *params.EnterpriseValueLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeCashFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_cash_flow", runtime.ParamLocationQuery, *params.FreeCashFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeCashFlowGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_cash_flow.gt", runtime.ParamLocationQuery, *params.FreeCashFlowGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeCashFlowGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_cash_flow.gte", runtime.ParamLocationQuery, *params.FreeCashFlowGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeCashFlowLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_cash_flow.lt", runtime.ParamLocationQuery, *params.FreeCashFlowLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeCashFlowLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_cash_flow.lte", runtime.ParamLocationQuery, *params.FreeCashFlowLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksTaxonomiesVXRiskFactorsRequest generates requests for GetStocksTaxonomiesVXRiskFactors
func NewGetStocksTaxonomiesVXRiskFactorsRequest(server string, params *GetStocksTaxonomiesVXRiskFactorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/taxonomies/vX/risk-factors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Taxonomy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxonomy", runtime.ParamLocationQuery, *params.Taxonomy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxonomyGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxonomy.gt", runtime.ParamLocationQuery, *params.TaxonomyGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxonomyGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxonomy.gte", runtime.ParamLocationQuery, *params.TaxonomyGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxonomyLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxonomy.lt", runtime.ParamLocationQuery, *params.TaxonomyLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxonomyLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxonomy.lte", runtime.ParamLocationQuery, *params.TaxonomyLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_category", runtime.ParamLocationQuery, *params.PrimaryCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryCategoryAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_category.any_of", runtime.ParamLocationQuery, *params.PrimaryCategoryAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryCategoryGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_category.gt", runtime.ParamLocationQuery, *params.PrimaryCategoryGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryCategoryGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_category.gte", runtime.ParamLocationQuery, *params.PrimaryCategoryGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryCategoryLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_category.lt", runtime.ParamLocationQuery, *params.PrimaryCategoryLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryCategoryLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_category.lte", runtime.ParamLocationQuery, *params.PrimaryCategoryLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondaryCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondary_category", runtime.ParamLocationQuery, *params.SecondaryCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondaryCategoryAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondary_category.any_of", runtime.ParamLocationQuery, *params.SecondaryCategoryAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondaryCategoryGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondary_category.gt", runtime.ParamLocationQuery, *params.SecondaryCategoryGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondaryCategoryGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondary_category.gte", runtime.ParamLocationQuery, *params.SecondaryCategoryGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondaryCategoryLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondary_category.lt", runtime.ParamLocationQuery, *params.SecondaryCategoryLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondaryCategoryLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondary_category.lte", runtime.ParamLocationQuery, *params.SecondaryCategoryLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TertiaryCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tertiary_category", runtime.ParamLocationQuery, *params.TertiaryCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TertiaryCategoryAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tertiary_category.any_of", runtime.ParamLocationQuery, *params.TertiaryCategoryAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TertiaryCategoryGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tertiary_category.gt", runtime.ParamLocationQuery, *params.TertiaryCategoryGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TertiaryCategoryGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tertiary_category.gte", runtime.ParamLocationQuery, *params.TertiaryCategoryGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TertiaryCategoryLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tertiary_category.lt", runtime.ParamLocationQuery, *params.TertiaryCategoryLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TertiaryCategoryLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tertiary_category.lte", runtime.ParamLocationQuery, *params.TertiaryCategoryLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksV1DividendsRequest generates requests for GetStocksV1Dividends
func NewGetStocksV1DividendsRequest(server string, params *GetStocksV1DividendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/v1/dividends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date", runtime.ParamLocationQuery, *params.ExDividendDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.gt", runtime.ParamLocationQuery, *params.ExDividendDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.gte", runtime.ParamLocationQuery, *params.ExDividendDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.lt", runtime.ParamLocationQuery, *params.ExDividendDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.lte", runtime.ParamLocationQuery, *params.ExDividendDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Frequency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FrequencyGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency.gt", runtime.ParamLocationQuery, *params.FrequencyGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FrequencyGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency.gte", runtime.ParamLocationQuery, *params.FrequencyGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FrequencyLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency.lt", runtime.ParamLocationQuery, *params.FrequencyLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FrequencyLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency.lte", runtime.ParamLocationQuery, *params.FrequencyLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DistributionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distribution_type", runtime.ParamLocationQuery, *params.DistributionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DistributionTypeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distribution_type.any_of", runtime.ParamLocationQuery, *params.DistributionTypeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksV1ExchangesRequest generates requests for GetStocksV1Exchanges
func NewGetStocksV1ExchangesRequest(server string, params *GetStocksV1ExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/v1/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksV1ShortInterestRequest generates requests for GetStocksV1ShortInterest
func NewGetStocksV1ShortInterestRequest(server string, params *GetStocksV1ShortInterestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/v1/short-interest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysToCover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_to_cover", runtime.ParamLocationQuery, *params.DaysToCover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysToCoverAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_to_cover.any_of", runtime.ParamLocationQuery, *params.DaysToCoverAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysToCoverGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_to_cover.gt", runtime.ParamLocationQuery, *params.DaysToCoverGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysToCoverGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_to_cover.gte", runtime.ParamLocationQuery, *params.DaysToCoverGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysToCoverLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_to_cover.lt", runtime.ParamLocationQuery, *params.DaysToCoverLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysToCoverLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_to_cover.lte", runtime.ParamLocationQuery, *params.DaysToCoverLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SettlementDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "settlement_date", runtime.ParamLocationQuery, *params.SettlementDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SettlementDateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "settlement_date.any_of", runtime.ParamLocationQuery, *params.SettlementDateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SettlementDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "settlement_date.gt", runtime.ParamLocationQuery, *params.SettlementDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SettlementDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "settlement_date.gte", runtime.ParamLocationQuery, *params.SettlementDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SettlementDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "settlement_date.lt", runtime.ParamLocationQuery, *params.SettlementDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SettlementDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "settlement_date.lte", runtime.ParamLocationQuery, *params.SettlementDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvgDailyVolume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avg_daily_volume", runtime.ParamLocationQuery, *params.AvgDailyVolume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvgDailyVolumeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avg_daily_volume.any_of", runtime.ParamLocationQuery, *params.AvgDailyVolumeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvgDailyVolumeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avg_daily_volume.gt", runtime.ParamLocationQuery, *params.AvgDailyVolumeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvgDailyVolumeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avg_daily_volume.gte", runtime.ParamLocationQuery, *params.AvgDailyVolumeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvgDailyVolumeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avg_daily_volume.lt", runtime.ParamLocationQuery, *params.AvgDailyVolumeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvgDailyVolumeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avg_daily_volume.lte", runtime.ParamLocationQuery, *params.AvgDailyVolumeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksV1ShortVolumeRequest generates requests for GetStocksV1ShortVolume
func NewGetStocksV1ShortVolumeRequest(server string, params *GetStocksV1ShortVolumeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/v1/short-volume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortVolumeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_volume_ratio", runtime.ParamLocationQuery, *params.ShortVolumeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortVolumeRatioAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_volume_ratio.any_of", runtime.ParamLocationQuery, *params.ShortVolumeRatioAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortVolumeRatioGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_volume_ratio.gt", runtime.ParamLocationQuery, *params.ShortVolumeRatioGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortVolumeRatioGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_volume_ratio.gte", runtime.ParamLocationQuery, *params.ShortVolumeRatioGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortVolumeRatioLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_volume_ratio.lt", runtime.ParamLocationQuery, *params.ShortVolumeRatioLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortVolumeRatioLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_volume_ratio.lte", runtime.ParamLocationQuery, *params.ShortVolumeRatioLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalVolume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_volume", runtime.ParamLocationQuery, *params.TotalVolume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalVolumeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_volume.any_of", runtime.ParamLocationQuery, *params.TotalVolumeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalVolumeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_volume.gt", runtime.ParamLocationQuery, *params.TotalVolumeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalVolumeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_volume.gte", runtime.ParamLocationQuery, *params.TotalVolumeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalVolumeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_volume.lt", runtime.ParamLocationQuery, *params.TotalVolumeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalVolumeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_volume.lte", runtime.ParamLocationQuery, *params.TotalVolumeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksV1SplitsRequest generates requests for GetStocksV1Splits
func NewGetStocksV1SplitsRequest(server string, params *GetStocksV1SplitsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/v1/splits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date", runtime.ParamLocationQuery, *params.ExecutionDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.gt", runtime.ParamLocationQuery, *params.ExecutionDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.gte", runtime.ParamLocationQuery, *params.ExecutionDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.lt", runtime.ParamLocationQuery, *params.ExecutionDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.lte", runtime.ParamLocationQuery, *params.ExecutionDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjustmentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjustment_type", runtime.ParamLocationQuery, *params.AdjustmentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjustmentTypeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjustment_type.any_of", runtime.ParamLocationQuery, *params.AdjustmentTypeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksVXFloatRequest generates requests for GetStocksVXFloat
func NewGetStocksVXFloatRequest(server string, params *GetStocksVXFloatParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stocks/vX/float")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeFloatPercent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_float_percent", runtime.ParamLocationQuery, *params.FreeFloatPercent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeFloatPercentGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_float_percent.gt", runtime.ParamLocationQuery, *params.FreeFloatPercentGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeFloatPercentGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_float_percent.gte", runtime.ParamLocationQuery, *params.FreeFloatPercentGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeFloatPercentLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_float_percent.lt", runtime.ParamLocationQuery, *params.FreeFloatPercentLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeFloatPercentLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free_float_percent.lte", runtime.ParamLocationQuery, *params.FreeFloatPercentLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTmxV1CorporateEventsRequest generates requests for GetTmxV1CorporateEvents
func NewGetTmxV1CorporateEventsRequest(server string, params *GetTmxV1CorporateEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tmx/v1/corporate-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.any_of", runtime.ParamLocationQuery, *params.DateAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gt", runtime.ParamLocationQuery, *params.DateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.gte", runtime.ParamLocationQuery, *params.DateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lt", runtime.ParamLocationQuery, *params.DateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date.lte", runtime.ParamLocationQuery, *params.DateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.any_of", runtime.ParamLocationQuery, *params.TypeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.gt", runtime.ParamLocationQuery, *params.TypeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.gte", runtime.ParamLocationQuery, *params.TypeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.lt", runtime.ParamLocationQuery, *params.TypeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.lte", runtime.ParamLocationQuery, *params.TypeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status.any_of", runtime.ParamLocationQuery, *params.StatusAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status.gt", runtime.ParamLocationQuery, *params.StatusGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status.gte", runtime.ParamLocationQuery, *params.StatusGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status.lt", runtime.ParamLocationQuery, *params.StatusLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status.lte", runtime.ParamLocationQuery, *params.StatusLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Isin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin", runtime.ParamLocationQuery, *params.Isin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.any_of", runtime.ParamLocationQuery, *params.IsinAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.gt", runtime.ParamLocationQuery, *params.IsinGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.gte", runtime.ParamLocationQuery, *params.IsinGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.lt", runtime.ParamLocationQuery, *params.IsinLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.lte", runtime.ParamLocationQuery, *params.IsinLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue", runtime.ParamLocationQuery, *params.TradingVenue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.any_of", runtime.ParamLocationQuery, *params.TradingVenueAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.gt", runtime.ParamLocationQuery, *params.TradingVenueGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.gte", runtime.ParamLocationQuery, *params.TradingVenueGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.lt", runtime.ParamLocationQuery, *params.TradingVenueLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TradingVenueLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trading_venue.lte", runtime.ParamLocationQuery, *params.TradingVenueLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxCompanyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_company_id", runtime.ParamLocationQuery, *params.TmxCompanyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxCompanyIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_company_id.gt", runtime.ParamLocationQuery, *params.TmxCompanyIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxCompanyIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_company_id.gte", runtime.ParamLocationQuery, *params.TmxCompanyIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxCompanyIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_company_id.lt", runtime.ParamLocationQuery, *params.TmxCompanyIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxCompanyIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_company_id.lte", runtime.ParamLocationQuery, *params.TmxCompanyIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxRecordId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_record_id", runtime.ParamLocationQuery, *params.TmxRecordId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxRecordIdAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_record_id.any_of", runtime.ParamLocationQuery, *params.TmxRecordIdAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxRecordIdGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_record_id.gt", runtime.ParamLocationQuery, *params.TmxRecordIdGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxRecordIdGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_record_id.gte", runtime.ParamLocationQuery, *params.TmxRecordIdGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxRecordIdLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_record_id.lt", runtime.ParamLocationQuery, *params.TmxRecordIdLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TmxRecordIdLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmx_record_id.lte", runtime.ParamLocationQuery, *params.TmxRecordIdLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrencyConversionRequest generates requests for GetCurrencyConversion
func NewGetCurrencyConversionRequest(server string, from string, to string, params *GetCurrencyConversionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/conversion/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Amount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeprecatedGetHistoricCryptoTradesRequest generates requests for DeprecatedGetHistoricCryptoTrades
func NewDeprecatedGetHistoricCryptoTradesRequest(server string, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricCryptoTradesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/historic/crypto/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeprecatedGetHistoricForexQuotesRequest generates requests for DeprecatedGetHistoricForexQuotes
func NewDeprecatedGetHistoricForexQuotesRequest(server string, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricForexQuotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/historic/forex/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoEMARequest generates requests for GetCryptoEMA
func NewGetCryptoEMARequest(server string, cryptoTicker string, params *GetCryptoEMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/ema/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexEMARequest generates requests for GetForexEMA
func NewGetForexEMARequest(server string, fxTicker string, params *GetForexEMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fxTicker", runtime.ParamLocationPath, fxTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/ema/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesEMARequest generates requests for GetIndicesEMA
func NewGetIndicesEMARequest(server string, indicesTicker string, params *GetIndicesEMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/ema/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsEMARequest generates requests for GetOptionsEMA
func NewGetOptionsEMARequest(server string, optionsTicker string, params *GetOptionsEMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/ema/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksEMARequest generates requests for GetStocksEMA
func NewGetStocksEMARequest(server string, stockTicker string, params *GetStocksEMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stockTicker", runtime.ParamLocationPath, stockTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/ema/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoMACDRequest generates requests for GetCryptoMACD
func NewGetCryptoMACDRequest(server string, cryptoTicker string, params *GetCryptoMACDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/macd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_window", runtime.ParamLocationQuery, *params.ShortWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LongWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "long_window", runtime.ParamLocationQuery, *params.LongWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SignalWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal_window", runtime.ParamLocationQuery, *params.SignalWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexMACDRequest generates requests for GetForexMACD
func NewGetForexMACDRequest(server string, fxTicker string, params *GetForexMACDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fxTicker", runtime.ParamLocationPath, fxTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/macd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_window", runtime.ParamLocationQuery, *params.ShortWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LongWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "long_window", runtime.ParamLocationQuery, *params.LongWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SignalWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal_window", runtime.ParamLocationQuery, *params.SignalWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesMACDRequest generates requests for GetIndicesMACD
func NewGetIndicesMACDRequest(server string, indicesTicker string, params *GetIndicesMACDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/macd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_window", runtime.ParamLocationQuery, *params.ShortWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LongWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "long_window", runtime.ParamLocationQuery, *params.LongWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SignalWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal_window", runtime.ParamLocationQuery, *params.SignalWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsMACDRequest generates requests for GetOptionsMACD
func NewGetOptionsMACDRequest(server string, optionsTicker string, params *GetOptionsMACDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/macd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_window", runtime.ParamLocationQuery, *params.ShortWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LongWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "long_window", runtime.ParamLocationQuery, *params.LongWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SignalWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal_window", runtime.ParamLocationQuery, *params.SignalWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksMACDRequest generates requests for GetStocksMACD
func NewGetStocksMACDRequest(server string, stockTicker string, params *GetStocksMACDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stockTicker", runtime.ParamLocationPath, stockTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/macd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short_window", runtime.ParamLocationQuery, *params.ShortWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LongWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "long_window", runtime.ParamLocationQuery, *params.LongWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SignalWindow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal_window", runtime.ParamLocationQuery, *params.SignalWindow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoRSIRequest generates requests for GetCryptoRSI
func NewGetCryptoRSIRequest(server string, cryptoTicker string, params *GetCryptoRSIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/rsi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexRSIRequest generates requests for GetForexRSI
func NewGetForexRSIRequest(server string, fxTicker string, params *GetForexRSIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fxTicker", runtime.ParamLocationPath, fxTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/rsi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesRSIRequest generates requests for GetIndicesRSI
func NewGetIndicesRSIRequest(server string, indicesTicker string, params *GetIndicesRSIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/rsi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsRSIRequest generates requests for GetOptionsRSI
func NewGetOptionsRSIRequest(server string, optionsTicker string, params *GetOptionsRSIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/rsi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksRSIRequest generates requests for GetStocksRSI
func NewGetStocksRSIRequest(server string, stockTicker string, params *GetStocksRSIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stockTicker", runtime.ParamLocationPath, stockTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/rsi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoSMARequest generates requests for GetCryptoSMA
func NewGetCryptoSMARequest(server string, cryptoTicker string, params *GetCryptoSMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/sma/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexSMARequest generates requests for GetForexSMA
func NewGetForexSMARequest(server string, fxTicker string, params *GetForexSMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fxTicker", runtime.ParamLocationPath, fxTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/sma/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesSMARequest generates requests for GetIndicesSMA
func NewGetIndicesSMARequest(server string, indicesTicker string, params *GetIndicesSMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/sma/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsSMARequest generates requests for GetOptionsSMA
func NewGetOptionsSMARequest(server string, optionsTicker string, params *GetOptionsSMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/sma/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksSMARequest generates requests for GetStocksSMA
func NewGetStocksSMARequest(server string, stockTicker string, params *GetStocksSMAParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stockTicker", runtime.ParamLocationPath, stockTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/indicators/sma/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timespan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timespan", runtime.ParamLocationQuery, *params.Timespan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Window != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "window", runtime.ParamLocationQuery, *params.Window); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series_type", runtime.ParamLocationQuery, *params.SeriesType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpandUnderlying != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand_underlying", runtime.ParamLocationQuery, *params.ExpandUnderlying); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastCryptoTradeRequest generates requests for GetLastCryptoTrade
func NewGetLastCryptoTradeRequest(server string, from string, to string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/last/crypto/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastCurrencyQuoteRequest generates requests for GetLastCurrencyQuote
func NewGetLastCurrencyQuoteRequest(server string, from string, to string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/last_quote/currencies/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketStatusRequest generates requests for GetMarketStatus
func NewGetMarketStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/marketstatus/now")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketHolidaysRequest generates requests for GetMarketHolidays
func NewGetMarketHolidaysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/marketstatus/upcoming")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoOpenCloseRequest generates requests for GetCryptoOpenClose
func NewGetCryptoOpenCloseRequest(server string, from string, to string, date openapi_types.Date, params *GetCryptoOpenCloseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/open-close/crypto/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesOpenCloseRequest generates requests for GetIndicesOpenClose
func NewGetIndicesOpenCloseRequest(server string, indicesTicker string, date string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/open-close/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsOpenCloseRequest generates requests for GetOptionsOpenClose
func NewGetOptionsOpenCloseRequest(server string, optionsTicker string, date openapi_types.Date, params *GetOptionsOpenCloseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/open-close/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksOpenCloseRequest generates requests for GetStocksOpenClose
func NewGetStocksOpenCloseRequest(server string, stocksTicker string, date openapi_types.Date, params *GetStocksOpenCloseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stocksTicker", runtime.ParamLocationPath, stocksTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/open-close/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV1ReferenceIposRequest generates requests for GetV1ReferenceIpos
func NewGetV1ReferenceIposRequest(server string, params *GetV1ReferenceIposParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reference/ipos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code", runtime.ParamLocationQuery, *params.UsCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.any_of", runtime.ParamLocationQuery, *params.UsCodeAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.gt", runtime.ParamLocationQuery, *params.UsCodeGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.gte", runtime.ParamLocationQuery, *params.UsCodeGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.lt", runtime.ParamLocationQuery, *params.UsCodeLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCodeLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code.lte", runtime.ParamLocationQuery, *params.UsCodeLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Isin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin", runtime.ParamLocationQuery, *params.Isin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.any_of", runtime.ParamLocationQuery, *params.IsinAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.gt", runtime.ParamLocationQuery, *params.IsinGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.gte", runtime.ParamLocationQuery, *params.IsinGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.lt", runtime.ParamLocationQuery, *params.IsinLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsinLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin.lte", runtime.ParamLocationQuery, *params.IsinLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date", runtime.ParamLocationQuery, *params.ListingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.gt", runtime.ParamLocationQuery, *params.ListingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.gte", runtime.ParamLocationQuery, *params.ListingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.lt", runtime.ParamLocationQuery, *params.ListingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.lte", runtime.ParamLocationQuery, *params.ListingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpoStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipo_status", runtime.ParamLocationQuery, *params.IpoStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpoStatusAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipo_status.any_of", runtime.ParamLocationQuery, *params.IpoStatusAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRelatedCompaniesRequest generates requests for GetRelatedCompanies
func NewGetRelatedCompaniesRequest(server string, ticker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/related-companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSnapshotSummaryRequest generates requests for GetSnapshotSummary
func NewGetSnapshotSummaryRequest(server string, params *GetSnapshotSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/summaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupedCryptoAggregatesRequest generates requests for GetGroupedCryptoAggregates
func NewGetGroupedCryptoAggregatesRequest(server string, date string, params *GetGroupedCryptoAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/grouped/locale/global/market/crypto/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupedForexAggregatesRequest generates requests for GetGroupedForexAggregates
func NewGetGroupedForexAggregatesRequest(server string, date string, params *GetGroupedForexAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/grouped/locale/global/market/fx/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupedStocksAggregatesRequest generates requests for GetGroupedStocksAggregates
func NewGetGroupedStocksAggregatesRequest(server string, date string, params *GetGroupedStocksAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/grouped/locale/us/market/stocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOtc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_otc", runtime.ParamLocationQuery, *params.IncludeOtc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreviousCryptoAggregatesRequest generates requests for GetPreviousCryptoAggregates
func NewGetPreviousCryptoAggregatesRequest(server string, cryptoTicker string, params *GetPreviousCryptoAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/prev", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoAggregatesRequest generates requests for GetCryptoAggregates
func NewGetCryptoAggregatesRequest(server string, cryptoTicker string, multiplier int, timespan GetCryptoAggregatesParamsTimespan, from string, to string, params *GetCryptoAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "multiplier", runtime.ParamLocationPath, multiplier)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "timespan", runtime.ParamLocationPath, timespan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/range/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreviousForexAggregatesRequest generates requests for GetPreviousForexAggregates
func NewGetPreviousForexAggregatesRequest(server string, forexTicker string, params *GetPreviousForexAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forexTicker", runtime.ParamLocationPath, forexTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/prev", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexAggregatesRequest generates requests for GetForexAggregates
func NewGetForexAggregatesRequest(server string, forexTicker string, multiplier int, timespan GetForexAggregatesParamsTimespan, from string, to string, params *GetForexAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forexTicker", runtime.ParamLocationPath, forexTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "multiplier", runtime.ParamLocationPath, multiplier)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "timespan", runtime.ParamLocationPath, timespan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/range/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreviousIndicesAggregatesRequest generates requests for GetPreviousIndicesAggregates
func NewGetPreviousIndicesAggregatesRequest(server string, indicesTicker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/prev", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesAggregatesRequest generates requests for GetIndicesAggregates
func NewGetIndicesAggregatesRequest(server string, indicesTicker string, multiplier int, timespan GetIndicesAggregatesParamsTimespan, from string, to string, params *GetIndicesAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "indicesTicker", runtime.ParamLocationPath, indicesTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "multiplier", runtime.ParamLocationPath, multiplier)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "timespan", runtime.ParamLocationPath, timespan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/range/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreviousOptionsAggregatesRequest generates requests for GetPreviousOptionsAggregates
func NewGetPreviousOptionsAggregatesRequest(server string, optionsTicker string, params *GetPreviousOptionsAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/prev", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsAggregatesRequest generates requests for GetOptionsAggregates
func NewGetOptionsAggregatesRequest(server string, optionsTicker string, multiplier int, timespan GetOptionsAggregatesParamsTimespan, from string, to string, params *GetOptionsAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "multiplier", runtime.ParamLocationPath, multiplier)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "timespan", runtime.ParamLocationPath, timespan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/range/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreviousStocksAggregatesRequest generates requests for GetPreviousStocksAggregates
func NewGetPreviousStocksAggregatesRequest(server string, stocksTicker string, params *GetPreviousStocksAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stocksTicker", runtime.ParamLocationPath, stocksTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/prev", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksAggregatesRequest generates requests for GetStocksAggregates
func NewGetStocksAggregatesRequest(server string, stocksTicker string, multiplier int, timespan GetStocksAggregatesParamsTimespan, from string, to string, params *GetStocksAggregatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stocksTicker", runtime.ParamLocationPath, stocksTicker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "multiplier", runtime.ParamLocationPath, multiplier)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "timespan", runtime.ParamLocationPath, timespan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "from", runtime.ParamLocationPath, from)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "to", runtime.ParamLocationPath, to)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/aggs/ticker/%s/range/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Adjusted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjusted", runtime.ParamLocationQuery, *params.Adjusted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastStocksQuoteRequest generates requests for GetLastStocksQuote
func NewGetLastStocksQuoteRequest(server string, stocksTicker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stocksTicker", runtime.ParamLocationPath, stocksTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/last/nbbo/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastOptionsTradeRequest generates requests for GetLastOptionsTrade
func NewGetLastOptionsTradeRequest(server string, optionsTicker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/last/trade/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastStocksTradeRequest generates requests for GetLastStocksTrade
func NewGetLastStocksTradeRequest(server string, stocksTicker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stocksTicker", runtime.ParamLocationPath, stocksTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/last/trade/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNewsRequest generates requests for ListNews
func NewListNewsRequest(server string, params *ListNewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/reference/news")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedUtc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_utc", runtime.ParamLocationQuery, *params.PublishedUtc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedUtcGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_utc.gte", runtime.ParamLocationQuery, *params.PublishedUtcGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedUtcGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_utc.gt", runtime.ParamLocationQuery, *params.PublishedUtcGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedUtcLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_utc.lte", runtime.ParamLocationQuery, *params.PublishedUtcLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedUtcLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_utc.lt", runtime.ParamLocationQuery, *params.PublishedUtcLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoSnapshotTickersRequest generates requests for GetCryptoSnapshotTickers
func NewGetCryptoSnapshotTickersRequest(server string, params *GetCryptoSnapshotTickersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/crypto/tickers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoSnapshotTickerRequest generates requests for GetCryptoSnapshotTicker
func NewGetCryptoSnapshotTickerRequest(server string, ticker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/crypto/tickers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeprecatedGetCryptoSnapshotTickerBookRequest generates requests for DeprecatedGetCryptoSnapshotTickerBook
func NewDeprecatedGetCryptoSnapshotTickerBookRequest(server string, ticker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/crypto/tickers/%s/book", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoSnapshotDirectionRequest generates requests for GetCryptoSnapshotDirection
func NewGetCryptoSnapshotDirectionRequest(server string, direction GetCryptoSnapshotDirectionParamsDirection) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "direction", runtime.ParamLocationPath, direction)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/crypto/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexSnapshotTickersRequest generates requests for GetForexSnapshotTickers
func NewGetForexSnapshotTickersRequest(server string, params *GetForexSnapshotTickersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/forex/tickers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexSnapshotTickerRequest generates requests for GetForexSnapshotTicker
func NewGetForexSnapshotTickerRequest(server string, ticker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/forex/tickers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexSnapshotDirectionRequest generates requests for GetForexSnapshotDirection
func NewGetForexSnapshotDirectionRequest(server string, direction GetForexSnapshotDirectionParamsDirection) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "direction", runtime.ParamLocationPath, direction)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/global/markets/forex/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksSnapshotTickersRequest generates requests for GetStocksSnapshotTickers
func NewGetStocksSnapshotTickersRequest(server string, params *GetStocksSnapshotTickersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/us/markets/stocks/tickers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOtc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_otc", runtime.ParamLocationQuery, *params.IncludeOtc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksSnapshotTickerRequest generates requests for GetStocksSnapshotTicker
func NewGetStocksSnapshotTickerRequest(server string, stocksTicker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stocksTicker", runtime.ParamLocationPath, stocksTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/us/markets/stocks/tickers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksSnapshotDirectionRequest generates requests for GetStocksSnapshotDirection
func NewGetStocksSnapshotDirectionRequest(server string, direction GetStocksSnapshotDirectionParamsDirection, params *GetStocksSnapshotDirectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "direction", runtime.ParamLocationPath, direction)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/snapshot/locale/us/markets/stocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeOtc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_otc", runtime.ParamLocationQuery, *params.IncludeOtc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeprecatedGetHistoricStocksQuotesRequest generates requests for DeprecatedGetHistoricStocksQuotes
func NewDeprecatedGetHistoricStocksQuotesRequest(server string, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksQuotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ticks/stocks/nbbo/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestampLimit", runtime.ParamLocationQuery, *params.TimestampLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeprecatedGetHistoricStocksTradesRequest generates requests for DeprecatedGetHistoricStocksTrades
func NewDeprecatedGetHistoricStocksTradesRequest(server string, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksTradesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ticks/stocks/trades/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestampLimit", runtime.ParamLocationQuery, *params.TimestampLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForexQuotesRequest generates requests for GetForexQuotes
func NewGetForexQuotesRequest(server string, fxTicker string, params *GetForexQuotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fxTicker", runtime.ParamLocationPath, fxTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/quotes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsQuotesRequest generates requests for GetOptionsQuotes
func NewGetOptionsQuotesRequest(server string, optionsTicker string, params *GetOptionsQuotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/quotes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksQuotesRequest generates requests for GetStocksQuotes
func NewGetStocksQuotesRequest(server string, stockTicker string, params *GetStocksQuotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stockTicker", runtime.ParamLocationPath, stockTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/quotes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConditionsRequest generates requests for ListConditions
func NewListConditionsRequest(server string, params *ListConditionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/conditions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_class", runtime.ParamLocationQuery, *params.AssetClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DataType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_type", runtime.ParamLocationQuery, *params.DataType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sip", runtime.ParamLocationQuery, *params.Sip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDividendsRequest generates requests for ListDividends
func NewListDividendsRequest(server string, params *ListDividendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/dividends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date", runtime.ParamLocationQuery, *params.ExDividendDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RecordDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "record_date", runtime.ParamLocationQuery, *params.RecordDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeclarationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "declaration_date", runtime.ParamLocationQuery, *params.DeclarationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PayDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pay_date", runtime.ParamLocationQuery, *params.PayDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Frequency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "frequency", runtime.ParamLocationQuery, *params.Frequency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashAmount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_amount", runtime.ParamLocationQuery, *params.CashAmount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DividendType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dividend_type", runtime.ParamLocationQuery, *params.DividendType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.gte", runtime.ParamLocationQuery, *params.ExDividendDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.gt", runtime.ParamLocationQuery, *params.ExDividendDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.lte", runtime.ParamLocationQuery, *params.ExDividendDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExDividendDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ex_dividend_date.lt", runtime.ParamLocationQuery, *params.ExDividendDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RecordDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "record_date.gte", runtime.ParamLocationQuery, *params.RecordDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RecordDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "record_date.gt", runtime.ParamLocationQuery, *params.RecordDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RecordDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "record_date.lte", runtime.ParamLocationQuery, *params.RecordDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RecordDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "record_date.lt", runtime.ParamLocationQuery, *params.RecordDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeclarationDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "declaration_date.gte", runtime.ParamLocationQuery, *params.DeclarationDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeclarationDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "declaration_date.gt", runtime.ParamLocationQuery, *params.DeclarationDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeclarationDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "declaration_date.lte", runtime.ParamLocationQuery, *params.DeclarationDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeclarationDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "declaration_date.lt", runtime.ParamLocationQuery, *params.DeclarationDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PayDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pay_date.gte", runtime.ParamLocationQuery, *params.PayDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PayDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pay_date.gt", runtime.ParamLocationQuery, *params.PayDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PayDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pay_date.lte", runtime.ParamLocationQuery, *params.PayDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PayDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pay_date.lt", runtime.ParamLocationQuery, *params.PayDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashAmountGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_amount.gte", runtime.ParamLocationQuery, *params.CashAmountGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashAmountGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_amount.gt", runtime.ParamLocationQuery, *params.CashAmountGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashAmountLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_amount.lte", runtime.ParamLocationQuery, *params.CashAmountLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CashAmountLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_amount.lt", runtime.ParamLocationQuery, *params.CashAmountLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExchangesRequest generates requests for ListExchanges
func NewListExchangesRequest(server string, params *ListExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_class", runtime.ParamLocationQuery, *params.AssetClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOptionsContractsRequest generates requests for ListOptionsContracts
func NewListOptionsContractsRequest(server string, params *ListOptionsContractsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/options/contracts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UnderlyingTicker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "underlying_ticker", runtime.ParamLocationQuery, *params.UnderlyingTicker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContractType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contract_type", runtime.ParamLocationQuery, *params.ContractType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date", runtime.ParamLocationQuery, *params.ExpirationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AsOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "as_of", runtime.ParamLocationQuery, *params.AsOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePrice != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price", runtime.ParamLocationQuery, *params.StrikePrice); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expired", runtime.ParamLocationQuery, *params.Expired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnderlyingTickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "underlying_ticker.gte", runtime.ParamLocationQuery, *params.UnderlyingTickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnderlyingTickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "underlying_ticker.gt", runtime.ParamLocationQuery, *params.UnderlyingTickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnderlyingTickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "underlying_ticker.lte", runtime.ParamLocationQuery, *params.UnderlyingTickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnderlyingTickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "underlying_ticker.lt", runtime.ParamLocationQuery, *params.UnderlyingTickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.gte", runtime.ParamLocationQuery, *params.ExpirationDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.gt", runtime.ParamLocationQuery, *params.ExpirationDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.lte", runtime.ParamLocationQuery, *params.ExpirationDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.lt", runtime.ParamLocationQuery, *params.ExpirationDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.gte", runtime.ParamLocationQuery, *params.StrikePriceGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.gt", runtime.ParamLocationQuery, *params.StrikePriceGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.lte", runtime.ParamLocationQuery, *params.StrikePriceLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.lt", runtime.ParamLocationQuery, *params.StrikePriceLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsContractRequest generates requests for GetOptionsContract
func NewGetOptionsContractRequest(server string, optionsTicker string, params *GetOptionsContractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "options_ticker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/options/contracts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AsOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "as_of", runtime.ParamLocationQuery, *params.AsOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStockSplitsRequest generates requests for ListStockSplits
func NewListStockSplitsRequest(server string, params *ListStockSplitsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/splits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date", runtime.ParamLocationQuery, *params.ExecutionDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReverseSplit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse_split", runtime.ParamLocationQuery, *params.ReverseSplit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.gte", runtime.ParamLocationQuery, *params.ExecutionDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.gt", runtime.ParamLocationQuery, *params.ExecutionDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.lte", runtime.ParamLocationQuery, *params.ExecutionDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_date.lt", runtime.ParamLocationQuery, *params.ExecutionDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTickersRequest generates requests for ListTickers
func NewListTickersRequest(server string, params *ListTickersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/tickers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cusip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cusip", runtime.ParamLocationQuery, *params.Cusip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTickerTypesRequest generates requests for ListTickerTypes
func NewListTickerTypesRequest(server string, params *ListTickerTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/tickers/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_class", runtime.ParamLocationQuery, *params.AssetClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTickerRequest generates requests for GetTicker
func NewGetTickerRequest(server string, ticker string, params *GetTickerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ticker", runtime.ParamLocationPath, ticker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/reference/tickers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSnapshotsRequest generates requests for GetSnapshots
func NewGetSnapshotsRequest(server string, params *GetSnapshotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/snapshot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndicesSnapshotRequest generates requests for GetIndicesSnapshot
func NewGetIndicesSnapshotRequest(server string, params *GetIndicesSnapshotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/snapshot/indices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TickerAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.any_of", runtime.ParamLocationQuery, *params.TickerAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gte", runtime.ParamLocationQuery, *params.TickerGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.gt", runtime.ParamLocationQuery, *params.TickerGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lte", runtime.ParamLocationQuery, *params.TickerLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TickerLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker.lt", runtime.ParamLocationQuery, *params.TickerLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsChainRequest generates requests for GetOptionsChain
func NewGetOptionsChainRequest(server string, underlyingAsset string, params *GetOptionsChainParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "underlyingAsset", runtime.ParamLocationPath, underlyingAsset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/snapshot/options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StrikePrice != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price", runtime.ParamLocationQuery, *params.StrikePrice); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date", runtime.ParamLocationQuery, *params.ExpirationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContractType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contract_type", runtime.ParamLocationQuery, *params.ContractType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.gte", runtime.ParamLocationQuery, *params.StrikePriceGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.gt", runtime.ParamLocationQuery, *params.StrikePriceGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.lte", runtime.ParamLocationQuery, *params.StrikePriceLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StrikePriceLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strike_price.lt", runtime.ParamLocationQuery, *params.StrikePriceLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.gte", runtime.ParamLocationQuery, *params.ExpirationDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.gt", runtime.ParamLocationQuery, *params.ExpirationDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.lte", runtime.ParamLocationQuery, *params.ExpirationDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpirationDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expiration_date.lt", runtime.ParamLocationQuery, *params.ExpirationDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionContractRequest generates requests for GetOptionContract
func NewGetOptionContractRequest(server string, underlyingAsset string, optionContract string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "underlyingAsset", runtime.ParamLocationPath, underlyingAsset)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "optionContract", runtime.ParamLocationPath, optionContract)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/snapshot/options/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoTradesRequest generates requests for GetCryptoTrades
func NewGetCryptoTradesRequest(server string, cryptoTicker string, params *GetCryptoTradesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cryptoTicker", runtime.ParamLocationPath, cryptoTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/trades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptionsTradesRequest generates requests for GetOptionsTrades
func NewGetOptionsTradesRequest(server string, optionsTicker string, params *GetOptionsTradesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optionsTicker", runtime.ParamLocationPath, optionsTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/trades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStocksTradesRequest generates requests for GetStocksTrades
func NewGetStocksTradesRequest(server string, stockTicker string, params *GetStocksTradesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stockTicker", runtime.ParamLocationPath, stockTicker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/trades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, *params.Timestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gte", runtime.ParamLocationQuery, *params.TimestampGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.gt", runtime.ParamLocationQuery, *params.TimestampGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lte", runtime.ParamLocationQuery, *params.TimestampLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimestampLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp.lt", runtime.ParamLocationQuery, *params.TimestampLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFinancialsRequest generates requests for ListFinancials
func NewListFinancialsRequest(server string, params *ListFinancialsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vX/reference/financials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cik != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cik", runtime.ParamLocationQuery, *params.Cik); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompanyName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company_name", runtime.ParamLocationQuery, *params.CompanyName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sic", runtime.ParamLocationQuery, *params.Sic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date", runtime.ParamLocationQuery, *params.FilingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodOfReportDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_of_report_date", runtime.ParamLocationQuery, *params.PeriodOfReportDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeframe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe", runtime.ParamLocationQuery, *params.Timeframe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSources != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_sources", runtime.ParamLocationQuery, *params.IncludeSources); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompanyNameSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company_name.search", runtime.ParamLocationQuery, *params.CompanyNameSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gte", runtime.ParamLocationQuery, *params.FilingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.gt", runtime.ParamLocationQuery, *params.FilingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lte", runtime.ParamLocationQuery, *params.FilingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filing_date.lt", runtime.ParamLocationQuery, *params.FilingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodOfReportDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_of_report_date.gte", runtime.ParamLocationQuery, *params.PeriodOfReportDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodOfReportDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_of_report_date.gt", runtime.ParamLocationQuery, *params.PeriodOfReportDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodOfReportDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_of_report_date.lte", runtime.ParamLocationQuery, *params.PeriodOfReportDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodOfReportDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period_of_report_date.lt", runtime.ParamLocationQuery, *params.PeriodOfReportDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIPOsRequest generates requests for ListIPOs
func NewListIPOsRequest(server string, params *ListIPOsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vX/reference/ipos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ticker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ticker", runtime.ParamLocationQuery, *params.Ticker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "us_code", runtime.ParamLocationQuery, *params.UsCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Isin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isin", runtime.ParamLocationQuery, *params.Isin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date", runtime.ParamLocationQuery, *params.ListingDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpoStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipo_status", runtime.ParamLocationQuery, *params.IpoStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.gte", runtime.ParamLocationQuery, *params.ListingDateGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.gt", runtime.ParamLocationQuery, *params.ListingDateGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.lte", runtime.ParamLocationQuery, *params.ListingDateLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingDateLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_date.lt", runtime.ParamLocationQuery, *params.ListingDateLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsRequest generates requests for GetEvents
func NewGetEventsRequest(server string, id string, params *GetEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vX/reference/tickers/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBenzingaV1AnalystInsightsWithResponse request
	GetBenzingaV1AnalystInsightsWithResponse(ctx context.Context, params *GetBenzingaV1AnalystInsightsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1AnalystInsightsResponse, error)

	// GetBenzingaV1AnalystsWithResponse request
	GetBenzingaV1AnalystsWithResponse(ctx context.Context, params *GetBenzingaV1AnalystsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1AnalystsResponse, error)

	// GetBenzingaV1BullsBearsSayWithResponse request
	GetBenzingaV1BullsBearsSayWithResponse(ctx context.Context, params *GetBenzingaV1BullsBearsSayParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1BullsBearsSayResponse, error)

	// GetBenzingaV1ConsensusRatingsWithResponse request
	GetBenzingaV1ConsensusRatingsWithResponse(ctx context.Context, ticker string, params *GetBenzingaV1ConsensusRatingsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1ConsensusRatingsResponse, error)

	// GetBenzingaV1EarningsWithResponse request
	GetBenzingaV1EarningsWithResponse(ctx context.Context, params *GetBenzingaV1EarningsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1EarningsResponse, error)

	// GetBenzingaV1FirmsWithResponse request
	GetBenzingaV1FirmsWithResponse(ctx context.Context, params *GetBenzingaV1FirmsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1FirmsResponse, error)

	// GetBenzingaV1GuidanceWithResponse request
	GetBenzingaV1GuidanceWithResponse(ctx context.Context, params *GetBenzingaV1GuidanceParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1GuidanceResponse, error)

	// GetBenzingaV1RatingsWithResponse request
	GetBenzingaV1RatingsWithResponse(ctx context.Context, params *GetBenzingaV1RatingsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1RatingsResponse, error)

	// GetBenzingaV2NewsWithResponse request
	GetBenzingaV2NewsWithResponse(ctx context.Context, params *GetBenzingaV2NewsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV2NewsResponse, error)

	// GetCryptoV1ExchangesWithResponse request
	GetCryptoV1ExchangesWithResponse(ctx context.Context, params *GetCryptoV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetCryptoV1ExchangesResponse, error)

	// GetEtfGlobalV1AnalyticsWithResponse request
	GetEtfGlobalV1AnalyticsWithResponse(ctx context.Context, params *GetEtfGlobalV1AnalyticsParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1AnalyticsResponse, error)

	// GetEtfGlobalV1ConstituentsWithResponse request
	GetEtfGlobalV1ConstituentsWithResponse(ctx context.Context, params *GetEtfGlobalV1ConstituentsParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1ConstituentsResponse, error)

	// GetEtfGlobalV1FundFlowsWithResponse request
	GetEtfGlobalV1FundFlowsWithResponse(ctx context.Context, params *GetEtfGlobalV1FundFlowsParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1FundFlowsResponse, error)

	// GetEtfGlobalV1ProfilesWithResponse request
	GetEtfGlobalV1ProfilesWithResponse(ctx context.Context, params *GetEtfGlobalV1ProfilesParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1ProfilesResponse, error)

	// GetEtfGlobalV1TaxonomiesWithResponse request
	GetEtfGlobalV1TaxonomiesWithResponse(ctx context.Context, params *GetEtfGlobalV1TaxonomiesParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1TaxonomiesResponse, error)

	// GetFedV1InflationWithResponse request
	GetFedV1InflationWithResponse(ctx context.Context, params *GetFedV1InflationParams, reqEditors ...RequestEditorFn) (*GetFedV1InflationResponse, error)

	// GetFedV1InflationExpectationsWithResponse request
	GetFedV1InflationExpectationsWithResponse(ctx context.Context, params *GetFedV1InflationExpectationsParams, reqEditors ...RequestEditorFn) (*GetFedV1InflationExpectationsResponse, error)

	// GetFedV1LaborMarketWithResponse request
	GetFedV1LaborMarketWithResponse(ctx context.Context, params *GetFedV1LaborMarketParams, reqEditors ...RequestEditorFn) (*GetFedV1LaborMarketResponse, error)

	// GetFedV1TreasuryYieldsWithResponse request
	GetFedV1TreasuryYieldsWithResponse(ctx context.Context, params *GetFedV1TreasuryYieldsParams, reqEditors ...RequestEditorFn) (*GetFedV1TreasuryYieldsResponse, error)

	// GetForexV1ExchangesWithResponse request
	GetForexV1ExchangesWithResponse(ctx context.Context, params *GetForexV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetForexV1ExchangesResponse, error)

	// GetFuturesAggregatesWithResponse request
	GetFuturesAggregatesWithResponse(ctx context.Context, ticker string, params *GetFuturesAggregatesParams, reqEditors ...RequestEditorFn) (*GetFuturesAggregatesResponse, error)

	// GetFuturesVXContractsWithResponse request
	GetFuturesVXContractsWithResponse(ctx context.Context, params *GetFuturesVXContractsParams, reqEditors ...RequestEditorFn) (*GetFuturesVXContractsResponse, error)

	// GetFuturesVXExchangesWithResponse request
	GetFuturesVXExchangesWithResponse(ctx context.Context, params *GetFuturesVXExchangesParams, reqEditors ...RequestEditorFn) (*GetFuturesVXExchangesResponse, error)

	// GetFuturesVXMarketStatusWithResponse request
	GetFuturesVXMarketStatusWithResponse(ctx context.Context, params *GetFuturesVXMarketStatusParams, reqEditors ...RequestEditorFn) (*GetFuturesVXMarketStatusResponse, error)

	// GetFuturesVXProductsWithResponse request
	GetFuturesVXProductsWithResponse(ctx context.Context, params *GetFuturesVXProductsParams, reqEditors ...RequestEditorFn) (*GetFuturesVXProductsResponse, error)

	// GetFuturesVXQuotesNewWithResponse request
	GetFuturesVXQuotesNewWithResponse(ctx context.Context, ticker string, params *GetFuturesVXQuotesNewParams, reqEditors ...RequestEditorFn) (*GetFuturesVXQuotesNewResponse, error)

	// GetFuturesQuotesWithResponse request
	GetFuturesQuotesWithResponse(ctx context.Context, ticker string, params *GetFuturesQuotesParams, reqEditors ...RequestEditorFn) (*GetFuturesQuotesResponse, error)

	// GetFuturesVXSchedulesWithResponse request
	GetFuturesVXSchedulesWithResponse(ctx context.Context, params *GetFuturesVXSchedulesParams, reqEditors ...RequestEditorFn) (*GetFuturesVXSchedulesResponse, error)

	// GetFuturesVXSnapshotWithResponse request
	GetFuturesVXSnapshotWithResponse(ctx context.Context, params *GetFuturesVXSnapshotParams, reqEditors ...RequestEditorFn) (*GetFuturesVXSnapshotResponse, error)

	// GetFuturesVXSnapshotNativeWithResponse request
	GetFuturesVXSnapshotNativeWithResponse(ctx context.Context, params *GetFuturesVXSnapshotNativeParams, reqEditors ...RequestEditorFn) (*GetFuturesVXSnapshotNativeResponse, error)

	// GetFuturesVXTradesNewWithResponse request
	GetFuturesVXTradesNewWithResponse(ctx context.Context, ticker string, params *GetFuturesVXTradesNewParams, reqEditors ...RequestEditorFn) (*GetFuturesVXTradesNewResponse, error)

	// GetFuturesTradesWithResponse request
	GetFuturesTradesWithResponse(ctx context.Context, ticker string, params *GetFuturesTradesParams, reqEditors ...RequestEditorFn) (*GetFuturesTradesResponse, error)

	// GetOptionsV1ExchangesWithResponse request
	GetOptionsV1ExchangesWithResponse(ctx context.Context, params *GetOptionsV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetOptionsV1ExchangesResponse, error)

	// GetStocksFilings10KVXSectionsWithResponse request
	GetStocksFilings10KVXSectionsWithResponse(ctx context.Context, params *GetStocksFilings10KVXSectionsParams, reqEditors ...RequestEditorFn) (*GetStocksFilings10KVXSectionsResponse, error)

	// GetStocksFilingsVXIndexWithResponse request
	GetStocksFilingsVXIndexWithResponse(ctx context.Context, params *GetStocksFilingsVXIndexParams, reqEditors ...RequestEditorFn) (*GetStocksFilingsVXIndexResponse, error)

	// GetStocksFilingsVXRiskFactorsWithResponse request
	GetStocksFilingsVXRiskFactorsWithResponse(ctx context.Context, params *GetStocksFilingsVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*GetStocksFilingsVXRiskFactorsResponse, error)

	// GetStocksFinancialsV1BalanceSheetsWithResponse request
	GetStocksFinancialsV1BalanceSheetsWithResponse(ctx context.Context, params *GetStocksFinancialsV1BalanceSheetsParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1BalanceSheetsResponse, error)

	// GetStocksFinancialsV1CashFlowStatementsWithResponse request
	GetStocksFinancialsV1CashFlowStatementsWithResponse(ctx context.Context, params *GetStocksFinancialsV1CashFlowStatementsParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1CashFlowStatementsResponse, error)

	// GetStocksFinancialsV1IncomeStatementsWithResponse request
	GetStocksFinancialsV1IncomeStatementsWithResponse(ctx context.Context, params *GetStocksFinancialsV1IncomeStatementsParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1IncomeStatementsResponse, error)

	// GetStocksFinancialsV1RatiosWithResponse request
	GetStocksFinancialsV1RatiosWithResponse(ctx context.Context, params *GetStocksFinancialsV1RatiosParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1RatiosResponse, error)

	// GetStocksTaxonomiesVXRiskFactorsWithResponse request
	GetStocksTaxonomiesVXRiskFactorsWithResponse(ctx context.Context, params *GetStocksTaxonomiesVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*GetStocksTaxonomiesVXRiskFactorsResponse, error)

	// GetStocksV1DividendsWithResponse request
	GetStocksV1DividendsWithResponse(ctx context.Context, params *GetStocksV1DividendsParams, reqEditors ...RequestEditorFn) (*GetStocksV1DividendsResponse, error)

	// GetStocksV1ExchangesWithResponse request
	GetStocksV1ExchangesWithResponse(ctx context.Context, params *GetStocksV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetStocksV1ExchangesResponse, error)

	// GetStocksV1ShortInterestWithResponse request
	GetStocksV1ShortInterestWithResponse(ctx context.Context, params *GetStocksV1ShortInterestParams, reqEditors ...RequestEditorFn) (*GetStocksV1ShortInterestResponse, error)

	// GetStocksV1ShortVolumeWithResponse request
	GetStocksV1ShortVolumeWithResponse(ctx context.Context, params *GetStocksV1ShortVolumeParams, reqEditors ...RequestEditorFn) (*GetStocksV1ShortVolumeResponse, error)

	// GetStocksV1SplitsWithResponse request
	GetStocksV1SplitsWithResponse(ctx context.Context, params *GetStocksV1SplitsParams, reqEditors ...RequestEditorFn) (*GetStocksV1SplitsResponse, error)

	// GetStocksVXFloatWithResponse request
	GetStocksVXFloatWithResponse(ctx context.Context, params *GetStocksVXFloatParams, reqEditors ...RequestEditorFn) (*GetStocksVXFloatResponse, error)

	// GetTmxV1CorporateEventsWithResponse request
	GetTmxV1CorporateEventsWithResponse(ctx context.Context, params *GetTmxV1CorporateEventsParams, reqEditors ...RequestEditorFn) (*GetTmxV1CorporateEventsResponse, error)

	// GetCurrencyConversionWithResponse request
	GetCurrencyConversionWithResponse(ctx context.Context, from string, to string, params *GetCurrencyConversionParams, reqEditors ...RequestEditorFn) (*GetCurrencyConversionResponse, error)

	// DeprecatedGetHistoricCryptoTradesWithResponse request
	DeprecatedGetHistoricCryptoTradesWithResponse(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricCryptoTradesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricCryptoTradesResponse, error)

	// DeprecatedGetHistoricForexQuotesWithResponse request
	DeprecatedGetHistoricForexQuotesWithResponse(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricForexQuotesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricForexQuotesResponse, error)

	// GetCryptoEMAWithResponse request
	GetCryptoEMAWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoEMAParams, reqEditors ...RequestEditorFn) (*GetCryptoEMAResponse, error)

	// GetForexEMAWithResponse request
	GetForexEMAWithResponse(ctx context.Context, fxTicker string, params *GetForexEMAParams, reqEditors ...RequestEditorFn) (*GetForexEMAResponse, error)

	// GetIndicesEMAWithResponse request
	GetIndicesEMAWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesEMAParams, reqEditors ...RequestEditorFn) (*GetIndicesEMAResponse, error)

	// GetOptionsEMAWithResponse request
	GetOptionsEMAWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsEMAParams, reqEditors ...RequestEditorFn) (*GetOptionsEMAResponse, error)

	// GetStocksEMAWithResponse request
	GetStocksEMAWithResponse(ctx context.Context, stockTicker string, params *GetStocksEMAParams, reqEditors ...RequestEditorFn) (*GetStocksEMAResponse, error)

	// GetCryptoMACDWithResponse request
	GetCryptoMACDWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoMACDParams, reqEditors ...RequestEditorFn) (*GetCryptoMACDResponse, error)

	// GetForexMACDWithResponse request
	GetForexMACDWithResponse(ctx context.Context, fxTicker string, params *GetForexMACDParams, reqEditors ...RequestEditorFn) (*GetForexMACDResponse, error)

	// GetIndicesMACDWithResponse request
	GetIndicesMACDWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesMACDParams, reqEditors ...RequestEditorFn) (*GetIndicesMACDResponse, error)

	// GetOptionsMACDWithResponse request
	GetOptionsMACDWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsMACDParams, reqEditors ...RequestEditorFn) (*GetOptionsMACDResponse, error)

	// GetStocksMACDWithResponse request
	GetStocksMACDWithResponse(ctx context.Context, stockTicker string, params *GetStocksMACDParams, reqEditors ...RequestEditorFn) (*GetStocksMACDResponse, error)

	// GetCryptoRSIWithResponse request
	GetCryptoRSIWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoRSIParams, reqEditors ...RequestEditorFn) (*GetCryptoRSIResponse, error)

	// GetForexRSIWithResponse request
	GetForexRSIWithResponse(ctx context.Context, fxTicker string, params *GetForexRSIParams, reqEditors ...RequestEditorFn) (*GetForexRSIResponse, error)

	// GetIndicesRSIWithResponse request
	GetIndicesRSIWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesRSIParams, reqEditors ...RequestEditorFn) (*GetIndicesRSIResponse, error)

	// GetOptionsRSIWithResponse request
	GetOptionsRSIWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsRSIParams, reqEditors ...RequestEditorFn) (*GetOptionsRSIResponse, error)

	// GetStocksRSIWithResponse request
	GetStocksRSIWithResponse(ctx context.Context, stockTicker string, params *GetStocksRSIParams, reqEditors ...RequestEditorFn) (*GetStocksRSIResponse, error)

	// GetCryptoSMAWithResponse request
	GetCryptoSMAWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoSMAParams, reqEditors ...RequestEditorFn) (*GetCryptoSMAResponse, error)

	// GetForexSMAWithResponse request
	GetForexSMAWithResponse(ctx context.Context, fxTicker string, params *GetForexSMAParams, reqEditors ...RequestEditorFn) (*GetForexSMAResponse, error)

	// GetIndicesSMAWithResponse request
	GetIndicesSMAWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesSMAParams, reqEditors ...RequestEditorFn) (*GetIndicesSMAResponse, error)

	// GetOptionsSMAWithResponse request
	GetOptionsSMAWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsSMAParams, reqEditors ...RequestEditorFn) (*GetOptionsSMAResponse, error)

	// GetStocksSMAWithResponse request
	GetStocksSMAWithResponse(ctx context.Context, stockTicker string, params *GetStocksSMAParams, reqEditors ...RequestEditorFn) (*GetStocksSMAResponse, error)

	// GetLastCryptoTradeWithResponse request
	GetLastCryptoTradeWithResponse(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*GetLastCryptoTradeResponse, error)

	// GetLastCurrencyQuoteWithResponse request
	GetLastCurrencyQuoteWithResponse(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*GetLastCurrencyQuoteResponse, error)

	// GetMarketStatusWithResponse request
	GetMarketStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketStatusResponse, error)

	// GetMarketHolidaysWithResponse request
	GetMarketHolidaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketHolidaysResponse, error)

	// GetCryptoOpenCloseWithResponse request
	GetCryptoOpenCloseWithResponse(ctx context.Context, from string, to string, date openapi_types.Date, params *GetCryptoOpenCloseParams, reqEditors ...RequestEditorFn) (*GetCryptoOpenCloseResponse, error)

	// GetIndicesOpenCloseWithResponse request
	GetIndicesOpenCloseWithResponse(ctx context.Context, indicesTicker string, date string, reqEditors ...RequestEditorFn) (*GetIndicesOpenCloseResponse, error)

	// GetOptionsOpenCloseWithResponse request
	GetOptionsOpenCloseWithResponse(ctx context.Context, optionsTicker string, date openapi_types.Date, params *GetOptionsOpenCloseParams, reqEditors ...RequestEditorFn) (*GetOptionsOpenCloseResponse, error)

	// GetStocksOpenCloseWithResponse request
	GetStocksOpenCloseWithResponse(ctx context.Context, stocksTicker string, date openapi_types.Date, params *GetStocksOpenCloseParams, reqEditors ...RequestEditorFn) (*GetStocksOpenCloseResponse, error)

	// GetV1ReferenceIposWithResponse request
	GetV1ReferenceIposWithResponse(ctx context.Context, params *GetV1ReferenceIposParams, reqEditors ...RequestEditorFn) (*GetV1ReferenceIposResponse, error)

	// GetRelatedCompaniesWithResponse request
	GetRelatedCompaniesWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*GetRelatedCompaniesResponse, error)

	// GetSnapshotSummaryWithResponse request
	GetSnapshotSummaryWithResponse(ctx context.Context, params *GetSnapshotSummaryParams, reqEditors ...RequestEditorFn) (*GetSnapshotSummaryResponse, error)

	// GetGroupedCryptoAggregatesWithResponse request
	GetGroupedCryptoAggregatesWithResponse(ctx context.Context, date string, params *GetGroupedCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*GetGroupedCryptoAggregatesResponse, error)

	// GetGroupedForexAggregatesWithResponse request
	GetGroupedForexAggregatesWithResponse(ctx context.Context, date string, params *GetGroupedForexAggregatesParams, reqEditors ...RequestEditorFn) (*GetGroupedForexAggregatesResponse, error)

	// GetGroupedStocksAggregatesWithResponse request
	GetGroupedStocksAggregatesWithResponse(ctx context.Context, date string, params *GetGroupedStocksAggregatesParams, reqEditors ...RequestEditorFn) (*GetGroupedStocksAggregatesResponse, error)

	// GetPreviousCryptoAggregatesWithResponse request
	GetPreviousCryptoAggregatesWithResponse(ctx context.Context, cryptoTicker string, params *GetPreviousCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousCryptoAggregatesResponse, error)

	// GetCryptoAggregatesWithResponse request
	GetCryptoAggregatesWithResponse(ctx context.Context, cryptoTicker string, multiplier int, timespan GetCryptoAggregatesParamsTimespan, from string, to string, params *GetCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*GetCryptoAggregatesResponse, error)

	// GetPreviousForexAggregatesWithResponse request
	GetPreviousForexAggregatesWithResponse(ctx context.Context, forexTicker string, params *GetPreviousForexAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousForexAggregatesResponse, error)

	// GetForexAggregatesWithResponse request
	GetForexAggregatesWithResponse(ctx context.Context, forexTicker string, multiplier int, timespan GetForexAggregatesParamsTimespan, from string, to string, params *GetForexAggregatesParams, reqEditors ...RequestEditorFn) (*GetForexAggregatesResponse, error)

	// GetPreviousIndicesAggregatesWithResponse request
	GetPreviousIndicesAggregatesWithResponse(ctx context.Context, indicesTicker string, reqEditors ...RequestEditorFn) (*GetPreviousIndicesAggregatesResponse, error)

	// GetIndicesAggregatesWithResponse request
	GetIndicesAggregatesWithResponse(ctx context.Context, indicesTicker string, multiplier int, timespan GetIndicesAggregatesParamsTimespan, from string, to string, params *GetIndicesAggregatesParams, reqEditors ...RequestEditorFn) (*GetIndicesAggregatesResponse, error)

	// GetPreviousOptionsAggregatesWithResponse request
	GetPreviousOptionsAggregatesWithResponse(ctx context.Context, optionsTicker string, params *GetPreviousOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousOptionsAggregatesResponse, error)

	// GetOptionsAggregatesWithResponse request
	GetOptionsAggregatesWithResponse(ctx context.Context, optionsTicker string, multiplier int, timespan GetOptionsAggregatesParamsTimespan, from string, to string, params *GetOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*GetOptionsAggregatesResponse, error)

	// GetPreviousStocksAggregatesWithResponse request
	GetPreviousStocksAggregatesWithResponse(ctx context.Context, stocksTicker string, params *GetPreviousStocksAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousStocksAggregatesResponse, error)

	// GetStocksAggregatesWithResponse request
	GetStocksAggregatesWithResponse(ctx context.Context, stocksTicker string, multiplier int, timespan GetStocksAggregatesParamsTimespan, from string, to string, params *GetStocksAggregatesParams, reqEditors ...RequestEditorFn) (*GetStocksAggregatesResponse, error)

	// GetLastStocksQuoteWithResponse request
	GetLastStocksQuoteWithResponse(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*GetLastStocksQuoteResponse, error)

	// GetLastOptionsTradeWithResponse request
	GetLastOptionsTradeWithResponse(ctx context.Context, optionsTicker string, reqEditors ...RequestEditorFn) (*GetLastOptionsTradeResponse, error)

	// GetLastStocksTradeWithResponse request
	GetLastStocksTradeWithResponse(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*GetLastStocksTradeResponse, error)

	// ListNewsWithResponse request
	ListNewsWithResponse(ctx context.Context, params *ListNewsParams, reqEditors ...RequestEditorFn) (*ListNewsResponse, error)

	// GetCryptoSnapshotTickersWithResponse request
	GetCryptoSnapshotTickersWithResponse(ctx context.Context, params *GetCryptoSnapshotTickersParams, reqEditors ...RequestEditorFn) (*GetCryptoSnapshotTickersResponse, error)

	// GetCryptoSnapshotTickerWithResponse request
	GetCryptoSnapshotTickerWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*GetCryptoSnapshotTickerResponse, error)

	// DeprecatedGetCryptoSnapshotTickerBookWithResponse request
	DeprecatedGetCryptoSnapshotTickerBookWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*DeprecatedGetCryptoSnapshotTickerBookResponse, error)

	// GetCryptoSnapshotDirectionWithResponse request
	GetCryptoSnapshotDirectionWithResponse(ctx context.Context, direction GetCryptoSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*GetCryptoSnapshotDirectionResponse, error)

	// GetForexSnapshotTickersWithResponse request
	GetForexSnapshotTickersWithResponse(ctx context.Context, params *GetForexSnapshotTickersParams, reqEditors ...RequestEditorFn) (*GetForexSnapshotTickersResponse, error)

	// GetForexSnapshotTickerWithResponse request
	GetForexSnapshotTickerWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*GetForexSnapshotTickerResponse, error)

	// GetForexSnapshotDirectionWithResponse request
	GetForexSnapshotDirectionWithResponse(ctx context.Context, direction GetForexSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*GetForexSnapshotDirectionResponse, error)

	// GetStocksSnapshotTickersWithResponse request
	GetStocksSnapshotTickersWithResponse(ctx context.Context, params *GetStocksSnapshotTickersParams, reqEditors ...RequestEditorFn) (*GetStocksSnapshotTickersResponse, error)

	// GetStocksSnapshotTickerWithResponse request
	GetStocksSnapshotTickerWithResponse(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*GetStocksSnapshotTickerResponse, error)

	// GetStocksSnapshotDirectionWithResponse request
	GetStocksSnapshotDirectionWithResponse(ctx context.Context, direction GetStocksSnapshotDirectionParamsDirection, params *GetStocksSnapshotDirectionParams, reqEditors ...RequestEditorFn) (*GetStocksSnapshotDirectionResponse, error)

	// DeprecatedGetHistoricStocksQuotesWithResponse request
	DeprecatedGetHistoricStocksQuotesWithResponse(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksQuotesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricStocksQuotesResponse, error)

	// DeprecatedGetHistoricStocksTradesWithResponse request
	DeprecatedGetHistoricStocksTradesWithResponse(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksTradesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricStocksTradesResponse, error)

	// GetForexQuotesWithResponse request
	GetForexQuotesWithResponse(ctx context.Context, fxTicker string, params *GetForexQuotesParams, reqEditors ...RequestEditorFn) (*GetForexQuotesResponse, error)

	// GetOptionsQuotesWithResponse request
	GetOptionsQuotesWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsQuotesParams, reqEditors ...RequestEditorFn) (*GetOptionsQuotesResponse, error)

	// GetStocksQuotesWithResponse request
	GetStocksQuotesWithResponse(ctx context.Context, stockTicker string, params *GetStocksQuotesParams, reqEditors ...RequestEditorFn) (*GetStocksQuotesResponse, error)

	// ListConditionsWithResponse request
	ListConditionsWithResponse(ctx context.Context, params *ListConditionsParams, reqEditors ...RequestEditorFn) (*ListConditionsResponse, error)

	// ListDividendsWithResponse request
	ListDividendsWithResponse(ctx context.Context, params *ListDividendsParams, reqEditors ...RequestEditorFn) (*ListDividendsResponse, error)

	// ListExchangesWithResponse request
	ListExchangesWithResponse(ctx context.Context, params *ListExchangesParams, reqEditors ...RequestEditorFn) (*ListExchangesResponse, error)

	// ListOptionsContractsWithResponse request
	ListOptionsContractsWithResponse(ctx context.Context, params *ListOptionsContractsParams, reqEditors ...RequestEditorFn) (*ListOptionsContractsResponse, error)

	// GetOptionsContractWithResponse request
	GetOptionsContractWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsContractParams, reqEditors ...RequestEditorFn) (*GetOptionsContractResponse, error)

	// ListStockSplitsWithResponse request
	ListStockSplitsWithResponse(ctx context.Context, params *ListStockSplitsParams, reqEditors ...RequestEditorFn) (*ListStockSplitsResponse, error)

	// ListTickersWithResponse request
	ListTickersWithResponse(ctx context.Context, params *ListTickersParams, reqEditors ...RequestEditorFn) (*ListTickersResponse, error)

	// ListTickerTypesWithResponse request
	ListTickerTypesWithResponse(ctx context.Context, params *ListTickerTypesParams, reqEditors ...RequestEditorFn) (*ListTickerTypesResponse, error)

	// GetTickerWithResponse request
	GetTickerWithResponse(ctx context.Context, ticker string, params *GetTickerParams, reqEditors ...RequestEditorFn) (*GetTickerResponse, error)

	// GetSnapshotsWithResponse request
	GetSnapshotsWithResponse(ctx context.Context, params *GetSnapshotsParams, reqEditors ...RequestEditorFn) (*GetSnapshotsResponse, error)

	// GetIndicesSnapshotWithResponse request
	GetIndicesSnapshotWithResponse(ctx context.Context, params *GetIndicesSnapshotParams, reqEditors ...RequestEditorFn) (*GetIndicesSnapshotResponse, error)

	// GetOptionsChainWithResponse request
	GetOptionsChainWithResponse(ctx context.Context, underlyingAsset string, params *GetOptionsChainParams, reqEditors ...RequestEditorFn) (*GetOptionsChainResponse, error)

	// GetOptionContractWithResponse request
	GetOptionContractWithResponse(ctx context.Context, underlyingAsset string, optionContract string, reqEditors ...RequestEditorFn) (*GetOptionContractResponse, error)

	// GetCryptoTradesWithResponse request
	GetCryptoTradesWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoTradesParams, reqEditors ...RequestEditorFn) (*GetCryptoTradesResponse, error)

	// GetOptionsTradesWithResponse request
	GetOptionsTradesWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsTradesParams, reqEditors ...RequestEditorFn) (*GetOptionsTradesResponse, error)

	// GetStocksTradesWithResponse request
	GetStocksTradesWithResponse(ctx context.Context, stockTicker string, params *GetStocksTradesParams, reqEditors ...RequestEditorFn) (*GetStocksTradesResponse, error)

	// ListFinancialsWithResponse request
	ListFinancialsWithResponse(ctx context.Context, params *ListFinancialsParams, reqEditors ...RequestEditorFn) (*ListFinancialsResponse, error)

	// ListIPOsWithResponse request
	ListIPOsWithResponse(ctx context.Context, params *ListIPOsParams, reqEditors ...RequestEditorFn) (*ListIPOsResponse, error)

	// GetEventsWithResponse request
	GetEventsWithResponse(ctx context.Context, id string, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error)
}

type GetBenzingaV1AnalystInsightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BenzingaFirmId The identifer used by Benzinga for the firm record.
			BenzingaFirmId *string `json:"benzinga_firm_id,omitempty"`

			// BenzingaId The identifer used by Benzinga for this record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// BenzingaRatingId The identifier used by Benzinga for the rating record.
			BenzingaRatingId *string `json:"benzinga_rating_id,omitempty"`

			// CompanyName The name of the company being rated.
			CompanyName *string `json:"company_name,omitempty"`

			// Date The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
			Date *string `json:"date,omitempty"`

			// Firm The name of the research firm or investment bank issuing the rating.
			Firm *string `json:"firm,omitempty"`

			// Insight Narrative commentary or reasoning provided by the analyst or firm to explain the rating or price target.
			Insight *string `json:"insight,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
			LastUpdated *time.Time `json:"last_updated,omitempty"`

			// PriceTarget The current price target set by the analyst.
			PriceTarget *float64 `json:"price_target,omitempty"`

			// Rating The current rating set by the analyst.
			Rating *string `json:"rating,omitempty"`

			// RatingAction The description of the change in rating from the firm's last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
			RatingAction *string `json:"rating_action,omitempty"`

			// Ticker The stock symbol of the company being rated.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1AnalystInsights200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1AnalystInsights400Status `json:"status"`
	}
}
type GetBenzingaV1AnalystInsights200Status string
type GetBenzingaV1AnalystInsights400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1AnalystInsightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1AnalystInsightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1AnalystsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BenzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank.
			BenzingaFirmId *string `json:"benzinga_firm_id,omitempty"`

			// BenzingaId The identifier used by Benzinga for this record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// FirmName The name of the research firm or investment bank issuing the ratings.
			FirmName *string `json:"firm_name,omitempty"`

			// FullName The full name of the analyst associated with the ratings.
			FullName *string `json:"full_name,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the analyst record was last updated in the system.
			LastUpdated *string `json:"last_updated,omitempty"`

			// OverallAvgReturn The average percent price difference per rating since the date of recommendation.
			OverallAvgReturn *float64 `json:"overall_avg_return,omitempty"`

			// OverallAvgReturnPercentile The analyst's percentile rank based on average return, relative to other analysts.
			OverallAvgReturnPercentile *float64 `json:"overall_avg_return_percentile,omitempty"`

			// OverallSuccessRate The percentage of gain/loss ratings that resulted in a gain overall.
			OverallSuccessRate *float64 `json:"overall_success_rate,omitempty"`

			// SmartScore A weighted average of the total_ratings_percentile, overall_avg_return_percentile, and overall_success_rate.
			SmartScore *float64 `json:"smart_score,omitempty"`

			// TotalRatings The total number of ratings issued by the analyst included in the performance calculation.
			TotalRatings *float64 `json:"total_ratings,omitempty"`

			// TotalRatingsPercentile The analyst's percentile rank based on the total number of ratings issued, relative to other analysts.
			TotalRatingsPercentile *float64 `json:"total_ratings_percentile,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1Analysts200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1Analysts400Status `json:"status"`
	}
}
type GetBenzingaV1Analysts200Status string
type GetBenzingaV1Analysts400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1AnalystsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1AnalystsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1BullsBearsSayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BearCase A concise summary of the bearish investment thesis, highlighting potential risks, challenges, and reasons why the stock could decline in value.
			BearCase *string `json:"bear_case,omitempty"`

			// BenzingaId The unique identifier used by Benzinga for this bull/bear case record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// BullCase A concise summary of the bullish investment thesis, highlighting positive aspects, growth opportunities, and reasons why the stock could appreciate in value.
			BullCase *string `json:"bull_case,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the bull/bear case was last updated in the system.
			LastUpdated *time.Time `json:"last_updated,omitempty"`

			// Ticker The stock ticker symbol for the company associated with the bull and bear case summaries.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1BullsBearsSay200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1BullsBearsSay400Status `json:"status"`
	}
}
type GetBenzingaV1BullsBearsSay200Status string
type GetBenzingaV1BullsBearsSay400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1BullsBearsSayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1BullsBearsSayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1ConsensusRatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BuyRatings The count of 'Buy' ratings from contributing analysts.
			BuyRatings int64 `json:"buy_ratings"`

			// ConsensusPriceTarget The average price target across all analysts, rounded to 2 decimal places.
			ConsensusPriceTarget *float64 `json:"consensus_price_target,omitempty"`

			// ConsensusRating The overall rating category determined by the average consensus weight. Possible values: 'strong_buy', 'buy', 'hold', 'sell', 'strong_sell'.
			ConsensusRating *string `json:"consensus_rating,omitempty"`

			// ConsensusRatingValue The numerical average of all consensus weights, rounded to 2 decimal places. Scale ranges from 1 (Strong Sell) to 5 (Strong Buy).
			ConsensusRatingValue *float64 `json:"consensus_rating_value,omitempty"`

			// HighPriceTarget The highest price target among all contributing analysts.
			HighPriceTarget *float64 `json:"high_price_target,omitempty"`

			// HoldRatings The count of 'Hold' ratings from contributing analysts.
			HoldRatings int64 `json:"hold_ratings"`

			// LowPriceTarget The lowest price target among all contributing analysts.
			LowPriceTarget *float64 `json:"low_price_target,omitempty"`

			// PriceTargetContributors The number of unique analysts contributing price targets.
			PriceTargetContributors int64 `json:"price_target_contributors"`

			// RatingsContributors The number of unique analysts contributing to the overall ratings consensus.
			RatingsContributors int64 `json:"ratings_contributors"`

			// SellRatings The count of 'Sell' ratings from contributing analysts.
			SellRatings int64 `json:"sell_ratings"`

			// StrongBuyRatings The count of 'Strong Buy' ratings from contributing analysts.
			StrongBuyRatings int64 `json:"strong_buy_ratings"`

			// StrongSellRatings The count of 'Strong Sell' ratings from contributing analysts.
			StrongSellRatings int64 `json:"strong_sell_ratings"`

			// Ticker The requested ticker.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1ConsensusRatings200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1ConsensusRatings400Status `json:"status"`
	}
}
type GetBenzingaV1ConsensusRatings200Status string
type GetBenzingaV1ConsensusRatings400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1ConsensusRatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1ConsensusRatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1EarningsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// ActualEps The actual earnings per share (EPS) reported by the company for the given period.
			ActualEps *float64 `json:"actual_eps,omitempty"`

			// ActualRevenue The actual revenue reported by the company for the given fiscal period.
			ActualRevenue *float64 `json:"actual_revenue,omitempty"`

			// BenzingaId The identifer used by Benzinga for this record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// CompanyName The name of the company releasing earnings.
			CompanyName *string `json:"company_name,omitempty"`

			// Currency The ISO 4217 currency code indicating the denomination in which the figures are reported.
			Currency *string `json:"currency,omitempty"`

			// Date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
			Date *string `json:"date,omitempty"`

			// DateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
			DateStatus *string `json:"date_status,omitempty"`

			// EpsMethod The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
			EpsMethod *string `json:"eps_method,omitempty"`

			// EpsSurprise The difference between the actual and estimated EPS.
			EpsSurprise *float64 `json:"eps_surprise,omitempty"`

			// EpsSurprisePercent The percentage difference between the actual and estimated EPS.
			EpsSurprisePercent *float64 `json:"eps_surprise_percent,omitempty"`

			// EstimatedEps The analyst consensus estimate for earnings per share (EPS) for the given period.
			EstimatedEps *float64 `json:"estimated_eps,omitempty"`

			// EstimatedRevenue The analyst consensus estimate for the company's revenue in the given period.
			EstimatedRevenue *float64 `json:"estimated_revenue,omitempty"`

			// FiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
			FiscalPeriod *string `json:"fiscal_period,omitempty"`

			// FiscalYear The fiscal year in which the earnings period falls.
			FiscalYear *int64 `json:"fiscal_year,omitempty"`

			// Importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
			Importance *int64 `json:"importance,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
			LastUpdated *time.Time `json:"last_updated,omitempty"`

			// Notes Additional context, commentary, or clarifying notes related to the earnings event.
			Notes *string `json:"notes,omitempty"`

			// PreviousEps The company's reported earnings per share (EPS) for the previous comparable period.
			PreviousEps *float64 `json:"previous_eps,omitempty"`

			// PreviousRevenue The company's revenue for the previous comparable fiscal period.
			PreviousRevenue *float64 `json:"previous_revenue,omitempty"`

			// RevenueMethod The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), adj (adjusted, non-GAAP figures that exclude certain items like one-time charges or divestitures), and rental (revenue specifically derived from rental operations, typically used by REITs, leasing companies, or businesses with a rental-based model).
			RevenueMethod *string `json:"revenue_method,omitempty"`

			// RevenueSurprise The difference between the actual and estimated revenue.
			RevenueSurprise *float64 `json:"revenue_surprise,omitempty"`

			// RevenueSurprisePercent The percentage difference between the actual and estimated revenue.
			RevenueSurprisePercent *float64 `json:"revenue_surprise_percent,omitempty"`

			// Ticker The stock symbol of the company reporting earnings.
			Ticker *string `json:"ticker,omitempty"`

			// Time The time (formatted as 24-hour HH:MM:SS UTC) when the earnings are scheduled or were reported.
			Time *string `json:"time,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1Earnings200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1Earnings400Status `json:"status"`
	}
}
type GetBenzingaV1Earnings200Status string
type GetBenzingaV1Earnings400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1EarningsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1EarningsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1FirmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BenzingaId The identifer used by Benzinga for this record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// Currency Primary currency used by the financial firm, with some entries having null values.
			Currency *string `json:"currency,omitempty"`

			// LastUpdated Timestamp indicating when the firm's information was last modified or verified in the database.
			LastUpdated *string `json:"last_updated,omitempty"`

			// Name The name of a research firm or investment bank which issues ratings.
			Name *string `json:"name,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1Firms200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1Firms400Status `json:"status"`
	}
}
type GetBenzingaV1Firms200Status string
type GetBenzingaV1Firms400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1FirmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1FirmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1GuidanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BenzingaId A unique identifier assigned by Benzinga to the guidance record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// CompanyName The name of the company issuing guidance.
			CompanyName *string `json:"company_name,omitempty"`

			// Currency The ISO 4217 code representing the currency in which the company issued its guidance figures.
			Currency *string `json:"currency,omitempty"`

			// Date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
			Date *string `json:"date,omitempty"`

			// EpsMethod The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
			EpsMethod *string `json:"eps_method,omitempty"`

			// EstimatedEpsGuidance The midpoint or central earnings per share (EPS) value the company expects for the given fiscal period.
			EstimatedEpsGuidance *float64 `json:"estimated_eps_guidance,omitempty"`

			// EstimatedRevenueGuidance The midpoint or central revenue figure the company expects for the given fiscal period.
			EstimatedRevenueGuidance *float64 `json:"estimated_revenue_guidance,omitempty"`

			// FiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
			FiscalPeriod *string `json:"fiscal_period,omitempty"`

			// FiscalYear The fiscal year corresponding to the period for which the guidance is issued.
			FiscalYear *int64 `json:"fiscal_year,omitempty"`

			// Importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
			Importance *int64 `json:"importance,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
			LastUpdated *string `json:"last_updated,omitempty"`

			// MaxEpsGuidance The highest EPS value the company expects for the fiscal period if a range was provided.
			MaxEpsGuidance *float64 `json:"max_eps_guidance,omitempty"`

			// MaxRevenueGuidance The highest revenue figure the company expects for the fiscal period if a range was provided.
			MaxRevenueGuidance *float64 `json:"max_revenue_guidance,omitempty"`

			// MinEpsGuidance The lowest EPS value the company expects for the fiscal period if a range was provided.
			MinEpsGuidance *float64 `json:"min_eps_guidance,omitempty"`

			// MinRevenueGuidance The lowest revenue figure the company expects for the fiscal period if a range was provided.
			MinRevenueGuidance *float64 `json:"min_revenue_guidance,omitempty"`

			// Notes Additional descriptive text or commentary provided about the guidance record.
			Notes *string `json:"notes,omitempty"`

			// Positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are 'primary' (the emphasized figure) and 'secondary' (a supporting or alternate figure)
			Positioning *string `json:"positioning,omitempty"`

			// PreviousMaxEpsGuidance The highest EPS value issued in a previous guidance record for the same fiscal period.
			PreviousMaxEpsGuidance *float64 `json:"previous_max_eps_guidance,omitempty"`

			// PreviousMaxRevenueGuidance The highest revenue value issued in a previous guidance record for the same fiscal period.
			PreviousMaxRevenueGuidance *float64 `json:"previous_max_revenue_guidance,omitempty"`

			// PreviousMinEpsGuidance The lowest EPS value issued in a previous guidance record for the same fiscal period.
			PreviousMinEpsGuidance *float64 `json:"previous_min_eps_guidance,omitempty"`

			// PreviousMinRevenueGuidance The lowest revenue value issued in a previous guidance record for the same fiscal period.
			PreviousMinRevenueGuidance *float64 `json:"previous_min_revenue_guidance,omitempty"`

			// ReleaseType Indicates whether the guidance was issued as part of a scheduled earnings release ('official') or as an unscheduled update ('preliminary').
			ReleaseType *string `json:"release_type,omitempty"`

			// RevenueMethod The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles) and adj (adjusted, non-GAAP).
			RevenueMethod *string `json:"revenue_method,omitempty"`

			// Ticker The stock symbol of the company issuing guidance.
			Ticker *string `json:"ticker,omitempty"`

			// Time The time of day the guidance was announced, in HH:mm:ss format.
			Time *string `json:"time,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1Guidance200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1Guidance400Status `json:"status"`
	}
}
type GetBenzingaV1Guidance200Status string
type GetBenzingaV1Guidance400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1GuidanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1GuidanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV1RatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AdjustedPriceTarget The current price target adjusted for stock splits and dividends.
			AdjustedPriceTarget *float64 `json:"adjusted_price_target,omitempty"`

			// Analyst The name of the individual analyst who issued the rating.
			Analyst *string `json:"analyst,omitempty"`

			// BenzingaAnalystId The identifer used by Benzinga for this analyst.
			BenzingaAnalystId *string `json:"benzinga_analyst_id,omitempty"`

			// BenzingaCalendarUrl A link to the Benzinga calendar page for this ticker
			BenzingaCalendarUrl *string `json:"benzinga_calendar_url,omitempty"`

			// BenzingaFirmId The identifer used by Benzinga for this firm.
			BenzingaFirmId *string `json:"benzinga_firm_id,omitempty"`

			// BenzingaId The identifer used by Benzinga for this record.
			BenzingaId *string `json:"benzinga_id,omitempty"`

			// BenzingaNewsUrl A link to the Benzinga articles page for this ticker
			BenzingaNewsUrl *string `json:"benzinga_news_url,omitempty"`

			// CompanyName The name of the company being rated.
			CompanyName *string `json:"company_name,omitempty"`

			// Currency The ISO 4217 currency code in which the price target is denominated.
			Currency *string `json:"currency,omitempty"`

			// Date The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
			Date *string `json:"date,omitempty"`

			// Firm The name of the research firm or investment bank issuing the rating.
			Firm *string `json:"firm,omitempty"`

			// Importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest).
			Importance *int64 `json:"importance,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
			LastUpdated *time.Time `json:"last_updated,omitempty"`

			// Notes Additional context or commentary.
			Notes *string `json:"notes,omitempty"`

			// PreviousAdjustedPriceTarget The previous price target adjusted for stock splits and dividends.
			PreviousAdjustedPriceTarget *float64 `json:"previous_adjusted_price_target,omitempty"`

			// PreviousPriceTarget The previous price target set by the analyst.
			PreviousPriceTarget *float64 `json:"previous_price_target,omitempty"`

			// PreviousRating The previous rating set by the analyst.
			PreviousRating *string `json:"previous_rating,omitempty"`

			// PricePercentChange The percentage change in price target if price target and previous price target exists
			PricePercentChange *float64 `json:"price_percent_change,omitempty"`

			// PriceTarget The current price target set by the analyst.
			PriceTarget *float64 `json:"price_target,omitempty"`

			// PriceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
			PriceTargetAction *string `json:"price_target_action,omitempty"`

			// Rating The current rating set by the analyst.
			Rating *string `json:"rating,omitempty"`

			// RatingAction The description of the change in rating from the firm's last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
			RatingAction *string `json:"rating_action,omitempty"`

			// Ticker The stock symbol of the company being rated.
			Ticker *string `json:"ticker,omitempty"`

			// Time The time (formatted as 24-hour HH:MM:SS UTC) when the rating was issued.
			Time *string `json:"time,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV1Ratings200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV1Ratings400Status `json:"status"`
	}
}
type GetBenzingaV1Ratings200Status string
type GetBenzingaV1Ratings400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV1RatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV1RatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenzingaV2NewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Author The name of the journalist or entity that authored the news article.
			Author string `json:"author"`

			// BenzingaId The identifer used by Benzinga for this record.
			BenzingaId int64 `json:"benzinga_id"`

			// Body The full text content of the news article.
			Body *string `json:"body,omitempty"`

			// Channels A list of categories or topics that the article belongs to (e.g., 'News', 'Price Target').
			Channels *[]string `json:"channels,omitempty"`

			// Images A list of images associated with the article.
			Images *[]string `json:"images,omitempty"`

			// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
			LastUpdated time.Time `json:"last_updated"`

			// Published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
			Published time.Time `json:"published"`

			// Tags A list of tags that describe the themes or content of the article.
			Tags *[]string `json:"tags,omitempty"`

			// Teaser A short summary or lead-in to the news article's content.
			Teaser *string `json:"teaser,omitempty"`

			// Tickers A list of stock or crypto tickers mentioned in the article.
			Tickers *[]string `json:"tickers,omitempty"`

			// Title The headline of the news article.
			Title string `json:"title"`

			// Url The direct link to the source of the news article.
			Url string `json:"url"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetBenzingaV2News200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetBenzingaV2News400Status `json:"status"`
	}
}
type GetBenzingaV2News200Status string
type GetBenzingaV2News400Status string

// Status returns HTTPResponse.Status
func (r GetBenzingaV2NewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenzingaV2NewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoV1ExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Id Numeric identifier for the cryptocurrency exchange or trading platform.
			Id string `json:"id"`

			// Name Full official name of the cryptocurrency exchange or digital asset trading platform.
			Name string `json:"name"`

			// Type Type of crypto venue - 'exchange' for cryptocurrency exchanges and digital asset trading platforms.
			Type string `json:"type"`

			// Url Official website URL of the cryptocurrency exchange.
			Url *string `json:"url,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetCryptoV1Exchanges200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetCryptoV1Exchanges400Status `json:"status"`
	}
}
type GetCryptoV1Exchanges200Status string
type GetCryptoV1Exchanges400Status string

// Status returns HTTPResponse.Status
func (r GetCryptoV1ExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoV1ExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEtfGlobalV1AnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
			CompositeTicker *string `json:"composite_ticker,omitempty"`

			// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
			EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

			// ProcessedDate The date showing when ETF Global received and processed the data.
			ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

			// QuantCompositeBehavioral Behavioral analysis score measuring investor psychology and market behavior patterns.
			QuantCompositeBehavioral *float64 `json:"quant_composite_behavioral,omitempty"`

			// QuantCompositeFundamental Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics.
			QuantCompositeFundamental *float64 `json:"quant_composite_fundamental,omitempty"`

			// QuantCompositeGlobal Overall global theme score combining sector and country analysis for macro investment views.
			QuantCompositeGlobal *float64 `json:"quant_composite_global,omitempty"`

			// QuantCompositeQuality Overall quality assessment score combining liquidity, diversification, and issuing firm factors.
			QuantCompositeQuality *float64 `json:"quant_composite_quality,omitempty"`

			// QuantCompositeSentiment Overall market sentiment score combining put/call ratios, short interest, and implied volatility.
			QuantCompositeSentiment *float64 `json:"quant_composite_sentiment,omitempty"`

			// QuantCompositeTechnical Combined technical analysis score aggregating short, intermediate, and long-term technical factors.
			QuantCompositeTechnical *float64 `json:"quant_composite_technical,omitempty"`

			// QuantFundamentalDiv Fundamental analysis score based on dividend yields of the ETF's underlying securities.
			QuantFundamentalDiv *float64 `json:"quant_fundamental_div,omitempty"`

			// QuantFundamentalPb Fundamental analysis score based on price-to-book value ratios of the ETF's holdings.
			QuantFundamentalPb *float64 `json:"quant_fundamental_pb,omitempty"`

			// QuantFundamentalPcf Fundamental analysis score based on price-to-cash-flow ratios of the ETF's underlying assets.
			QuantFundamentalPcf *float64 `json:"quant_fundamental_pcf,omitempty"`

			// QuantFundamentalPe Fundamental analysis score based on price-to-earnings ratios of the ETF's underlying holdings.
			QuantFundamentalPe *float64 `json:"quant_fundamental_pe,omitempty"`

			// QuantGlobalCountry Quantitative score analyzing global country themes and country-specific market factors.
			QuantGlobalCountry *float64 `json:"quant_global_country,omitempty"`

			// QuantGlobalSector Quantitative score analyzing global sector themes and sector-specific performance factors.
			QuantGlobalSector *float64 `json:"quant_global_sector,omitempty"`

			// QuantGrade Letter grade summarizing the ETF's overall quantitative assessment, where A = 71-100, B = 56-70, etc.
			QuantGrade *string `json:"quant_grade,omitempty"`

			// QuantQualityDiversification Quality assessment score evaluating the diversification benefits and risk distribution of the ETF.
			QuantQualityDiversification *float64 `json:"quant_quality_diversification,omitempty"`

			// QuantQualityFirm Quality assessment score evaluating the reputation and capabilities of the ETF's issuing firm.
			QuantQualityFirm *float64 `json:"quant_quality_firm,omitempty"`

			// QuantQualityLiquidity Quality assessment score measuring the liquidity characteristics and trading ease of the ETF.
			QuantQualityLiquidity *float64 `json:"quant_quality_liquidity,omitempty"`

			// QuantSentimentIv Market sentiment score derived from implied volatility levels in options markets.
			QuantSentimentIv *float64 `json:"quant_sentiment_iv,omitempty"`

			// QuantSentimentPc Market sentiment score derived from put/call option ratios and options activity.
			QuantSentimentPc *float64 `json:"quant_sentiment_pc,omitempty"`

			// QuantSentimentSi Market sentiment score based on short interest levels and short selling activity.
			QuantSentimentSi *float64 `json:"quant_sentiment_si,omitempty"`

			// QuantTechnicalIt Intermediate-term technical analysis score evaluating medium-term price trends.
			QuantTechnicalIt *float64 `json:"quant_technical_it,omitempty"`

			// QuantTechnicalLt Long-term technical analysis score assessing extended price trend patterns.
			QuantTechnicalLt *float64 `json:"quant_technical_lt,omitempty"`

			// QuantTechnicalSt Short-term technical analysis score based on recent price movements and trading patterns.
			QuantTechnicalSt *float64 `json:"quant_technical_st,omitempty"`

			// QuantTotalScore ETF Global's comprehensive quantitative analysis score combining all quantitative factors.
			QuantTotalScore *float64 `json:"quant_total_score,omitempty"`

			// RewardScore ETF Global's proprietary Green Diamond score measuring the potential reward and return prospects of the ETF.
			RewardScore *float64 `json:"reward_score,omitempty"`

			// RiskCountry A component score assessing country-specific risks based on the ETF's geographic exposure.
			RiskCountry *float64 `json:"risk_country,omitempty"`

			// RiskDeviation A component score measuring how much the ETF deviates from expected performance.
			RiskDeviation *float64 `json:"risk_deviation,omitempty"`

			// RiskEfficiency A component score assessing the operational efficiency and cost-effectiveness of the ETF.
			RiskEfficiency *float64 `json:"risk_efficiency,omitempty"`

			// RiskLiquidity A component score measuring the liquidity risk and ease of trading the ETF.
			RiskLiquidity *float64 `json:"risk_liquidity,omitempty"`

			// RiskStructure A component score evaluating risks related to the ETF's structural design and mechanics.
			RiskStructure *float64 `json:"risk_structure,omitempty"`

			// RiskTotalScore ETF Global's proprietary Red Diamond overall risk assessment score for the ETF.
			RiskTotalScore *float64 `json:"risk_total_score,omitempty"`

			// RiskVolatility A component score measuring the volatility risk of the ETF's price movements.
			RiskVolatility *float64 `json:"risk_volatility,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Analytics200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Analytics400Status `json:"status"`
	}
}
type GetEtfGlobalV1Analytics200Status string
type GetEtfGlobalV1Analytics400Status string

// Status returns HTTPResponse.Status
func (r GetEtfGlobalV1AnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEtfGlobalV1AnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEtfGlobalV1ConstituentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AssetClass The broad category of asset type, such as Equity, Corporate Bond, Municipal Bond, etc.
			AssetClass *string `json:"asset_class,omitempty"`

			// CompositeTicker The stock ticker symbol of the ETF that holds these constituent securities.
			CompositeTicker *string `json:"composite_ticker,omitempty"`

			// ConstituentName The full company or security name of the constituent holding.
			ConstituentName *string `json:"constituent_name,omitempty"`

			// ConstituentRank The rank of this constituent within the ETF for a given effective_date, ordered by weight (descending), market_value (descending), and constituent_ticker (ascending). A rank of 1 indicates the largest holding.
			ConstituentRank int64 `json:"constituent_rank"`

			// ConstituentTicker The stock ticker symbol of the individual security held within the ETF.
			ConstituentTicker *string `json:"constituent_ticker,omitempty"`

			// CountryOfExchange The country where the exchange that lists this constituent security is located.
			CountryOfExchange *string `json:"country_of_exchange,omitempty"`

			// CurrencyTraded The local currency in which this constituent security is denominated and traded.
			CurrencyTraded *string `json:"currency_traded,omitempty"`

			// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
			EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

			// Exchange The name of the stock exchange where this constituent security is primarily traded.
			Exchange *string `json:"exchange,omitempty"`

			// Figi The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
			Figi *string `json:"figi,omitempty"`

			// Isin The International Securities Identification Number, a global standard for identifying securities.
			Isin *string `json:"isin,omitempty"`

			// MarketValue The total market value of this constituent position held by the ETF.
			MarketValue *float64 `json:"market_value,omitempty"`

			// ProcessedDate The date showing when ETF Global received and processed the data.
			ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

			// SecurityType The specific classification of security type using ETF Global's taxonomy, such as Common Equity, Domestic, Global, etc.
			SecurityType *string `json:"security_type,omitempty"`

			// Sedol The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
			Sedol *string `json:"sedol,omitempty"`

			// SharesHeld The number of shares of this constituent security that the ETF currently owns.
			SharesHeld *float64 `json:"shares_held,omitempty"`

			// UsCode A unique identifier code for the constituent security in US markets.
			UsCode *string `json:"us_code,omitempty"`

			// Weight The percentage weight of this constituent security within the ETF's total portfolio.
			Weight *float64 `json:"weight,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Constituents200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Constituents400Status `json:"status"`
	}
}
type GetEtfGlobalV1Constituents200Status string
type GetEtfGlobalV1Constituents400Status string

// Status returns HTTPResponse.Status
func (r GetEtfGlobalV1ConstituentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEtfGlobalV1ConstituentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEtfGlobalV1FundFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// CompositeTicker The stock ticker symbol used to identify this ETF on exchanges.
			CompositeTicker *string `json:"composite_ticker,omitempty"`

			// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
			EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

			// FundFlow The net daily capital flow into or out of the ETF through the creation and redemption process, where positive values indicate inflows and negative values indicate outflows.
			FundFlow *float64 `json:"fund_flow,omitempty"`

			// Nav The net asset value per share, representing the per-share value of the ETF's underlying holdings.
			Nav *float64 `json:"nav,omitempty"`

			// ProcessedDate The date showing when ETF Global received and processed the data.
			ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

			// SharesOutstanding The total number of ETF shares currently issued and outstanding in the market.
			SharesOutstanding *float64 `json:"shares_outstanding,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1FundFlows200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1FundFlows400Status `json:"status"`
	}
}
type GetEtfGlobalV1FundFlows200Status string
type GetEtfGlobalV1FundFlows400Status string

// Status returns HTTPResponse.Status
func (r GetEtfGlobalV1FundFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEtfGlobalV1FundFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEtfGlobalV1ProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Administrator The administrator of the ETF.
			Administrator *string `json:"administrator,omitempty"`

			// Advisor The investment advisor of the ETF.
			Advisor *string `json:"advisor,omitempty"`

			// AssetClass The primary type of assets held by the ETF, such as equities, bonds, commodities, or other securities.
			AssetClass *string `json:"asset_class,omitempty"`

			// Aum The total assets under management, representing the current market value of all assets held by the ETF.
			Aum *float64 `json:"aum,omitempty"`

			// AvgDailyTradingVolume The average number of shares traded daily over the past month, indicating liquidity and investor interest.
			AvgDailyTradingVolume *float64 `json:"avg_daily_trading_volume,omitempty"`

			// BidAskSpread The average intraday bid-ask spread as a percentage, calculated by dividing the spread by the lowest ask price sampled during the day.
			BidAskSpread *float64 `json:"bid_ask_spread,omitempty"`

			// CallVolume Call options volume.
			CallVolume *float64 `json:"call_volume,omitempty"`

			// Category The broad investment category that describes the ETF's investment focus and strategy.
			Category *string `json:"category,omitempty"`

			// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
			CompositeTicker *string `json:"composite_ticker,omitempty"`

			// CouponExposure Coupon exposure breakdown for fixed income ETFs.
			CouponExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"coupon_exposure,omitempty"`

			// CreationFee The fee for creating new shares of the ETF.
			CreationFee *float64 `json:"creation_fee,omitempty"`

			// CreationUnitSize The size of creation units for the ETF.
			CreationUnitSize *float64 `json:"creation_unit_size,omitempty"`

			// CurrencyExposure Currency exposure breakdown of the ETF.
			CurrencyExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"currency_exposure,omitempty"`

			// Custodian The custodian of the ETF assets.
			Custodian *string `json:"custodian,omitempty"`

			// Description The official name and description of the ETF product.
			Description *string `json:"description,omitempty"`

			// DevelopmentClass The economic development classification of the markets the ETF invests in, such as developed, emerging, or frontier markets.
			DevelopmentClass *string `json:"development_class,omitempty"`

			// DiscountPremium Discount or premium to net asset value.
			DiscountPremium *float64 `json:"discount_premium,omitempty"`

			// DistributionFrequency How frequently the ETF makes distributions.
			DistributionFrequency *string `json:"distribution_frequency,omitempty"`

			// Distributor The distributor of the ETF.
			Distributor *string `json:"distributor,omitempty"`

			// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
			EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

			// FeeWaivers Any fee waivers applied to the ETF.
			FeeWaivers *float64 `json:"fee_waivers,omitempty"`

			// FiscalYearEnd The fiscal year end date for the ETF.
			FiscalYearEnd *string `json:"fiscal_year_end,omitempty"`

			// Focus The specific investment focus or exposure that the ETF provides, such as sector, geography, or investment style.
			Focus *string `json:"focus,omitempty"`

			// FuturesCommissionMerchant The futures commission merchant, if applicable.
			FuturesCommissionMerchant *string `json:"futures_commission_merchant,omitempty"`

			// GeographicExposure Geographic exposure breakdown of the ETF.
			GeographicExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"geographic_exposure,omitempty"`

			// InceptionDate The date when this ETF was first launched and became available for trading.
			InceptionDate *openapi_types.Date `json:"inception_date,omitempty"`

			// IndustryExposure Industry exposure breakdown of the ETF.
			IndustryExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"industry_exposure,omitempty"`

			// IndustryGroupExposure Industry group exposure breakdown of the ETF.
			IndustryGroupExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"industry_group_exposure,omitempty"`

			// Issuer The financial institution or fund company that created and sponsors this ETF.
			Issuer *string `json:"issuer,omitempty"`

			// LeadMarketMaker The lead market maker for the ETF.
			LeadMarketMaker *string `json:"lead_market_maker,omitempty"`

			// LeverageStyle Indicates whether the ETF uses leverage to amplify returns ('leveraged'), or does not use leverage ('unleveraged').
			LeverageStyle string `json:"leverage_style"`

			// LeveredAmount The leverage multiplier applied by the ETF, where positive numbers indicate leveraged exposure and negative numbers indicate inverse exposure.
			LeveredAmount *float64 `json:"levered_amount,omitempty"`

			// ListingExchange The primary exchange where the ETF is listed.
			ListingExchange *string `json:"listing_exchange,omitempty"`

			// ManagementClassification Defines whether an ETF is considered active under SEC rules, with managers making investment decisions, or passive, tracking an index.
			ManagementClassification string `json:"management_classification"`

			// ManagementFee The annual fee charged by the fund manager for managing the ETF's portfolio and operations.
			ManagementFee *float64 `json:"management_fee,omitempty"`

			// MaturityExposure Maturity exposure breakdown for fixed income ETFs.
			MaturityExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"maturity_exposure,omitempty"`

			// NetExpenses Net expenses after waivers.
			NetExpenses *float64 `json:"net_expenses,omitempty"`

			// NumHoldings Number of holdings in the ETF.
			NumHoldings *float64 `json:"num_holdings,omitempty"`

			// OptionsAvailable Availability of options on the ETF.
			OptionsAvailable *int32 `json:"options_available,omitempty"`

			// OptionsVolume Options trading volume for the ETF.
			OptionsVolume *float64 `json:"options_volume,omitempty"`

			// OtherExpenses Other expenses charged by the ETF.
			OtherExpenses *float64 `json:"other_expenses,omitempty"`

			// PortfolioManager The portfolio manager of the ETF.
			PortfolioManager *string `json:"portfolio_manager,omitempty"`

			// PrimaryBenchmark The main index or benchmark that this ETF is designed to track or replicate.
			PrimaryBenchmark *string `json:"primary_benchmark,omitempty"`

			// ProcessedDate The date showing when ETF Global received and processed the data.
			ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

			// ProductType Indicates whether the product is an Exchange-Traded Note ('etn') or an Exchange-Traded Fund ('etf').
			ProductType string `json:"product_type"`

			// PutCallRatio Put/call ratio for options on the ETF.
			PutCallRatio *float64 `json:"put_call_ratio,omitempty"`

			// PutVolume Put options volume.
			PutVolume *float64 `json:"put_volume,omitempty"`

			// Region The geographic region or area of the world where the ETF concentrates its investments.
			Region *string `json:"region,omitempty"`

			// SectorExposure Sector exposure breakdown of the ETF.
			SectorExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"sector_exposure,omitempty"`

			// ShortInterest Short interest in the ETF.
			ShortInterest *float64 `json:"short_interest,omitempty"`

			// Subadvisor The subadvisor of the ETF, if applicable.
			Subadvisor *string `json:"subadvisor,omitempty"`

			// SubindustryExposure Sub-industry exposure breakdown of the ETF.
			SubindustryExposure *[]struct {
				Key   string  `json:"key"`
				Value float64 `json:"value"`
			} `json:"subindustry_exposure,omitempty"`

			// TaxClassification The tax structure of the ETF, determining whether investors receive 1099 or K1 tax forms (RIC, Partnership, or UIT).
			TaxClassification *string `json:"tax_classification,omitempty"`

			// TotalExpenses The total annual expense ratio of the ETF, including all fees and costs passed on to investors.
			TotalExpenses *float64 `json:"total_expenses,omitempty"`

			// TransferAgent The transfer agent for the ETF.
			TransferAgent *string `json:"transfer_agent,omitempty"`

			// Trustee The trustee of the ETF.
			Trustee *string `json:"trustee,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Profiles200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Profiles400Status `json:"status"`
	}
}
type GetEtfGlobalV1Profiles200Status string
type GetEtfGlobalV1Profiles400Status string

// Status returns HTTPResponse.Status
func (r GetEtfGlobalV1ProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEtfGlobalV1ProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEtfGlobalV1TaxonomiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AssetClass The primary type of assets held by the ETF, such as equities, bonds, commodities, or other securities.
			AssetClass *string `json:"asset_class,omitempty"`

			// Category The broad investment category that describes the ETF's investment focus and strategy.
			Category *string `json:"category,omitempty"`

			// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
			CompositeTicker *string `json:"composite_ticker,omitempty"`

			// Country The specific country focus of the ETF, if applicable.
			Country *string `json:"country,omitempty"`

			// CreditQualityRating Credit quality rating for fixed income ETFs.
			CreditQualityRating *string `json:"credit_quality_rating,omitempty"`

			// Description The official name and description of the ETF product.
			Description *string `json:"description,omitempty"`

			// DevelopmentClass The economic development classification of the markets the ETF invests in, such as developed, emerging, or frontier markets.
			DevelopmentClass *string `json:"development_class,omitempty"`

			// Duration The duration characteristics for fixed income ETFs.
			Duration *string `json:"duration,omitempty"`

			// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
			EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

			// Esg Environmental, Social, and Governance characteristics.
			Esg *string `json:"esg,omitempty"`

			// ExposureMechanism The mechanism used to achieve exposure.
			ExposureMechanism *string `json:"exposure_mechanism,omitempty"`

			// Factor Factor exposure characteristics of the ETF.
			Factor *string `json:"factor,omitempty"`

			// Focus The specific investment focus or exposure that the ETF provides, such as sector, geography, or investment style.
			Focus *string `json:"focus,omitempty"`

			// HedgeReset The frequency of hedge reset, if applicable.
			HedgeReset *string `json:"hedge_reset,omitempty"`

			// HoldingsDisclosureFrequency How frequently holdings are disclosed.
			HoldingsDisclosureFrequency *string `json:"holdings_disclosure_frequency,omitempty"`

			// InceptionDate The date when this ETF was first launched and became available for trading.
			InceptionDate *openapi_types.Date `json:"inception_date,omitempty"`

			// Isin The International Securities Identification Number, a global standard code for uniquely identifying this ETF worldwide.
			Isin *string `json:"isin,omitempty"`

			// Issuer The financial institution or fund company that created and sponsors this ETF.
			Issuer *string `json:"issuer,omitempty"`

			// LeverageReset The frequency of leverage reset, if applicable.
			LeverageReset *string `json:"leverage_reset,omitempty"`

			// LeverageStyle Indicates whether the ETF uses leverage to amplify returns ('leveraged'), or does not use leverage ('unleveraged').
			LeverageStyle string `json:"leverage_style"`

			// LeveredAmount The leverage multiplier applied by the ETF, where positive numbers indicate leveraged exposure and negative numbers indicate inverse exposure.
			LeveredAmount *float64 `json:"levered_amount,omitempty"`

			// ManagementClassification Defines whether an ETF is considered active under SEC rules, with managers making investment decisions, or passive, tracking an index.
			ManagementClassification string `json:"management_classification"`

			// ManagementStyle Indicates whether an ETF is managed actively or passively, and the level of transparency or replication method used.
			ManagementStyle *string `json:"management_style,omitempty"`

			// Maturity The maturity profile for fixed income ETFs.
			Maturity *string `json:"maturity,omitempty"`

			// Objective The primary investment objective of the ETF.
			Objective *string `json:"objective,omitempty"`

			// PrimaryBenchmark The main index or benchmark that this ETF is designed to track or replicate.
			PrimaryBenchmark *string `json:"primary_benchmark,omitempty"`

			// ProcessedDate The date showing when ETF Global received and processed the data.
			ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

			// ProductType Indicates whether the product is an Exchange-Traded Note ('etn') or an Exchange-Traded Fund ('etf').
			ProductType string `json:"product_type"`

			// RebalanceFrequency How frequently the ETF rebalances its holdings.
			RebalanceFrequency *string `json:"rebalance_frequency,omitempty"`

			// ReconstitutionFrequency How frequently the index is reconstituted.
			ReconstitutionFrequency *string `json:"reconstitution_frequency,omitempty"`

			// Region The geographic region or area of the world where the ETF concentrates its investments.
			Region *string `json:"region,omitempty"`

			// SecondaryObjective The secondary investment objective, if applicable.
			SecondaryObjective *string `json:"secondary_objective,omitempty"`

			// SelectionMethodology The methodology used to select securities.
			SelectionMethodology *string `json:"selection_methodology,omitempty"`

			// SelectionUniverse The universe from which securities are selected.
			SelectionUniverse *string `json:"selection_universe,omitempty"`

			// StrategicFocus The strategic investment focus of the ETF.
			StrategicFocus *string `json:"strategic_focus,omitempty"`

			// TargetedFocus The targeted investment focus of the ETF.
			TargetedFocus *string `json:"targeted_focus,omitempty"`

			// TaxClassification The tax structure of the ETF, determining whether investors receive 1099 or K1 tax forms (RIC, Partnership, or UIT).
			TaxClassification *string `json:"tax_classification,omitempty"`

			// UsCode A unique identifier code that identifies this ETF in US markets.
			UsCode *string `json:"us_code,omitempty"`

			// WeightingMethodology The methodology used to weight holdings.
			WeightingMethodology *string `json:"weighting_methodology,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Taxonomies200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetEtfGlobalV1Taxonomies400Status `json:"status"`
	}
}
type GetEtfGlobalV1Taxonomies200Status string
type GetEtfGlobalV1Taxonomies400Status string

// Status returns HTTPResponse.Status
func (r GetEtfGlobalV1TaxonomiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEtfGlobalV1TaxonomiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFedV1InflationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Cpi Consumer Price Index (CPI) for All Urban Consumers  a standard measure of headline inflation based on a fixed basket of goods and services, not seasonally adjusted.
			Cpi *float32 `json:"cpi,omitempty"`

			// CpiCore Core Consumer Price Index  the CPI excluding food and energy, used to understand underlying inflation trends without short-term volatility.
			CpiCore *float32 `json:"cpi_core,omitempty"`

			// CpiYearOverYear Year-over-year percentage change in the headline CPI  the most commonly cited inflation rate in public discourse and economic policy.
			CpiYearOverYear *float32 `json:"cpi_year_over_year,omitempty"`

			// Date Calendar date of the observation (YYYYMMDD).
			Date *string `json:"date,omitempty"`

			// Pce Personal Consumption Expenditures (PCE) Price Index  a broader measure of inflation used by the Federal Reserve, reflecting actual consumer spending patterns and updated basket weights.
			Pce *float32 `json:"pce,omitempty"`

			// PceCore Core PCE Price Index  excludes food and energy prices from the PCE index, and is the Fed's preferred measure of underlying inflation.
			PceCore *float32 `json:"pce_core,omitempty"`

			// PceSpending Nominal Personal Consumption Expenditures  total dollar value of consumer spending in the U.AskSize. economy, reported in billions of dollars and not adjusted for inflation.
			PceSpending *float32 `json:"pce_spending,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFedV1Inflation200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFedV1Inflation400Status `json:"status"`
	}
}
type GetFedV1Inflation200Status string
type GetFedV1Inflation400Status string

// Status returns HTTPResponse.Status
func (r GetFedV1InflationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFedV1InflationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFedV1InflationExpectationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Date Calendar date of the observation (YYYYMMDD).
			Date *string `json:"date,omitempty"`

			// ForwardYears5To10 5-Year, 5-Year Forward Inflation Expectation Rate  the market's expectation of average annual inflation for the 5-year period beginning 5 years from now, based on the spread between forward nominal and real yields.
			ForwardYears5To10 *float32 `json:"forward_years_5_to_10,omitempty"`

			// Market10Year 10-Year Breakeven Inflation Rate  the market's expectation of average annual inflation over the next 10 years, based on the spread between 10-year nominal Treasury yields and 10-year TIPS yields.
			Market10Year *float32 `json:"market_10_year,omitempty"`

			// Market5Year 5-Year Breakeven Inflation Rate  the market's expectation of average annual inflation over the next 5 years, based on the spread between 5-year nominal Treasury yields and 5-year TIPS yields.
			Market5Year *float32 `json:"market_5_year,omitempty"`

			// Model10Year The Cleveland Feds 10-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
			Model10Year *float32 `json:"model_10_year,omitempty"`

			// Model1Year The Cleveland Feds 1-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
			Model1Year *float32 `json:"model_1_year,omitempty"`

			// Model30Year The Cleveland Feds 30-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
			Model30Year *float32 `json:"model_30_year,omitempty"`

			// Model5Year The Cleveland Feds 5-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
			Model5Year *float32 `json:"model_5_year,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFedV1InflationExpectations200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFedV1InflationExpectations400Status `json:"status"`
	}
}
type GetFedV1InflationExpectations200Status string
type GetFedV1InflationExpectations400Status string

// Status returns HTTPResponse.Status
func (r GetFedV1InflationExpectationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFedV1InflationExpectationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFedV1LaborMarketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AvgHourlyEarnings Average hourly earnings of all employees on private nonfarm payrolls in USD (CES0500000003 series from FRED).
			AvgHourlyEarnings *float32 `json:"avg_hourly_earnings,omitempty"`

			// Date Calendar date of the observation (YYYY-MM-DD).
			Date *string `json:"date,omitempty"`

			// JobOpenings Total nonfarm job openings in thousands (JTSJOL series from FRED).
			JobOpenings *float32 `json:"job_openings,omitempty"`

			// LaborForceParticipationRate Civilian labor force participation rate as a percentage of the civilian noninstitutional population (CIVPART series from FRED).
			LaborForceParticipationRate *float32 `json:"labor_force_participation_rate,omitempty"`

			// UnemploymentRate Civilian unemployment rate as a percentage of the labor force (UNRATE series from FRED).
			UnemploymentRate *float32 `json:"unemployment_rate,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFedV1LaborMarket200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFedV1LaborMarket400Status `json:"status"`
	}
}
type GetFedV1LaborMarket200Status string
type GetFedV1LaborMarket400Status string

// Status returns HTTPResponse.Status
func (r GetFedV1LaborMarketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFedV1LaborMarketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFedV1TreasuryYieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Date Calendar date of the yield observation (YYYY-MM-DD).
			Date *string `json:"date,omitempty"`

			// Yield10Year Market Yield on U.AskSize. Treasury Securities at 10-Year Constant Maturity, Quoted on an Investment Basis
			Yield10Year *float32 `json:"yield_10_year,omitempty"`

			// Yield1Month Market Yield on U.AskSize. Treasury Securities at 1-Month Constant Maturity, Quoted on an Investment Basis
			Yield1Month *float32 `json:"yield_1_month,omitempty"`

			// Yield1Year Market Yield on U.AskSize. Treasury Securities at 1-Year Constant Maturity, Quoted on an Investment Basis
			Yield1Year *float32 `json:"yield_1_year,omitempty"`

			// Yield20Year Market Yield on U.AskSize. Treasury Securities at 20-Year Constant Maturity, Quoted on an Investment Basis
			Yield20Year *float32 `json:"yield_20_year,omitempty"`

			// Yield2Year Market Yield on U.AskSize. Treasury Securities at 2-Year Constant Maturity, Quoted on an Investment Basis
			Yield2Year *float32 `json:"yield_2_year,omitempty"`

			// Yield30Year Market Yield on U.AskSize. Treasury Securities at 30-Year Constant Maturity, Quoted on an Investment Basis
			Yield30Year *float32 `json:"yield_30_year,omitempty"`

			// Yield3Month Market Yield on U.AskSize. Treasury Securities at 3-Month Constant Maturity, Quoted on an Investment Basis
			Yield3Month *float32 `json:"yield_3_month,omitempty"`

			// Yield3Year Market Yield on U.AskSize. Treasury Securities at 3-Year Constant Maturity, Quoted on an Investment Basis
			Yield3Year *float32 `json:"yield_3_year,omitempty"`

			// Yield5Year Market Yield on U.AskSize. Treasury Securities at 5-Year Constant Maturity, Quoted on an Investment Basis
			Yield5Year *float32 `json:"yield_5_year,omitempty"`

			// Yield6Month Market Yield on U.AskSize. Treasury Securities at 6-Month Constant Maturity, Quoted on an Investment Basis
			Yield6Month *float32 `json:"yield_6_month,omitempty"`

			// Yield7Year Market Yield on U.AskSize. Treasury Securities at 7-Year Constant Maturity, Quoted on an Investment Basis
			Yield7Year *float32 `json:"yield_7_year,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFedV1TreasuryYields200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFedV1TreasuryYields400Status `json:"status"`
	}
}
type GetFedV1TreasuryYields200Status string
type GetFedV1TreasuryYields400Status string

// Status returns HTTPResponse.Status
func (r GetFedV1TreasuryYieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFedV1TreasuryYieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexV1ExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Id Numeric identifier for the forex trading venue or institution.
			Id string `json:"id"`

			// Name Full name of the foreign exchange trading venue, platform, or financial institution.
			Name string `json:"name"`

			// Type Type of forex venue - 'exchange' for electronic trading platforms and institutional trading venues.
			Type string `json:"type"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetForexV1Exchanges200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetForexV1Exchanges400Status `json:"status"`
	}
}
type GetForexV1Exchanges200Status string
type GetForexV1Exchanges400Status string

// Status returns HTTPResponse.Status
func (r GetForexV1ExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexV1ExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, the URL to the next page of results.
		NextUrl *string `json:"next_url,omitempty"`
		Results []struct {
			// Close The last price within the timeframe.
			Close float64 `json:"close"`

			// DollarVolume The total dollar volume of the transactions that occurred within the timeframe.
			DollarVolume float64 `json:"dollar_volume"`

			// High The highest price within the timeframe.
			High float64 `json:"high"`

			// Low The lowest price within the timeframe.
			Low float64 `json:"low"`

			// Open The opening price within the timeframe.
			Open float64 `json:"open"`

			// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
			SessionEndDate string `json:"session_end_date"`

			// SettlementPrice The price the contract would have cost to settle for this session.
			SettlementPrice *float64 `json:"settlement_price,omitempty"`

			// Ticker The ticker for the contract.
			Ticker string `json:"ticker"`

			// Transactions The number of transactions that occurred within the timeframe.
			Transactions int64 `json:"transactions"`

			// Volume The number of contracts that traded within the timeframe.
			Volume int64 `json:"volume"`

			// WindowStart The timestamp of the beginning of the candlesticks aggregation window.
			WindowStart int64 `json:"window_start"`
		} `json:"results"`

		// Status The status of the response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFuturesAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXContractsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Active Whether or not a given contract was tradeable at the given point in time. Active is true when (first_trade_date <= date >= last_trade_date) and false otherwise.
			Active bool `json:"active"`

			// Date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about contracts for the specified day.
			Date openapi_types.Date `json:"date"`

			// DaysToMaturity The number of calendar days between the 'date' and the contract's final settlement date.
			DaysToMaturity *int64 `json:"days_to_maturity,omitempty"`

			// FirstTradeDate The first day on which the contract was tradeable.
			FirstTradeDate *openapi_types.Date `json:"first_trade_date,omitempty"`

			// GroupCode An identifier used to identify logical groups of products. The group_code is only populated for contracts listed for trading on CME Globex.
			GroupCode *string `json:"group_code,omitempty"`

			// LastTradeDate The last day on which the contract was tradeable.
			LastTradeDate *openapi_types.Date `json:"last_trade_date,omitempty"`

			// MaxOrderQuantity The maximum order quantity.
			MaxOrderQuantity *int64 `json:"max_order_quantity,omitempty"`

			// MinOrderQuantity The minimum order quantity.
			MinOrderQuantity *int64 `json:"min_order_quantity,omitempty"`

			// Name The name of this contract.
			Name *string `json:"name,omitempty"`

			// ProductCode The identifier for the contract's product.
			ProductCode *string `json:"product_code,omitempty"`

			// SettlementDate The date on which this contract settles.
			SettlementDate *openapi_types.Date `json:"settlement_date,omitempty"`

			// SettlementTickSize The tick size for settlement.
			SettlementTickSize *float64 `json:"settlement_tick_size,omitempty"`

			// SpreadTickSize The tick size for spreads.
			SpreadTickSize *float64 `json:"spread_tick_size,omitempty"`

			// Ticker The ticker for the contract.
			Ticker *string `json:"ticker,omitempty"`

			// TradeTickSize The tick size for trades.
			TradeTickSize *float64 `json:"trade_tick_size,omitempty"`

			// TradingVenue The trading venue (MIC) for the exchange on which this contract trades.
			TradingVenue *string `json:"trading_venue,omitempty"`

			// Type The type of contract, one of 'single' or 'combo'. Leaving this filter blank will query for both 'single' and 'combo' types.
			Type *string `json:"type,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXContracts200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXContracts400Status `json:"status"`
	}
}
type GetFuturesVXContracts200Status string
type GetFuturesVXContracts400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXContractsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXContractsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Acronym Well-known acronym for the exchange (e.g., 'CME', 'NYMEX', 'CBOT', 'COMEX').
			Acronym *string `json:"acronym,omitempty"`

			// Id Numeric identifier for the futures exchange or trading venue.
			Id string `json:"id"`

			// Locale Geographic location code where the exchange operates.
			Locale *string `json:"locale,omitempty"`

			// Mic Market Identifier Code (MIC) - ISO 10383 standard four-character code for the futures market.
			Mic *string `json:"mic,omitempty"`

			// Name Full official name of the futures exchange (e.g., 'Chicago Mercantile Exchange', 'New York Mercantile Exchange').
			Name string `json:"name"`

			// OperatingMic Operating Market Identifier Code for the futures exchange.
			OperatingMic *string `json:"operating_mic,omitempty"`

			// Type Type of venue - 'exchange' for futures exchanges and derivatives trading platforms.
			Type string `json:"type"`

			// Url Official website URL of the futures exchange organization.
			Url *string `json:"url,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXExchanges200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXExchanges400Status `json:"status"`
	}
}
type GetFuturesVXExchanges200Status string
type GetFuturesVXExchanges400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXMarketStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// MarketEvent The current status of the market for the product.
			MarketEvent *string `json:"market_event,omitempty"`

			// Name The name of the futures product.
			Name *string `json:"name,omitempty"`

			// ProductCode The product code of the futures contracts for which you want statuses.
			ProductCode *string `json:"product_code,omitempty"`

			// SessionEndDate The trading date for the current session.
			SessionEndDate *string `json:"session_end_date,omitempty"`

			// Timestamp The timestamp for the given market event.
			Timestamp *string `json:"timestamp,omitempty"`

			// TradingVenue The trading venue (MIC) for the exchange on which the corresponding product trades.
			TradingVenue *string `json:"trading_venue,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXMarketStatus200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXMarketStatus400Status `json:"status"`
	}
}
type GetFuturesVXMarketStatus200Status string
type GetFuturesVXMarketStatus400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXMarketStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXMarketStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AssetClass The asset class to which the product belongs.
			AssetClass *string `json:"asset_class,omitempty"`

			// AssetSubClass The asset sub-class to which the product belongs.
			AssetSubClass *string `json:"asset_sub_class,omitempty"`

			// Date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day.
			Date openapi_types.Date `json:"date"`

			// LastUpdated The date and time at which this product was last updated.
			LastUpdated *time.Time `json:"last_updated,omitempty"`

			// Name The full name of the product.
			Name *string `json:"name,omitempty"`

			// PriceQuotation The quoted price for this product.
			PriceQuotation *string `json:"price_quotation,omitempty"`

			// ProductCode The identifier for the product.
			ProductCode *string `json:"product_code,omitempty"`

			// Sector The sector to which the product belongs.
			Sector *string `json:"sector,omitempty"`

			// SettlementCurrencyCode The currency in which this product settles.
			SettlementCurrencyCode *string `json:"settlement_currency_code,omitempty"`

			// SettlementMethod The method of settlement for this product (Financially Settled or Deliverable).
			SettlementMethod *string `json:"settlement_method,omitempty"`

			// SettlementType The type of settlement for this product.
			SettlementType *string `json:"settlement_type,omitempty"`

			// SubSector The sub-sector to which the product belongs.
			SubSector *string `json:"sub_sector,omitempty"`

			// TradeCurrencyCode The currency in which this product's contracts trade.
			TradeCurrencyCode *string `json:"trade_currency_code,omitempty"`

			// TradingVenue The trading venue (MIC) for the exchange on which this product's contracts trade.
			TradingVenue *string `json:"trading_venue,omitempty"`

			// Type The type of product, one of 'single' or 'combo'. Leaving this filter blank will query for both 'single' and 'combo' types.
			Type *string `json:"type,omitempty"`

			// UnitOfMeasure The unit of measure for this product.
			UnitOfMeasure *string `json:"unit_of_measure,omitempty"`

			// UnitOfMeasureQty The quantity of the unit of measure for this product.
			UnitOfMeasureQty *float64 `json:"unit_of_measure_qty,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXProducts200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXProducts400Status `json:"status"`
	}
}
type GetFuturesVXProducts200Status string
type GetFuturesVXProducts400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXQuotesNewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AskPrice The ask price.
			AskPrice *float64 `json:"ask_price,omitempty"`

			// AskSize The ask size.
			AskSize *int32 `json:"ask_size,omitempty"`

			// AskTimestamp The nanosecond accuracy Unix Timestamp when the ask price was submitted to the exchange.
			AskTimestamp *int64 `json:"ask_timestamp,omitempty"`

			// BidPrice The bid price.
			BidPrice *float64 `json:"bid_price,omitempty"`

			// BidSize The bid size.
			BidSize *int32 `json:"bid_size,omitempty"`

			// BidTimestamp The nanosecond accuracy Unix Timestamp when the bid price was submitted to the exchange.
			BidTimestamp *int64 `json:"bid_timestamp,omitempty"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange *int32 `json:"exchange,omitempty"`

			// ReportSequence The report sequence number.
			ReportSequence int64 `json:"report_sequence"`

			// SequenceNumber The sequence number represents the order in which quote events occurred for this ticker.
			SequenceNumber int64 `json:"sequence_number"`

			// SessionEndDate The trade date representing the session end date for this quote. Used for partitioning and filtering quotes by trading session.
			SessionEndDate string `json:"session_end_date"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// Timestamp The nanosecond accuracy Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			Timestamp int64 `json:"timestamp"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXQuotesNew200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXQuotesNew400Status `json:"status"`
	}
}
type GetFuturesVXQuotesNew200Status string
type GetFuturesVXQuotesNew400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXQuotesNewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXQuotesNewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`
		Results *[]struct {
			// AskPrice The ask price is expressed per unit of the underlying asset, and you apply the contract multiplier to get the full contract value.
			AskPrice *float64 `json:"ask_price,omitempty"`

			// AskSize The quote size represents the number of futures contracts available at the given ask price.
			AskSize *float64 `json:"ask_size,omitempty"`

			// AskTimestamp The time when the ask price was submitted to the exchange.
			AskTimestamp *int `json:"ask_timestamp,omitempty"`

			// BidPrice The bid price is expressed per unit of the underlying asset, and you apply the contract multiplier to get the full contract value.
			BidPrice *float64 `json:"bid_price,omitempty"`

			// BidSize The quote size represents the number of futures contracts available at the given bid price.
			BidSize *float64 `json:"bid_size,omitempty"`

			// BidTimestamp The time when the bid price was submitted to the exchange.
			BidTimestamp *int `json:"bid_timestamp,omitempty"`

			// ReportSequence The reporting sequence number.
			ReportSequence int `json:"report_sequence"`

			// SequenceNumber The unique sequence number assigned to this quote by the exchange.
			SequenceNumber int `json:"sequence_number"`

			// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
			SessionEndDate string `json:"session_end_date"`

			// Ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
			Ticker string `json:"ticker"`

			// Timestamp The time when the quote was generated at the exchange to nanosecond precision.
			Timestamp int `json:"timestamp"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFuturesQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Event The type of session on the given trading date.
			Event *string `json:"event,omitempty"`

			// ProductCode The product code of the futures contract.
			ProductCode *string `json:"product_code,omitempty"`

			// ProductName The name of the futures product to which this schedule applies.
			ProductName *string `json:"product_name,omitempty"`

			// SessionEndDate The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to 'today' in Central Time. e.g. If a request is made from Pacific Time on '2025-01-01' at 11:00 pm with no 'session_end_date' a default value of `2025-01-02` will be used.
			SessionEndDate *string `json:"session_end_date,omitempty"`

			// Timestamp The timestamp for the given market event.
			Timestamp *string `json:"timestamp,omitempty"`

			// TradingVenue The trading venue (MIC) for the exchange on which this schedule's product trades.
			TradingVenue *string `json:"trading_venue,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXSchedules200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXSchedules400Status `json:"status"`
	}
}
type GetFuturesVXSchedules200Status string
type GetFuturesVXSchedules400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			Details *struct {
				ProductCode *string `json:"product_code,omitempty"`

				// SettlementDate The day that this contract is settled.
				SettlementDate *openapi_types.Date `json:"settlement_date,omitempty"`
				Ticker         *string             `json:"ticker,omitempty"`
			} `json:"details,omitempty"`
			LastMinute *struct {
				// Close The price at the end of the minute bar.
				Close *float64 `json:"close,omitempty"`

				// High The highest price reached in the minute bar.
				High *float64 `json:"high,omitempty"`

				// LastUpdated The timestamp indicating the most recent update to the minute bar.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Low The lowest price reached in the minute bar.
				Low *float64 `json:"low,omitempty"`

				// Open The opening price at the start of the minute bar.
				Open      *float64 `json:"open,omitempty"`
				Timeframe *string  `json:"timeframe,omitempty"`

				// Volume The number of contracts traded in the minute bar.
				Volume *float64 `json:"volume,omitempty"`
			} `json:"last_minute,omitempty"`
			LastQuote *struct {
				// Ask The lowest price a seller is willing to accept.
				Ask *float64 `json:"ask,omitempty"`

				// AskSize The number of contracts available at the ask price.
				AskSize *int32 `json:"ask_size,omitempty"`

				// AskTimestamp The time when the best ask price was last updated.
				AskTimestamp *int64 `json:"ask_timestamp,omitempty"`

				// Bid The highest price a buyer is willing to pay.
				Bid *float64 `json:"bid,omitempty"`

				// BidSize The number of contracts available at the bid price.
				BidSize *int32 `json:"bid_size,omitempty"`

				// BidTimestamp The time when the best bid price was last updated.
				BidTimestamp *int64 `json:"bid_timestamp,omitempty"`

				// LastUpdated The time when the quote was generated at the exchange to nanosecond precision.
				LastUpdated *int64  `json:"last_updated,omitempty"`
				Timeframe   *string `json:"timeframe,omitempty"`
			} `json:"last_quote,omitempty"`
			LastTrade *struct {
				// LastUpdated The time when the trade was generated at the exchange to nanosecond precision.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
				Price *float64 `json:"price,omitempty"`

				// Size The total number of contracts exchanged between buyers and sellers on a given trade.
				Size      *int64  `json:"size,omitempty"`
				Timeframe *string `json:"timeframe,omitempty"`
			} `json:"last_trade,omitempty"`
			Session *struct {
				// Change The change in price during this session.
				Change *float64 `json:"change,omitempty"`

				// ChangePercent The percentage change in price during this session.
				ChangePercent *float64 `json:"change_percent,omitempty"`

				// Close The price at the end of the session.
				Close *float64 `json:"close,omitempty"`

				// High The highest price reached in the session.
				High *float64 `json:"high,omitempty"`

				// Low The lowest price reached in the session.
				Low *float64 `json:"low,omitempty"`

				// Open The opening price at the start of the session.
				Open *float64 `json:"open,omitempty"`

				// PreviousSettlement The settlement price of the previous session.
				PreviousSettlement *float64 `json:"previous_settlement,omitempty"`

				// SettlementPrice The final settlement price at the end of the session.
				SettlementPrice *float64 `json:"settlement_price,omitempty"`

				// Volume The number of contracts traded in the session.
				Volume *float64 `json:"volume,omitempty"`
			} `json:"session,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXSnapshot200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXSnapshot400Status `json:"status"`
	}
}
type GetFuturesVXSnapshot200Status string
type GetFuturesVXSnapshot400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXSnapshotNativeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			Details *struct {
				ProductCode *string `json:"product_code,omitempty"`

				// SettlementDate The day that this contract is settled.
				SettlementDate *openapi_types.Date `json:"settlement_date,omitempty"`
				Ticker         *string             `json:"ticker,omitempty"`
			} `json:"details,omitempty"`
			LastMinute *struct {
				// Close The price at the end of the minute bar.
				Close *float64 `json:"close,omitempty"`

				// High The highest price reached in the minute bar.
				High *float64 `json:"high,omitempty"`

				// LastUpdated The timestamp indicating the most recent update to the minute bar.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Low The lowest price reached in the minute bar.
				Low *float64 `json:"low,omitempty"`

				// Open The opening price at the start of the minute bar.
				Open      *float64 `json:"open,omitempty"`
				Timeframe *string  `json:"timeframe,omitempty"`

				// Volume The number of contracts traded in the minute bar.
				Volume *float64 `json:"volume,omitempty"`
			} `json:"last_minute,omitempty"`
			LastQuote *struct {
				// Ask The lowest price a seller is willing to accept.
				Ask *float64 `json:"ask,omitempty"`

				// AskSize The number of contracts available at the ask price.
				AskSize *int32 `json:"ask_size,omitempty"`

				// AskTimestamp The time when the best ask price was last updated.
				AskTimestamp *int64 `json:"ask_timestamp,omitempty"`

				// Bid The highest price a buyer is willing to pay.
				Bid *float64 `json:"bid,omitempty"`

				// BidSize The number of contracts available at the bid price.
				BidSize *int32 `json:"bid_size,omitempty"`

				// BidTimestamp The time when the best bid price was last updated.
				BidTimestamp *int64 `json:"bid_timestamp,omitempty"`

				// LastUpdated The time when the quote was generated at the exchange to nanosecond precision.
				LastUpdated *int64  `json:"last_updated,omitempty"`
				Timeframe   *string `json:"timeframe,omitempty"`
			} `json:"last_quote,omitempty"`
			LastTrade *struct {
				// LastUpdated The time when the trade was generated at the exchange to nanosecond precision.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
				Price *float64 `json:"price,omitempty"`

				// Size The total number of contracts exchanged between buyers and sellers on a given trade.
				Size      *int64  `json:"size,omitempty"`
				Timeframe *string `json:"timeframe,omitempty"`
			} `json:"last_trade,omitempty"`
			Session *struct {
				// Change The change in price during this session.
				Change *float64 `json:"change,omitempty"`

				// ChangePercent The percentage change in price during this session.
				ChangePercent *float64 `json:"change_percent,omitempty"`

				// Close The price at the end of the session.
				Close *float64 `json:"close,omitempty"`

				// High The highest price reached in the session.
				High *float64 `json:"high,omitempty"`

				// Low The lowest price reached in the session.
				Low *float64 `json:"low,omitempty"`

				// Open The opening price at the start of the session.
				Open *float64 `json:"open,omitempty"`

				// PreviousSettlement The settlement price of the previous session.
				PreviousSettlement *float64 `json:"previous_settlement,omitempty"`

				// SettlementPrice The final settlement price at the end of the session.
				SettlementPrice *float64 `json:"settlement_price,omitempty"`

				// Volume The number of contracts traded in the session.
				Volume *float64 `json:"volume,omitempty"`
			} `json:"session,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXSnapshotNative200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXSnapshotNative400Status `json:"status"`
	}
}
type GetFuturesVXSnapshotNative200Status string
type GetFuturesVXSnapshotNative400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXSnapshotNativeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXSnapshotNativeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesVXTradesNewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Conditions A list of condition codes.
			Conditions *[]int32 `json:"conditions,omitempty"`

			// Correction The trade correction indicator.
			Correction *int64 `json:"correction,omitempty"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange *int32 `json:"exchange,omitempty"`

			// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
			Price float64 `json:"price"`

			// ReportSequence The report sequence number.
			ReportSequence int64 `json:"report_sequence"`

			// SequenceNumber The sequence number represents the sequence in which trade events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
			SequenceNumber int64 `json:"sequence_number"`

			// SessionEndDate The trade date representing the session end date for this trade. Used for partitioning and filtering trades by trading session.
			SessionEndDate string `json:"session_end_date"`

			// Size The total number of contracts exchanged between buyers and sellers on a given trade.
			Size *int64 `json:"size,omitempty"`

			// Ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&P 500 E-mini contract).
			Ticker string `json:"ticker"`

			// Timestamp The time when the trade was generated at the exchange to nanosecond precision.
			Timestamp int64 `json:"timestamp"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetFuturesVXTradesNew200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetFuturesVXTradesNew400Status `json:"status"`
	}
}
type GetFuturesVXTradesNew200Status string
type GetFuturesVXTradesNew400Status string

// Status returns HTTPResponse.Status
func (r GetFuturesVXTradesNewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesVXTradesNewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFuturesTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`
		Results *[]struct {
			// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
			Price float64 `json:"price"`

			// ReportSequence The reporting sequence number.
			ReportSequence int `json:"report_sequence"`

			// SequenceNumber The unique sequence number assigned to this trade.
			SequenceNumber int `json:"sequence_number"`

			// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
			SessionEndDate string `json:"session_end_date"`

			// Size The total number of contracts exchanged between buyers and sellers on a given trade.
			Size float64 `json:"size"`

			// Ticker ticker of the trade
			Ticker string `json:"ticker"`

			// Timestamp The time when the trade was generated at the exchange to nanosecond precision.
			Timestamp int `json:"timestamp"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFuturesTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFuturesTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsV1ExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Acronym Exchange acronym or short name (e.g., 'ISE', 'GEMX') - may be null for some venues.
			Acronym *string `json:"acronym,omitempty"`

			// Id Numeric identifier for the options trading venue or exchange.
			Id string `json:"id"`

			// Locale Geographic location code.
			Locale *string `json:"locale,omitempty"`

			// Mic Market Identifier Code (MIC) - ISO 10383 standard four-character code identifying the specific options market.
			Mic *string `json:"mic,omitempty"`

			// Name Full official name of the options exchange or trading venue.
			Name string `json:"name"`

			// OperatingMic Operating Market Identifier Code - identifies the parent organization or operating entity.
			OperatingMic *string `json:"operating_mic,omitempty"`

			// ParticipantId Single-character participant identifier used in consolidator market data feeds and options trade reporting.
			ParticipantId *string `json:"participant_id,omitempty"`

			// Type Type of venue: 'exchange' for options exchanges, 'SIP' for Securities Information Processors like OPRA (Options Price Reporting Authority).
			Type string `json:"type"`

			// Url Official website URL of the organization operating the options exchange.
			Url *string `json:"url,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetOptionsV1Exchanges200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetOptionsV1Exchanges400Status `json:"status"`
	}
}
type GetOptionsV1Exchanges200Status string
type GetOptionsV1Exchanges400Status string

// Status returns HTTPResponse.Status
func (r GetOptionsV1ExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsV1ExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFilings10KVXSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Cik SEC Central Index Key (10 digits, zero-padded).
			Cik *string `json:"cik,omitempty"`

			// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
			FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

			// FilingUrl SEC URL source for the full filing.
			FilingUrl *string `json:"filing_url,omitempty"`

			// PeriodEnd Period end date that the filing relates to (formatted as YYYY-MM-DD).
			PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

			// Section Standardized section identifier from the filing (e.g. 'business', 'risk_factors', etc.).
			Section *string `json:"section,omitempty"`

			// Text Full raw text content of the section, including headers and formatting.
			Text *string `json:"text,omitempty"`

			// Ticker Stock ticker symbol for the company.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFilings10KVXSections200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFilings10KVXSections400Status `json:"status"`
	}
}
type GetStocksFilings10KVXSections200Status string
type GetStocksFilings10KVXSections400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFilings10KVXSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFilings10KVXSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFilingsVXIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AccessionNumber SEC accession number uniquely identifying the filing (e.g., '0000320193-24-000123').
			AccessionNumber *string `json:"accession_number,omitempty"`

			// Cik SEC Central Index Key (CIK) identifying the filing entity.
			Cik *string `json:"cik,omitempty"`

			// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
			FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

			// FilingUrl Direct URL to the filing on the SEC EDGAR website.
			FilingUrl *string `json:"filing_url,omitempty"`

			// FormType SEC form type (e.g., '10-K', '10-Q', '8-K', 'S-1', '4', etc.).
			FormType *string `json:"form_type,omitempty"`

			// IssuerName Name of the company or entity that submitted the filing.
			IssuerName *string `json:"issuer_name,omitempty"`

			// Ticker Stock ticker symbol for the filing entity, if available.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFilingsVXIndex200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFilingsVXIndex400Status `json:"status"`
	}
}
type GetStocksFilingsVXIndex200Status string
type GetStocksFilingsVXIndex400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFilingsVXIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFilingsVXIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFilingsVXRiskFactorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Cik SEC Central Index Key (10 digits, zero-padded).
			Cik *string `json:"cik,omitempty"`

			// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
			FilingDate *string `json:"filing_date,omitempty"`

			// PrimaryCategory Top-level risk category
			PrimaryCategory *string `json:"primary_category,omitempty"`

			// SecondaryCategory Mid-level risk category
			SecondaryCategory *string `json:"secondary_category,omitempty"`

			// SupportingText Snippet of text to support the given label
			SupportingText *string `json:"supporting_text,omitempty"`

			// TertiaryCategory Most specific risk classification
			TertiaryCategory *string `json:"tertiary_category,omitempty"`

			// Ticker Stock ticker symbol for the company.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFilingsVXRiskFactors200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFilingsVXRiskFactors400Status `json:"status"`
	}
}
type GetStocksFilingsVXRiskFactors200Status string
type GetStocksFilingsVXRiskFactors400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFilingsVXRiskFactorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFilingsVXRiskFactorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFinancialsV1BalanceSheetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AccountsPayable Amounts owed to suppliers and vendors for goods and services purchased on credit.
			AccountsPayable *float64 `json:"accounts_payable,omitempty"`

			// AccruedAndOtherCurrentLiabilities Current liabilities not classified elsewhere, including accrued expenses, taxes payable, and other obligations due within one year.
			AccruedAndOtherCurrentLiabilities *float64 `json:"accrued_and_other_current_liabilities,omitempty"`

			// AccumulatedOtherComprehensiveIncome Cumulative gains and losses that bypass the income statement, including foreign currency translation adjustments and unrealized gains/losses on securities.
			AccumulatedOtherComprehensiveIncome *float64 `json:"accumulated_other_comprehensive_income,omitempty"`

			// AdditionalPaidInCapital Amount received from shareholders in excess of the par or stated value of shares issued.
			AdditionalPaidInCapital *float64 `json:"additional_paid_in_capital,omitempty"`

			// CashAndEquivalents Cash on hand and short-term, highly liquid investments that are readily convertible to known amounts of cash.
			CashAndEquivalents *float64 `json:"cash_and_equivalents,omitempty"`

			// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a company's CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
			Cik *string `json:"cik,omitempty"`

			// CommitmentsAndContingencies Disclosed amount related to contractual commitments and potential liabilities that may arise from uncertain future events.
			CommitmentsAndContingencies *float64 `json:"commitments_and_contingencies,omitempty"`

			// CommonStock Par or stated value of common shares outstanding representing basic ownership in the company.
			CommonStock *float64 `json:"common_stock,omitempty"`

			// DebtCurrent Short-term borrowings and the current portion of long-term debt due within one year.
			DebtCurrent *float64 `json:"debt_current,omitempty"`

			// DeferredRevenueCurrent Customer payments received in advance for goods or services to be delivered within one year.
			DeferredRevenueCurrent *float64 `json:"deferred_revenue_current,omitempty"`

			// FilingDate The date when the financial statement was filed with the SEC.
			FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

			// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
			FiscalQuarter *float64 `json:"fiscal_quarter,omitempty"`

			// FiscalYear The fiscal year for the reporting period.
			FiscalYear *float64 `json:"fiscal_year,omitempty"`

			// Goodwill Intangible asset representing the excess of purchase price over fair value of net assets acquired in business combinations.
			Goodwill *float64 `json:"goodwill,omitempty"`

			// IntangibleAssetsNet Intangible assets other than goodwill, including patents, trademarks, and customer relationships, net of accumulated amortization.
			IntangibleAssetsNet *float64 `json:"intangible_assets_net,omitempty"`

			// Inventories Raw materials, work-in-process, and finished goods held for sale in the ordinary course of business.
			Inventories *float64 `json:"inventories,omitempty"`

			// LongTermDebtAndCapitalLeaseObligations Long-term borrowings and capital lease obligations with maturities greater than one year.
			LongTermDebtAndCapitalLeaseObligations *float64 `json:"long_term_debt_and_capital_lease_obligations,omitempty"`

			// NoncontrollingInterest Equity in consolidated subsidiaries not owned by the parent company, representing minority shareholders' ownership.
			NoncontrollingInterest *float64 `json:"noncontrolling_interest,omitempty"`

			// OtherAssets Non-current assets not classified elsewhere, including long-term investments, deferred tax assets, and other long-term assets.
			OtherAssets *float64 `json:"other_assets,omitempty"`

			// OtherCurrentAssets Current assets not classified elsewhere, including prepaid expenses, taxes receivable, and other assets expected to be converted to cash within one year.
			OtherCurrentAssets *float64 `json:"other_current_assets,omitempty"`

			// OtherEquity Equity components not classified elsewhere in shareholders' equity.
			OtherEquity *float64 `json:"other_equity,omitempty"`

			// OtherNoncurrentLiabilities Non-current liabilities not classified elsewhere, including deferred tax liabilities, pension obligations, and other long-term liabilities.
			OtherNoncurrentLiabilities *float64 `json:"other_noncurrent_liabilities,omitempty"`

			// PeriodEnd The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken.
			PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

			// PreferredStock Par or stated value of preferred shares outstanding with preferential rights over common stock.
			PreferredStock *float64 `json:"preferred_stock,omitempty"`

			// PropertyPlantEquipmentNet Tangible fixed assets used in operations, reported net of accumulated depreciation.
			PropertyPlantEquipmentNet *float64 `json:"property_plant_equipment_net,omitempty"`

			// Receivables Amounts owed to the company by customers and other parties, primarily accounts receivable, net of allowances for doubtful accounts.
			Receivables *float64 `json:"receivables,omitempty"`

			// RetainedEarningsDeficit Cumulative net income earned by the company less dividends paid to shareholders since inception.
			RetainedEarningsDeficit *float64 `json:"retained_earnings_deficit,omitempty"`

			// ShortTermInvestments Marketable securities and other investments with maturities of one year or less that are not classified as cash equivalents.
			ShortTermInvestments *float64 `json:"short_term_investments,omitempty"`

			// Tickers A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
			Tickers *[]string `json:"tickers,omitempty"`

			// Timeframe The reporting period type. Possible values include: quarterly, annual.
			Timeframe string `json:"timeframe"`

			// TotalAssets Sum of all current and non-current assets representing everything the company owns or controls.
			TotalAssets *float64 `json:"total_assets,omitempty"`

			// TotalCurrentAssets Sum of all current assets expected to be converted to cash, sold, or consumed within one year.
			TotalCurrentAssets *float64 `json:"total_current_assets,omitempty"`

			// TotalCurrentLiabilities Sum of all liabilities expected to be settled within one year.
			TotalCurrentLiabilities *float64 `json:"total_current_liabilities,omitempty"`

			// TotalEquity Sum of all equity components representing shareholders' total ownership interest in the company.
			TotalEquity *float64 `json:"total_equity,omitempty"`

			// TotalEquityAttributableToParent Total shareholders' equity attributable to the parent company, excluding noncontrolling interests.
			TotalEquityAttributableToParent *float64 `json:"total_equity_attributable_to_parent,omitempty"`

			// TotalLiabilities Sum of all current and non-current liabilities representing everything the company owes.
			TotalLiabilities *float64 `json:"total_liabilities,omitempty"`

			// TotalLiabilitiesAndEquity Sum of total liabilities and total equity, which should equal total assets per the fundamental accounting equation.
			TotalLiabilitiesAndEquity *float64 `json:"total_liabilities_and_equity,omitempty"`

			// TreasuryStock Cost of the company's own shares that have been repurchased and are held in treasury, typically reported as a negative value.
			TreasuryStock *float64 `json:"treasury_stock,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1BalanceSheets200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1BalanceSheets400Status `json:"status"`
	}
}
type GetStocksFinancialsV1BalanceSheets200Status string
type GetStocksFinancialsV1BalanceSheets400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFinancialsV1BalanceSheetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFinancialsV1BalanceSheetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFinancialsV1CashFlowStatementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// CashFromOperatingActivitiesContinuingOperations Cash generated from continuing business operations before discontinued operations.
			CashFromOperatingActivitiesContinuingOperations *float64 `json:"cash_from_operating_activities_continuing_operations,omitempty"`

			// ChangeInCashAndEquivalents Net change in cash and cash equivalents during the period, representing the sum of operating, investing, and financing cash flows plus currency effects.
			ChangeInCashAndEquivalents *float64 `json:"change_in_cash_and_equivalents,omitempty"`

			// ChangeInOtherOperatingAssetsAndLiabilitiesNet Net change in working capital components including accounts receivable, inventory, accounts payable, and other operating items.
			ChangeInOtherOperatingAssetsAndLiabilitiesNet *float64 `json:"change_in_other_operating_assets_and_liabilities_net,omitempty"`

			// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
			Cik *string `json:"cik,omitempty"`

			// DepreciationDepletionAndAmortization Non-cash charges for the reduction in value of tangible and intangible assets over time.
			DepreciationDepletionAndAmortization *float64 `json:"depreciation_depletion_and_amortization,omitempty"`

			// Dividends Cash payments to shareholders in the form of dividends, typically reported as negative values.
			Dividends *float64 `json:"dividends,omitempty"`

			// EffectOfCurrencyExchangeRate Impact of foreign exchange rate changes on cash and cash equivalents denominated in foreign currencies.
			EffectOfCurrencyExchangeRate *float64 `json:"effect_of_currency_exchange_rate,omitempty"`

			// FilingDate The date when the financial statement was filed with the SEC.
			FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

			// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
			FiscalQuarter *float64 `json:"fiscal_quarter,omitempty"`

			// FiscalYear The fiscal year for the reporting period.
			FiscalYear *float64 `json:"fiscal_year,omitempty"`

			// IncomeLossFromDiscontinuedOperations After-tax income or loss from business operations that have been discontinued.
			IncomeLossFromDiscontinuedOperations *float64 `json:"income_loss_from_discontinued_operations,omitempty"`

			// LongTermDebtIssuancesRepayments Net cash flows from issuing or repaying long-term debt obligations.
			LongTermDebtIssuancesRepayments *float64 `json:"long_term_debt_issuances_repayments,omitempty"`

			// NetCashFromFinancingActivities Total cash generated or used by financing activities, including debt issuance, debt repayment, dividends, and share transactions.
			NetCashFromFinancingActivities *float64 `json:"net_cash_from_financing_activities,omitempty"`

			// NetCashFromFinancingActivitiesContinuingOperations Cash flows from financing activities of continuing operations before discontinued operations.
			NetCashFromFinancingActivitiesContinuingOperations *float64 `json:"net_cash_from_financing_activities_continuing_operations,omitempty"`

			// NetCashFromFinancingActivitiesDiscontinuedOperations Cash flows from financing activities of discontinued business segments.
			NetCashFromFinancingActivitiesDiscontinuedOperations *float64 `json:"net_cash_from_financing_activities_discontinued_operations,omitempty"`

			// NetCashFromInvestingActivities Total cash generated or used by investing activities, including capital expenditures, acquisitions, and asset sales.
			NetCashFromInvestingActivities *float64 `json:"net_cash_from_investing_activities,omitempty"`

			// NetCashFromInvestingActivitiesContinuingOperations Cash flows from investing activities of continuing operations before discontinued operations.
			NetCashFromInvestingActivitiesContinuingOperations *float64 `json:"net_cash_from_investing_activities_continuing_operations,omitempty"`

			// NetCashFromInvestingActivitiesDiscontinuedOperations Cash flows from investing activities of discontinued business segments.
			NetCashFromInvestingActivitiesDiscontinuedOperations *float64 `json:"net_cash_from_investing_activities_discontinued_operations,omitempty"`

			// NetCashFromOperatingActivities Total cash generated or used by operating activities, representing cash flow from core business operations.
			NetCashFromOperatingActivities *float64 `json:"net_cash_from_operating_activities,omitempty"`

			// NetCashFromOperatingActivitiesDiscontinuedOperations Cash flows from operating activities of discontinued business segments.
			NetCashFromOperatingActivitiesDiscontinuedOperations *float64 `json:"net_cash_from_operating_activities_discontinued_operations,omitempty"`

			// NetIncome Net income used as the starting point for operating cash flow calculations.
			NetIncome *float64 `json:"net_income,omitempty"`

			// NoncontrollingInterests Cash flows related to minority shareholders in consolidated subsidiaries.
			NoncontrollingInterests *float64 `json:"noncontrolling_interests,omitempty"`

			// OtherCashAdjustments Other miscellaneous adjustments to cash flows not classified elsewhere.
			OtherCashAdjustments *float64 `json:"other_cash_adjustments,omitempty"`

			// OtherFinancingActivities Cash flows from financing activities not classified elsewhere, including share repurchases and other equity transactions.
			OtherFinancingActivities *float64 `json:"other_financing_activities,omitempty"`

			// OtherInvestingActivities Cash flows from investing activities not classified elsewhere, including acquisitions, divestitures, and investments.
			OtherInvestingActivities *float64 `json:"other_investing_activities,omitempty"`

			// OtherOperatingActivities Other adjustments to reconcile net income to operating cash flow not classified elsewhere.
			OtherOperatingActivities *float64 `json:"other_operating_activities,omitempty"`

			// PeriodEnd The last date of the reporting period (formatted as YYYY-MM-DD).
			PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

			// PurchaseOfPropertyPlantAndEquipment Cash outflows for capital expenditures on fixed assets, typically reported as negative values.
			PurchaseOfPropertyPlantAndEquipment *float64 `json:"purchase_of_property_plant_and_equipment,omitempty"`

			// SaleOfPropertyPlantAndEquipment Cash inflows from disposing of fixed assets, typically reported as positive values.
			SaleOfPropertyPlantAndEquipment *float64 `json:"sale_of_property_plant_and_equipment,omitempty"`

			// ShortTermDebtIssuancesRepayments Net cash flows from issuing or repaying short-term debt obligations.
			ShortTermDebtIssuancesRepayments *float64 `json:"short_term_debt_issuances_repayments,omitempty"`

			// Tickers A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
			Tickers *[]string `json:"tickers,omitempty"`

			// Timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
			Timeframe *string `json:"timeframe,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1CashFlowStatements200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1CashFlowStatements400Status `json:"status"`
	}
}
type GetStocksFinancialsV1CashFlowStatements200Status string
type GetStocksFinancialsV1CashFlowStatements400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFinancialsV1CashFlowStatementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFinancialsV1CashFlowStatementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFinancialsV1IncomeStatementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// BasicEarningsPerShare Earnings per share calculated using the weighted average number of basic shares outstanding. For TTM records, recalculated as TTM net income divided by average basic shares outstanding over the four quarters.
			BasicEarningsPerShare *float64 `json:"basic_earnings_per_share,omitempty"`

			// BasicSharesOutstanding Weighted average number of common shares outstanding during the period, used in basic EPS calculation. For TTM records, represents the average over the four most recent quarters.
			BasicSharesOutstanding *float64 `json:"basic_shares_outstanding,omitempty"`

			// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
			Cik *string `json:"cik,omitempty"`

			// ConsolidatedNetIncomeLoss Total net income or loss for the consolidated entity including all subsidiaries.
			ConsolidatedNetIncomeLoss *float64 `json:"consolidated_net_income_loss,omitempty"`

			// CostOfRevenue Direct costs attributable to the production of goods or services sold, also known as cost of goods sold (COGS).
			CostOfRevenue *float64 `json:"cost_of_revenue,omitempty"`

			// DepreciationDepletionAmortization Non-cash expenses representing the allocation of asset costs over their useful lives.
			DepreciationDepletionAmortization *float64 `json:"depreciation_depletion_amortization,omitempty"`

			// DilutedEarningsPerShare Earnings per share calculated using diluted shares outstanding, including the effect of potentially dilutive securities. For TTM records, recalculated as TTM net income divided by average diluted shares outstanding over the four quarters.
			DilutedEarningsPerShare *float64 `json:"diluted_earnings_per_share,omitempty"`

			// DilutedSharesOutstanding Weighted average number of shares outstanding including the dilutive effect of stock options, warrants, and convertible securities. For TTM records, represents the average over the four most recent quarters.
			DilutedSharesOutstanding *float64 `json:"diluted_shares_outstanding,omitempty"`

			// DiscontinuedOperations After-tax results from business segments that have been or will be disposed of.
			DiscontinuedOperations *float64 `json:"discontinued_operations,omitempty"`

			// Ebitda Earnings before interest, taxes, depreciation, and amortization, a measure of operating performance.
			Ebitda *float64 `json:"ebitda,omitempty"`

			// EquityInAffiliates The company's share of income or losses from equity method investments in affiliated companies.
			EquityInAffiliates *float64 `json:"equity_in_affiliates,omitempty"`

			// ExtraordinaryItems Unusual and infrequent gains or losses that are both unusual in nature and infrequent in occurrence.
			ExtraordinaryItems *float64 `json:"extraordinary_items,omitempty"`

			// FilingDate The date when the financial statement was filed with the SEC.
			FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

			// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
			FiscalQuarter *float64 `json:"fiscal_quarter,omitempty"`

			// FiscalYear The fiscal year for the reporting period.
			FiscalYear *float64 `json:"fiscal_year,omitempty"`

			// GrossProfit Revenue minus cost of revenue, representing profit before operating expenses.
			GrossProfit *float64 `json:"gross_profit,omitempty"`

			// IncomeBeforeIncomeTaxes Pre-tax income calculated as operating income plus total other income/expense.
			IncomeBeforeIncomeTaxes *float64 `json:"income_before_income_taxes,omitempty"`

			// IncomeTaxes Income tax expense or benefit for the period.
			IncomeTaxes *float64 `json:"income_taxes,omitempty"`

			// InterestExpense Cost of borrowed funds, including interest on debt and other financing obligations.
			InterestExpense *float64 `json:"interest_expense,omitempty"`

			// InterestIncome Income earned from interest-bearing investments and cash equivalents.
			InterestIncome *float64 `json:"interest_income,omitempty"`

			// NetIncomeLossAttributableCommonShareholders Net income or loss available to common shareholders after preferred dividends and noncontrolling interests.
			NetIncomeLossAttributableCommonShareholders *float64 `json:"net_income_loss_attributable_common_shareholders,omitempty"`

			// NoncontrollingInterest The portion of net income attributable to minority shareholders in consolidated subsidiaries.
			NoncontrollingInterest *float64 `json:"noncontrolling_interest,omitempty"`

			// OperatingIncome Income from operations calculated as gross profit minus total operating expenses, excluding non-operating items.
			OperatingIncome *float64 `json:"operating_income,omitempty"`

			// OtherIncomeExpense Non-operating income and expenses not related to the company's core business operations.
			OtherIncomeExpense *float64 `json:"other_income_expense,omitempty"`

			// OtherOperatingExpenses Operating expenses not classified in the main expense categories.
			OtherOperatingExpenses *float64 `json:"other_operating_expenses,omitempty"`

			// PeriodEnd The last date of the reporting period (formatted as YYYY-MM-DD).
			PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

			// PreferredStockDividendsDeclared Dividends declared on preferred stock during the period.
			PreferredStockDividendsDeclared *float64 `json:"preferred_stock_dividends_declared,omitempty"`

			// ResearchDevelopment Expenses incurred for research and development activities to create new products or improve existing ones.
			ResearchDevelopment *float64 `json:"research_development,omitempty"`

			// Revenue Total revenue or net sales for the period, representing the company's gross income from operations.
			Revenue *float64 `json:"revenue,omitempty"`

			// SellingGeneralAdministrative Expenses related to selling products and general administrative costs not directly tied to production.
			SellingGeneralAdministrative *float64 `json:"selling_general_administrative,omitempty"`

			// Tickers A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
			Tickers *[]string `json:"tickers,omitempty"`

			// Timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
			Timeframe *string `json:"timeframe,omitempty"`

			// TotalOperatingExpenses Sum of all operating expenses including cost of revenue, SG&A, R&D, depreciation, and other operating expenses.
			TotalOperatingExpenses *float64 `json:"total_operating_expenses,omitempty"`

			// TotalOtherIncomeExpense Net total of all non-operating income and expenses including interest income, interest expense, and other items.
			TotalOtherIncomeExpense *float64 `json:"total_other_income_expense,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1IncomeStatements200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1IncomeStatements400Status `json:"status"`
	}
}
type GetStocksFinancialsV1IncomeStatements200Status string
type GetStocksFinancialsV1IncomeStatements400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFinancialsV1IncomeStatementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFinancialsV1IncomeStatementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksFinancialsV1RatiosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AverageVolume Average trading volume over the last 30 trading days, providing context for liquidity.
			AverageVolume *float64 `json:"average_volume,omitempty"`

			// Cash Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage.
			Cash *float64 `json:"cash,omitempty"`

			// Cik Central Index Key (CIK) number assigned by the SEC to identify the company.
			Cik *string `json:"cik,omitempty"`

			// Current Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity.
			Current *float64 `json:"current,omitempty"`

			// Date Date for which the ratios are calculated, representing the trading date with available price data.
			Date string `json:"date"`

			// DebtToEquity Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders' equity, measuring financial leverage.
			DebtToEquity *float64 `json:"debt_to_equity,omitempty"`

			// DividendYield Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment.
			DividendYield *float64 `json:"dividend_yield,omitempty"`

			// EarningsPerShare Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding.
			EarningsPerShare *float64 `json:"earnings_per_share,omitempty"`

			// EnterpriseValue Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value.
			EnterpriseValue *float64 `json:"enterprise_value,omitempty"`

			// EvToEbitda Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization.
			EvToEbitda *float64 `json:"ev_to_ebitda,omitempty"`

			// EvToSales Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales.
			EvToSales *float64 `json:"ev_to_sales,omitempty"`

			// FreeCashFlow Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment).
			FreeCashFlow *float64 `json:"free_cash_flow,omitempty"`

			// MarketCap Market capitalization, calculated as stock price multiplied by total shares outstanding.
			MarketCap *float64 `json:"market_cap,omitempty"`

			// Price Stock price used in ratio calculations, typically the closing price for the given date.
			Price *float64 `json:"price,omitempty"`

			// PriceToBook Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value.
			PriceToBook *float64 `json:"price_to_book,omitempty"`

			// PriceToCashFlow Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive.
			PriceToCashFlow *float64 `json:"price_to_cash_flow,omitempty"`

			// PriceToEarnings Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive.
			PriceToEarnings *float64 `json:"price_to_earnings,omitempty"`

			// PriceToFreeCashFlow Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive.
			PriceToFreeCashFlow *float64 `json:"price_to_free_cash_flow,omitempty"`

			// PriceToSales Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales.
			PriceToSales *float64 `json:"price_to_sales,omitempty"`

			// Quick Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity.
			Quick *float64 `json:"quick,omitempty"`

			// ReturnOnAssets Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit.
			ReturnOnAssets *float64 `json:"return_on_assets,omitempty"`

			// ReturnOnEquity Return on equity ratio, calculated as net income divided by total shareholders' equity, measuring profitability relative to shareholders' equity.
			ReturnOnEquity *float64 `json:"return_on_equity,omitempty"`

			// Ticker Stock ticker symbol for the company.
			Ticker string `json:"ticker"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1Ratios200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksFinancialsV1Ratios400Status `json:"status"`
	}
}
type GetStocksFinancialsV1Ratios200Status string
type GetStocksFinancialsV1Ratios400Status string

// Status returns HTTPResponse.Status
func (r GetStocksFinancialsV1RatiosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksFinancialsV1RatiosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksTaxonomiesVXRiskFactorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Description Detailed explanation of what this risk category encompasses, including specific examples and potential impacts
			Description *string `json:"description,omitempty"`

			// PrimaryCategory Top-level risk category
			PrimaryCategory *string `json:"primary_category,omitempty"`

			// SecondaryCategory Mid-level risk category
			SecondaryCategory *string `json:"secondary_category,omitempty"`

			// Taxonomy Version identifier (e.g., '1.0', '1.1') for the taxonomy
			Taxonomy float64 `json:"taxonomy"`

			// TertiaryCategory Most specific risk classification
			TertiaryCategory *string `json:"tertiary_category,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksTaxonomiesVXRiskFactors200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksTaxonomiesVXRiskFactors400Status `json:"status"`
	}
}
type GetStocksTaxonomiesVXRiskFactors200Status string
type GetStocksTaxonomiesVXRiskFactors400Status string

// Status returns HTTPResponse.Status
func (r GetStocksTaxonomiesVXRiskFactorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksTaxonomiesVXRiskFactorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksV1DividendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// CashAmount Original dividend amount per share in the specified currency
			CashAmount *float64 `json:"cash_amount,omitempty"`

			// Currency Currency code for the dividend payment (e.g., USD, CAD)
			Currency *string `json:"currency,omitempty"`

			// DeclarationDate Date when the company officially announced the dividend
			DeclarationDate *openapi_types.Date `json:"declaration_date,omitempty"`

			// DistributionType Classification describing the nature of this dividend's recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
			DistributionType string `json:"distribution_type"`

			// ExDividendDate Date when the stock begins trading without the dividend value
			ExDividendDate *openapi_types.Date `json:"ex_dividend_date,omitempty"`

			// Frequency How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 52 (weekly), 104 (bi-weekly), and 365 (daily) depending on the issuer's declared or inferred payout cadence.
			Frequency *int64 `json:"frequency,omitempty"`

			// HistoricalAdjustmentFactor Cumulative adjustment factor used to offset dividend effects on historical prices. To adjust a historical price for dividends: for a price on date D, find the first dividend whose `ex_dividend_date` is after date D and multiply the price by that dividend's `historical_adjustment_factor`.
			HistoricalAdjustmentFactor *float64 `json:"historical_adjustment_factor,omitempty"`

			// Id Unique identifier for each dividend record
			Id *string `json:"id,omitempty"`

			// PayDate Date when the dividend payment is distributed to shareholders
			PayDate *openapi_types.Date `json:"pay_date,omitempty"`

			// RecordDate Date when shareholders must be on record to be eligible for the dividend payment
			RecordDate *openapi_types.Date `json:"record_date,omitempty"`

			// SplitAdjustedCashAmount Dividend amount adjusted for stock splits that occurred after the dividend was paid, expressed on a current share basis
			SplitAdjustedCashAmount *float64 `json:"split_adjusted_cash_amount,omitempty"`

			// Ticker Stock symbol for the company issuing the dividend
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksV1Dividends200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksV1Dividends400Status `json:"status"`
	}
}
type GetStocksV1Dividends200Status string
type GetStocksV1Dividends400Status string

// Status returns HTTPResponse.Status
func (r GetStocksV1DividendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksV1DividendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksV1ExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// Acronym Short acronym or abbreviation (may be null for some venues).
			Acronym *string `json:"acronym,omitempty"`

			// Id Numeric identifier for the trading venue or exchange.
			Id string `json:"id"`

			// Locale Geographic location code.
			Locale *string `json:"locale,omitempty"`

			// Mic Market Identifier Code (MIC) - ISO 10383 standard four-character code for the market (may be empty for some venues).
			Mic *string `json:"mic,omitempty"`

			// Name Full official name of the exchange, trading venue, or reporting facility.
			Name string `json:"name"`

			// OperatingMic Operating Market Identifier Code - identifies the specific operating entity or parent organization.
			OperatingMic *string `json:"operating_mic,omitempty"`

			// ParticipantId Single-character participant identifier used in market data feeds and trade reporting.
			ParticipantId *string `json:"participant_id,omitempty"`

			// Type Type of trading venue: 'exchange' for stock exchanges, 'TRF' for Trade Reporting Facilities, 'SIP' for Securities Information Processors, 'ORF' for OTC Reporting Facility.
			Type string `json:"type"`

			// Url Official website URL of the organization operating the venue.
			Url *string `json:"url,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksV1Exchanges200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksV1Exchanges400Status `json:"status"`
	}
}
type GetStocksV1Exchanges200Status string
type GetStocksV1Exchanges400Status string

// Status returns HTTPResponse.Status
func (r GetStocksV1ExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksV1ExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksV1ShortInterestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AvgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
			AvgDailyVolume int64 `json:"avg_daily_volume"`

			// DaysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
			DaysToCover float64 `json:"days_to_cover"`

			// SettlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
			SettlementDate string `json:"settlement_date"`

			// ShortInterest The total number of shares that have been sold short but have not yet been covered or closed out.
			ShortInterest *int64 `json:"short_interest,omitempty"`

			// Ticker The primary ticker symbol for the stock.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksV1ShortInterest200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksV1ShortInterest400Status `json:"status"`
	}
}
type GetStocksV1ShortInterest200Status string
type GetStocksV1ShortInterest400Status string

// Status returns HTTPResponse.Status
func (r GetStocksV1ShortInterestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksV1ShortInterestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksV1ShortVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AdfShortVolume Short volume reported via the Alternative Display Facility (ADF), excluding exempt volume.
			AdfShortVolume *int64 `json:"adf_short_volume,omitempty"`

			// AdfShortVolumeExempt Short volume reported via ADF that was marked as exempt.
			AdfShortVolumeExempt *int64 `json:"adf_short_volume_exempt,omitempty"`

			// Date The date of trade activity reported in the format YYYY-MM-DD
			Date string `json:"date"`

			// ExemptVolume Portion of short volume that was marked as exempt from regulation SHO.
			ExemptVolume *int64 `json:"exempt_volume,omitempty"`

			// NasdaqCarteretShortVolume Short volume reported from Nasdaq's Carteret facility, excluding exempt volume.
			NasdaqCarteretShortVolume *int64 `json:"nasdaq_carteret_short_volume,omitempty"`

			// NasdaqCarteretShortVolumeExempt Short volume from Nasdaq Carteret that was marked as exempt.
			NasdaqCarteretShortVolumeExempt *int64 `json:"nasdaq_carteret_short_volume_exempt,omitempty"`

			// NasdaqChicagoShortVolume Short volume reported from Nasdaq's Chicago facility, excluding exempt volume.
			NasdaqChicagoShortVolume *int64 `json:"nasdaq_chicago_short_volume,omitempty"`

			// NasdaqChicagoShortVolumeExempt Short volume from Nasdaq Chicago that was marked as exempt.
			NasdaqChicagoShortVolumeExempt *int64 `json:"nasdaq_chicago_short_volume_exempt,omitempty"`

			// NonExemptVolume Portion of short volume that was not exempt from regulation SHO (i.e., short_volume - exempt_volume).
			NonExemptVolume *int64 `json:"non_exempt_volume,omitempty"`

			// NyseShortVolume Short volume reported from NYSE facilities, excluding exempt volume.
			NyseShortVolume *int64 `json:"nyse_short_volume,omitempty"`

			// NyseShortVolumeExempt Short volume from NYSE facilities that was marked as exempt.
			NyseShortVolumeExempt *int64 `json:"nyse_short_volume_exempt,omitempty"`

			// ShortVolume Total number of shares sold short across all venues for the ticker on the given date.
			ShortVolume *int64 `json:"short_volume,omitempty"`

			// ShortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
			ShortVolumeRatio *float32 `json:"short_volume_ratio,omitempty"`

			// Ticker The primary ticker symbol for the stock.
			Ticker *string `json:"ticker,omitempty"`

			// TotalVolume Total reported volume across all venues for the ticker on the given date.
			TotalVolume *int64 `json:"total_volume,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksV1ShortVolume200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksV1ShortVolume400Status `json:"status"`
	}
}
type GetStocksV1ShortVolume200Status string
type GetStocksV1ShortVolume400Status string

// Status returns HTTPResponse.Status
func (r GetStocksV1ShortVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksV1ShortVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksV1SplitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AdjustmentType Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
			AdjustmentType string `json:"adjustment_type"`

			// ExecutionDate Date when the stock split was applied and shares adjusted
			ExecutionDate *openapi_types.Date `json:"execution_date,omitempty"`

			// HistoricalAdjustmentFactor Cumulative adjustment factor used to offset split effects on historical prices. To adjust a historical price for splits: for a price on date D, find the first split whose `execution_date` is after date D and multiply the unadjusted price by the `historical_adjustment_factor`.
			HistoricalAdjustmentFactor *float64 `json:"historical_adjustment_factor,omitempty"`

			// Id Unique identifier for each stock split event
			Id *string `json:"id,omitempty"`

			// SplitFrom Denominator of the split ratio (old shares)
			SplitFrom *float64 `json:"split_from,omitempty"`

			// SplitTo Numerator of the split ratio (new shares)
			SplitTo *float64 `json:"split_to,omitempty"`

			// Ticker Stock symbol for the company that executed the split
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksV1Splits200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksV1Splits400Status `json:"status"`
	}
}
type GetStocksV1Splits200Status string
type GetStocksV1Splits400Status string

// Status returns HTTPResponse.Status
func (r GetStocksV1SplitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksV1SplitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksVXFloatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// EffectiveDate The effective date of the free float measurement.
			EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

			// FreeFloat Number of shares freely tradable in the market. Free float shares represent the portion of a company's outstanding shares that is freely tradable in the market, excluding any holdings considered strategic, controlling, or long term. This excludes insiders, directors, founders, 5 percent plus shareholders, cross holdings, government stakes except pensions, restricted or locked up shares, employee plans, and any entities with board influence, leaving only shares that are genuinely available for public trading.
			FreeFloat *int64 `json:"free_float,omitempty"`

			// FreeFloatPercent Percentage of total shares outstanding that are available for public trading, rounded to two decimal places.
			FreeFloatPercent *float64 `json:"free_float_percent,omitempty"`

			// Ticker The primary ticker symbol for the stock.
			Ticker *string `json:"ticker,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetStocksVXFloat200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetStocksVXFloat400Status `json:"status"`
	}
}
type GetStocksVXFloat200Status string
type GetStocksVXFloat400Status string

// Status returns HTTPResponse.Status
func (r GetStocksVXFloatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksVXFloatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTmxV1CorporateEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// CompanyName Full name of the company.
			CompanyName *string `json:"company_name,omitempty"`

			// Date Scheduled date of the corporate event, formatted as YYYY-MM-DD.
			Date *string `json:"date,omitempty"`

			// Isin Standard international identifier for the company's common stock.
			Isin *string `json:"isin,omitempty"`

			// Name Name or title of the event.
			Name *string `json:"name,omitempty"`

			// Status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
			Status *string `json:"status,omitempty"`

			// Ticker The company's stock symbol.
			Ticker *string `json:"ticker,omitempty"`

			// TmxCompanyId Unique numeric identifier for the company used by TMX.
			TmxCompanyId *int64 `json:"tmx_company_id,omitempty"`

			// TmxRecordId The unique alphanumeric identifier for the event record used by TMX.
			TmxRecordId *string `json:"tmx_record_id,omitempty"`

			// TradingVenue MIC (Market Identifier Code) of the exchange where the company's stock is listed.
			TradingVenue *string `json:"trading_venue,omitempty"`

			// Type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
			Type *string `json:"type,omitempty"`

			// Url URL linking to the primary public source of the event announcement, if available.
			Url *string `json:"url,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetTmxV1CorporateEvents200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetTmxV1CorporateEvents400Status `json:"status"`
	}
}
type GetTmxV1CorporateEvents200Status string
type GetTmxV1CorporateEvents400Status string

// Status returns HTTPResponse.Status
func (r GetTmxV1CorporateEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTmxV1CorporateEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrencyConversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Converted The result of the conversion.
		Converted float64 `json:"converted"`

		// From The "from" currency symbol.
		From string `json:"from"`

		// InitialAmount The amount to convert.
		InitialAmount float64 `json:"initialAmount"`

		// Last Contains the requested quote data for the specified forex currency pair.
		Last *struct {
			// Ask The ask price.
			Ask float64 `json:"ask"`

			// Bid The bid price.
			Bid float64 `json:"bid"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/forex/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange int `json:"exchange"`

			// Timestamp The Unix millisecond timestamp.
			Timestamp int `json:"timestamp"`
		} `json:"last,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`

		// Symbol The symbol pair that was evaluated from the request.
		Symbol string `json:"symbol"`

		// To The "to" currency symbol.
		To string `json:"to"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCurrencyConversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrencyConversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedGetHistoricCryptoTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		// Day The date that was evaluated from the request.
		Day openapi_types.Date `json:"day"`

		// Map A map for shortened result keys.
		Map map[string]interface{} `json:"map"`

		// MsLatency The milliseconds of latency for the query results.
		MsLatency int `json:"msLatency"`

		// Symbol The symbol pair that was evaluated from the request.
		Symbol string `json:"symbol"`
		Ticks  []struct {
			// C A list of condition codes.
			C []int `json:"c"`

			// I The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			I string `json:"i"`

			// P The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			BidPrice float64 `json:"p"`

			// S The size of a trade (also known as volume).
			BidSize float64 `json:"s"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// X The exchange that this crypto trade happened on.
			// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
			BidExchange int `json:"x"`
		} `json:"ticks"`
	}
}

// Status returns HTTPResponse.Status
func (r DeprecatedGetHistoricCryptoTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedGetHistoricCryptoTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedGetHistoricForexQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Day The date that was evaluated from the request.
		Day openapi_types.Date `json:"day"`

		// Map A map for shortened result keys.
		Map map[string]interface{} `json:"map"`

		// MsLatency The milliseconds of latency for the query results.
		MsLatency int `json:"msLatency"`

		// Pair The currency pair that was evaluated from the request.
		Pair  string `json:"pair"`
		Ticks []struct {
			// A The ask price.
			A float64 `json:"a"`

			// B The bid price.
			B float64 `json:"b"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// X The exchange ID. See <a href="https://massive.com/docs/rest/forex/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			BidExchange int `json:"x"`
		} `json:"ticks"`
	}
}

// Status returns HTTPResponse.Status
func (r DeprecatedGetHistoricForexQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedGetHistoricForexQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoEMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the EMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoEMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoEMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexEMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the EMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexEMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexEMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesEMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the EMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIndicesEMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesEMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsEMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the EMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsEMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsEMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksEMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the EMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksEMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksEMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoMACDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the MACD indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
			Values *[]struct {
				// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
				Histogram *float32 `json:"histogram,omitempty"`

				// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
				Signal *float32 `json:"signal,omitempty"`

				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoMACDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoMACDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexMACDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the MACD indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
			Values *[]struct {
				// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
				Histogram *float32 `json:"histogram,omitempty"`

				// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
				Signal *float32 `json:"signal,omitempty"`

				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexMACDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexMACDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesMACDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the MACD indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
			Values *[]struct {
				// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
				Histogram *float32 `json:"histogram,omitempty"`

				// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
				Signal *float32 `json:"signal,omitempty"`

				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIndicesMACDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesMACDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsMACDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the MACD indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
			Values *[]struct {
				// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
				Histogram *float32 `json:"histogram,omitempty"`

				// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
				Signal *float32 `json:"signal,omitempty"`

				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsMACDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsMACDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksMACDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the MACD indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
			Values *[]struct {
				// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
				Histogram *float32 `json:"histogram,omitempty"`

				// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
				Signal *float32 `json:"signal,omitempty"`

				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksMACDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksMACDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoRSIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the RSI indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoRSIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoRSIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexRSIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the RSI indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexRSIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexRSIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesRSIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the RSI indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIndicesRSIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesRSIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsRSIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the RSI indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsRSIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsRSIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksRSIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the RSI indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksRSIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksRSIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoSMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the SMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoSMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoSMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexSMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the SMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexSMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexSMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesSMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the SMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIndicesSMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesSMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsSMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the SMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsSMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsSMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksSMAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results of the SMA indicator calculation.
		Results struct {
			// Underlying The underlying aggregates used.
			Underlying *struct {
				// Aggregates The array of aggregates used in the calculation of this indicator.
				Aggregates *[]struct {
					// C The close price for the symbol in the given time period.
					C float32 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float32 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float32 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float32 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix Msec timestamp for the start of the aggregate window.
					Timestamp float32 `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float32 `json:"v"`

					// Vw The volume weighted average price.
					Vw float32 `json:"vw"`
				} `json:"aggregates,omitempty"`

				// Url The URL which can be used to request the underlying aggregates used in this request.
				Url *string `json:"url,omitempty"`
			} `json:"underlying,omitempty"`

			// Values Timestamp or indicator value.
			Values *[]struct {
				// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
				Timestamp *int64 `json:"timestamp,omitempty"`

				// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
				Value *float32 `json:"value,omitempty"`
			} `json:"values,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksSMAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksSMAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastCryptoTradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Last Contains the requested trade data for the specified cryptocurrency pair.
		Last *struct {
			// Conditions A list of condition codes.
			Conditions *[]int32 `json:"conditions,omitempty"`

			// Exchange The exchange that this crypto trade happened on.
			// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
			Exchange int `json:"exchange"`

			// Price The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			Price float64 `json:"price"`

			// Size The size of a trade (also known as volume).
			Size float64 `json:"size"`

			// Timestamp The Unix millisecond timestamp.
			Timestamp int `json:"timestamp"`
		} `json:"last,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`

		// Symbol The symbol pair that was evaluated from the request.
		Symbol string `json:"symbol"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLastCryptoTradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastCryptoTradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastCurrencyQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Last Contains the requested quote data for the specified forex currency pair.
		Last *struct {
			// Ask The ask price.
			Ask float64 `json:"ask"`

			// Bid The bid price.
			Bid float64 `json:"bid"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/forex/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange int `json:"exchange"`

			// Timestamp The Unix millisecond timestamp.
			Timestamp int `json:"timestamp"`
		} `json:"last,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`

		// Symbol The symbol pair that was evaluated from the request.
		Symbol string `json:"symbol"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLastCurrencyQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastCurrencyQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AfterHours Whether or not the market is in post-market hours.
		AfterHours *bool `json:"afterHours,omitempty"`

		// Currencies Contains the status of various currency markets.
		Currencies *struct {
			// Crypto The status of the crypto market.
			Crypto *string `json:"crypto,omitempty"`

			// Fx The status of the forex market.
			Fx *string `json:"fx,omitempty"`
		} `json:"currencies,omitempty"`

		// EarlyHours Whether or not the market is in pre-market hours.
		EarlyHours *bool `json:"earlyHours,omitempty"`

		// Exchanges Contains the status of different US stock exchanges (e.g., Nasdaq, NYSE).
		Exchanges *struct {
			// Nasdaq The status of the Nasdaq market.
			Nasdaq *string `json:"nasdaq,omitempty"`

			// Nyse The status of the NYSE market.
			Nyse *string `json:"nyse,omitempty"`

			// Otc The status of the OTC market.
			Otc *string `json:"otc,omitempty"`
		} `json:"exchanges,omitempty"`

		// IndicesGroups Contains the status of various index groups (e.g., MSCI, FTSE Russell).
		IndicesGroups *struct {
			// Cccy The status of Cboe Streaming Market Indices Cryptocurrency ("CCCY") indices trading hours.
			Cccy *string `json:"cccy,omitempty"`

			// Cgi The status of Cboe Global Indices ("CGI") trading hours.
			Cgi *string `json:"cgi,omitempty"`

			// DowJones The status of Dow Jones indices trading hours
			DowJones *string `json:"dow_jones,omitempty"`

			// FtseRussell The status of Financial Times Stock Exchange Group ("FTSE") Russell indices trading hours.
			FtseRussell *string `json:"ftse_russell,omitempty"`

			// Msci The status of Morgan Stanley Capital International ("MSCI") indices trading hours.
			Msci *string `json:"msci,omitempty"`

			// Mstar The status of Morningstar ("MSTAR") indices trading hours.
			Mstar *string `json:"mstar,omitempty"`

			// Mstarc The status of Morningstar Customer ("MSTARC") indices trading hours.
			Mstarc *string `json:"mstarc,omitempty"`

			// Nasdaq The status of National Association of Securities Dealers Automated Quotations ("Nasdaq") indices trading hours.
			Nasdaq *string `json:"nasdaq,omitempty"`

			// SAndP The status of Standard & Poor's ("S&P") indices trading hours.
			SAndP *string `json:"s_and_p,omitempty"`

			// SocieteGenerale The status of Societe Generale indices trading hours.
			SocieteGenerale *string `json:"societe_generale,omitempty"`
		} `json:"indicesGroups,omitempty"`

		// Market The status of the market as a whole.
		Market *string `json:"market,omitempty"`

		// ServerTime The current time of the server, returned as a date-time in RFC3339 format.
		ServerTime *string `json:"serverTime,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMarketStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketHolidaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Close The market close time on the holiday (if it's not closed).
		Close *string `json:"close,omitempty"`

		// Date The date of the holiday.
		Date *string `json:"date,omitempty"`

		// Exchange Which market the record is for.
		Exchange *string `json:"exchange,omitempty"`

		// Name The name of the holiday.
		Name *string `json:"name,omitempty"`

		// Open The market open time on the holiday (if it's not closed).
		Open *string `json:"open,omitempty"`

		// Status The status of the market on the holiday.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMarketHolidaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketHolidaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoOpenCloseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Close The close price for the symbol in the given time period.
		Close float64 `json:"close"`

		// ClosingTrades An array of results containing the requested data.
		ClosingTrades []struct {
			// C A list of condition codes.
			C []int `json:"c"`

			// I The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			I string `json:"i"`

			// P The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			BidPrice float64 `json:"p"`

			// S The size of a trade (also known as volume).
			BidSize float64 `json:"s"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// X The exchange that this crypto trade happened on.
			// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
			BidExchange int `json:"x"`
		} `json:"closingTrades"`

		// Day The date requested.
		Day openapi_types.Date `json:"day"`

		// IsUTC Whether or not the timestamps are in UTC timezone.
		IsUTC bool `json:"isUTC"`

		// Open The open price for the symbol in the given time period.
		Open float64 `json:"open"`

		// OpenTrades An array of results containing the requested data.
		OpenTrades []struct {
			// C A list of condition codes.
			C []int `json:"c"`

			// I The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			I string `json:"i"`

			// P The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			BidPrice float64 `json:"p"`

			// S The size of a trade (also known as volume).
			BidSize float64 `json:"s"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// X The exchange that this crypto trade happened on.
			// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
			BidExchange int `json:"x"`
		} `json:"openTrades"`

		// Symbol The symbol pair that was evaluated from the request.
		Symbol string `json:"symbol"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoOpenCloseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoOpenCloseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesOpenCloseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AfterHours The close value of the ticker symbol in after hours trading.
		AfterHours *float64 `json:"afterHours,omitempty"`

		// Close The close value for the symbol in the given time period.
		Close float64 `json:"close"`

		// From The requested date.
		From openapi_types.Date `json:"from"`

		// High The highest value for the symbol in the given time period.
		High float64 `json:"high"`

		// Low The lowest value for the symbol in the given time period.
		Low float64 `json:"low"`

		// Open The open value for the symbol in the given time period.
		Open float64 `json:"open"`

		// PreMarket The open value of the ticker symbol in pre-market trading.
		PreMarket *int `json:"preMarket,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`

		// Symbol The exchange symbol that this item is traded under.
		Symbol string `json:"symbol"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIndicesOpenCloseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesOpenCloseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsOpenCloseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AfterHours The close price of the ticker symbol in after hours trading.
		AfterHours *float64 `json:"afterHours,omitempty"`

		// Close The close price for the symbol in the given time period.
		Close float64 `json:"close"`

		// From The requested date.
		From openapi_types.Date `json:"from"`

		// High The highest price for the symbol in the given time period.
		High float64 `json:"high"`

		// Low The lowest price for the symbol in the given time period.
		Low float64 `json:"low"`

		// Open The open price for the symbol in the given time period.
		Open float64 `json:"open"`

		// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
		Otc *bool `json:"otc,omitempty"`

		// PreMarket The open price of the ticker symbol in pre-market trading.
		PreMarket *int `json:"preMarket,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`

		// Symbol The exchange symbol that this item is traded under.
		Symbol string `json:"symbol"`

		// Volume The trading volume of the symbol in the given time period.
		Volume float64 `json:"volume"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsOpenCloseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsOpenCloseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksOpenCloseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AfterHours The close price of the ticker symbol in after hours trading.
		AfterHours *float64 `json:"afterHours,omitempty"`

		// Close The close price for the symbol in the given time period.
		Close float64 `json:"close"`

		// From The requested date.
		From openapi_types.Date `json:"from"`

		// High The highest price for the symbol in the given time period.
		High float64 `json:"high"`

		// Low The lowest price for the symbol in the given time period.
		Low float64 `json:"low"`

		// Open The open price for the symbol in the given time period.
		Open float64 `json:"open"`

		// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
		Otc *bool `json:"otc,omitempty"`

		// PreMarket The open price of the ticker symbol in pre-market trading.
		PreMarket *int `json:"preMarket,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`

		// Symbol The exchange symbol that this item is traded under.
		Symbol string `json:"symbol"`

		// Volume The trading volume of the symbol in the given time period.
		Volume float64 `json:"volume"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksOpenCloseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksOpenCloseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV1ReferenceIposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results The results for this request.
		Results []struct {
			// AnnouncedDate The date when the IPO event was announced.
			AnnouncedDate *int64 `json:"announced_date,omitempty"`

			// CurrencyCode Underlying currency of the security.
			CurrencyCode *string `json:"currency_code,omitempty"`

			// FinalIssuePrice The price set by the company and its underwriters before the IPO goes live.
			FinalIssuePrice *float64 `json:"final_issue_price,omitempty"`

			// HighestOfferPrice The highest price within the IPO price range that the company might use to price the shares.
			HighestOfferPrice *float64 `json:"highest_offer_price,omitempty"`

			// IpoStatus The status of the IPO.
			IpoStatus *string `json:"ipo_status,omitempty"`

			// Isin International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
			Isin *string `json:"isin,omitempty"`

			// IssuerName Name of issuer.
			IssuerName *string `json:"issuer_name,omitempty"`

			// LastUpdated The date when the IPO event was last modified.
			LastUpdated *int64 `json:"last_updated,omitempty"`

			// ListingDate First trading date for the newly listed entity.
			ListingDate *int64 `json:"listing_date,omitempty"`

			// LotSize The minimum number of shares that an investor may apply for during an IPO.
			LotSize *int64 `json:"lot_size,omitempty"`

			// LowestOfferPrice The lowest price within the IPO price range that the company is willing to offer its shares to investors.
			LowestOfferPrice *float64 `json:"lowest_offer_price,omitempty"`

			// MaxSharesOffered The upper limit of the shares that the company is offering to investors.
			MaxSharesOffered *int64 `json:"max_shares_offered,omitempty"`

			// MinSharesOffered The lower limit of shares that the company is willing to sell in the IPO.
			MinSharesOffered *int64 `json:"min_shares_offered,omitempty"`

			// PrimaryExchange Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
			PrimaryExchange *string `json:"primary_exchange,omitempty"`

			// SecurityDescription A brief description of the security. e.g. Class A Shares
			SecurityDescription *string `json:"security_description,omitempty"`

			// SecurityType The classification of the stock. For example, CS stands for Common Stock.
			SecurityType *string `json:"security_type,omitempty"`

			// SharesOutstanding The total number of shares that the company has issued and are held by investors.
			SharesOutstanding *int64 `json:"shares_outstanding,omitempty"`

			// Ticker The ticker symbol of the IPO event.
			Ticker *string `json:"ticker,omitempty"`

			// TotalOfferSize The total amount raised by the company for IPO.
			TotalOfferSize *float64 `json:"total_offer_size,omitempty"`

			// UsCode Nine-character alphanumeric code that uniquely identifies a financial security in North America.
			UsCode *string `json:"us_code,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status GetV1ReferenceIpos200Status `json:"status"`
	}
	JSON400 *struct {
		// Error A message describing the source of the error.
		Error string `json:"error"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status GetV1ReferenceIpos400Status `json:"status"`
	}
}
type GetV1ReferenceIpos200Status string
type GetV1ReferenceIpos400Status string

// Status returns HTTPResponse.Status
func (r GetV1ReferenceIposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV1ReferenceIposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRelatedCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// Ticker A ticker related to the requested ticker.
			Ticker string `json:"ticker"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`

		// Ticker The ticker being queried.
		Ticker *string `json:"ticker,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRelatedCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRelatedCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSnapshotSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			Branding *struct {
				// IconUrl A link to this ticker's company's icon. Icon's are generally smaller, square images that represent the company at a glance.
				// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
				IconUrl *string `json:"icon_url,omitempty"`

				// LogoUrl A link to this ticker's company's logo.
				// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
				LogoUrl *string `json:"logo_url,omitempty"`
			} `json:"branding,omitempty"`

			// Error The error while looking for this ticker.
			Error *string `json:"error,omitempty"`

			// LastUpdated The nanosecond timestamp of when this information was updated.
			LastUpdated *int64 `json:"last_updated,omitempty"`

			// MarketStatus The market status for the market that trades this ticker.
			MarketStatus *string `json:"market_status,omitempty"`

			// Message The error message while looking for this ticker.
			Message *string `json:"message,omitempty"`

			// Name Name of ticker, forex, or crypto asset.
			Name    *string `json:"name,omitempty"`
			Options *struct {
				// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
				ContractType GetSnapshotSummary200ResultsOptionsContractType `json:"contract_type"`

				// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
				ExerciseStyle GetSnapshotSummary200ResultsOptionsExerciseStyle `json:"exercise_style"`

				// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
				ExpirationDate openapi_types.Date `json:"expiration_date"`

				// SharesPerContract The number of shares per contract for this contract.
				SharesPerContract float64 `json:"shares_per_contract"`

				// StrikePrice The strike price of the option contract.
				StrikePrice float64 `json:"strike_price"`

				// UnderlyingTicker The ticker for the option contract.
				UnderlyingTicker string `json:"underlying_ticker"`
			} `json:"options,omitempty"`

			// Price The most up to date ticker price.
			Price *float64 `json:"price,omitempty"`

			// Session Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
			Session *struct {
				// Change The value of the price change for the asset from the previous trading day.
				Change float64 `json:"change"`

				// ChangePercent The percent of the price change for the asset from the previous trading day.
				ChangePercent float64 `json:"change_percent"`

				// Close The closing price of the asset for the day.
				Close float64 `json:"close"`

				// DecimalVolume The trading volume for the asset for the day with decimal precision. This field provides support for fractional shares, representing volume as a decimal string. This field is only returned for stocks snapshots.
				DecimalVolume *string `json:"decimal_volume,omitempty"`

				// EarlyTradingChange Today's early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
				EarlyTradingChange *float64 `json:"early_trading_change,omitempty"`

				// EarlyTradingChangePercent Today's early trading change as a percentage.
				EarlyTradingChangePercent *float64 `json:"early_trading_change_percent,omitempty"`

				// High The highest price of the asset for the day.
				High float64 `json:"high"`

				// LateTradingChange Today's late trading change amount, difference between price and today's close if in late trading hours, otherwise difference between last price during late trading and today's close.
				LateTradingChange *float64 `json:"late_trading_change,omitempty"`

				// LateTradingChangePercent Today's late trading change as a percentage.
				LateTradingChangePercent *float64 `json:"late_trading_change_percent,omitempty"`

				// Low The lowest price of the asset for the day.
				Low float64 `json:"low"`

				// Open The open price of the asset for the day.
				Open float64 `json:"open"`

				// PreviousClose The closing price of the asset for the previous trading day.
				PreviousClose float64 `json:"previous_close"`

				// Price The price of the most recent trade or bid price for this asset.
				Price *float64 `json:"price,omitempty"`

				// RegularTradingChange Today's change in regular trading hours, difference between current price and previous trading day's close, otherwise difference between today's close and previous day's close.
				RegularTradingChange *float64 `json:"regular_trading_change,omitempty"`

				// RegularTradingChangePercent Today's regular trading change as a percentage.
				RegularTradingChangePercent *float64 `json:"regular_trading_change_percent,omitempty"`

				// Volume The trading volume for the asset for the day.
				Volume *float64 `json:"volume,omitempty"`
			} `json:"session,omitempty"`

			// Ticker Ticker of asset queried.
			Ticker string `json:"ticker"`

			// Type The market for this ticker of stock, crypto, fx, option.
			Type *GetSnapshotSummary200ResultsType `json:"type,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type GetSnapshotSummary200ResultsOptionsContractType string
type GetSnapshotSummary200ResultsOptionsExerciseStyle string
type GetSnapshotSummary200ResultsType string

// Status returns HTTPResponse.Status
func (r GetSnapshotSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSnapshotSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupedCryptoAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the end of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupedCryptoAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupedCryptoAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupedForexAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the end of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupedForexAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupedForexAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupedStocksAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
			Otc *bool `json:"otc,omitempty"`

			// T The Unix millisecond timestamp for the end of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupedStocksAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupedStocksAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreviousCryptoAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the end of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPreviousCryptoAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreviousCryptoAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreviousForexAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPreviousForexAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreviousForexAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreviousIndicesAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close value for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest value for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest value for the symbol in the given time period.
			L float64 `json:"l"`

			// O The open value for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPreviousIndicesAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreviousIndicesAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close value for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest value for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest value for the symbol in the given time period.
			L float64 `json:"l"`

			// O The open value for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIndicesAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreviousOptionsAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPreviousOptionsAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreviousOptionsAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreviousStocksAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPreviousStocksAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreviousStocksAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksAggregatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Ticker The exchange symbol that this item is traded under.
		Ticker string `json:"ticker"`
		// Embedded fields due to inline allOf schema
		// Adjusted Whether or not this response was adjusted for splits.
		Adjusted bool `json:"adjusted"`

		// QueryCount The number of aggregates (minute or day) used to generate the response.
		QueryCount int `json:"queryCount"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// ResultsCount The total number of results for this request.
		ResultsCount int `json:"resultsCount"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Results An array of results containing the requested data.
		Results *[]struct {
			// C The close price for the symbol in the given time period.
			C float64 `json:"c"`

			// H The highest price for the symbol in the given time period.
			H float64 `json:"h"`

			// L The lowest price for the symbol in the given time period.
			L float64 `json:"l"`

			// N The number of transactions in the aggregate window.
			N *int `json:"n,omitempty"`

			// O The open price for the symbol in the given time period.
			O float64 `json:"o"`

			// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
			Otc *bool `json:"otc,omitempty"`

			// T The Unix millisecond timestamp for the start of the aggregate window.
			Timestamp int `json:"t"`

			// V The trading volume of the symbol in the given time period.
			V float64 `json:"v"`

			// Vw The volume weighted average price.
			Vw *float64 `json:"vw,omitempty"`
		} `json:"results,omitempty"`
		// Embedded fields due to inline allOf schema
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksAggregatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksAggregatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastStocksQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`
		Results   *struct {
			// P The ask price.
			AskPrice *float64 `json:"P,omitempty"`

			// S The total number of shares available for sale at the current ask price.
			AskSize *int `json:"S,omitempty"`

			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			AskExchange *int `json:"X,omitempty"`

			// C A list of condition codes.
			C *[]int32 `json:"c,omitempty"`

			// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
			F *int `json:"f,omitempty"`

			// I A list of indicator codes.
			I *[]int32 `json:"i,omitempty"`

			// P The bid price.
			BidPrice *float64 `json:"p,omitempty"`

			// Q The sequence number represents the sequence in which message events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11).
			Q int64 `json:"q"`

			// S The total number of shares that buyers want to purchase at the current bid price.
			BidSize *int `json:"s,omitempty"`

			// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
			Timestamp int `json:"t"`

			// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			BidExchange *int `json:"x,omitempty"`

			// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			Y int `json:"y"`

			// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Z *int `json:"z,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLastStocksQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastStocksQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastOptionsTradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`
		Results   *struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C A list of condition codes.
			C *[]int32 `json:"c,omitempty"`

			// E The trade correction indicator.
			E *int `json:"e,omitempty"`

			// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
			F *int `json:"f,omitempty"`

			// I The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			I string `json:"i"`

			// P The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			BidPrice float64 `json:"p"`

			// Q The sequence number represents the sequence in which message events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11).
			Q int64 `json:"q"`

			// R The ID for the Trade Reporting Facility where the trade took place.
			R *int `json:"r,omitempty"`

			// S The size of a trade (also known as volume).
			BidSize *float64 `json:"s,omitempty"`

			// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
			Timestamp int `json:"t"`

			// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			BidExchange int `json:"x"`

			// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			Y int `json:"y"`

			// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Z *int `json:"z,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLastOptionsTradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastOptionsTradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastStocksTradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`
		Results   *struct {
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// C A list of condition codes.
			C *[]int32 `json:"c,omitempty"`

			// Ds The size of the trade including the fractional component. This is represented as a decimal string.
			Ds string `json:"ds"`

			// E The trade correction indicator.
			E *int `json:"e,omitempty"`

			// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
			F *int `json:"f,omitempty"`

			// I The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			I string `json:"i"`

			// P The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			BidPrice float64 `json:"p"`

			// Q The sequence number represents the sequence in which message events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11).
			Q int64 `json:"q"`

			// R The ID for the Trade Reporting Facility where the trade took place.
			R *int `json:"r,omitempty"`

			// S The size of a trade (also known as volume).
			BidSize *float64 `json:"s,omitempty"`

			// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
			Timestamp int `json:"t"`

			// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			BidExchange int `json:"x"`

			// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			Y int `json:"y"`

			// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Z *int `json:"z,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLastStocksTradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastStocksTradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AmpUrl The mobile friendly Accelerated Mobile Page (AMP) URL.
			AmpUrl *string `json:"amp_url,omitempty"`

			// ArticleUrl A link to the news article.
			ArticleUrl string `json:"article_url"`

			// Author The article's author.
			Author string `json:"author"`

			// Description A description of the article.
			Description *string `json:"description,omitempty"`

			// Id Unique identifier for the article.
			Id string `json:"id"`

			// ImageUrl The article's image URL.
			ImageUrl *string `json:"image_url,omitempty"`

			// Insights The insights related to the article.
			Insights *[]struct {
				// Sentiment The sentiment of the insight.
				Sentiment ListNews200ResultsInsightsSentiment `json:"sentiment"`

				// SentimentReasoning The reasoning behind the sentiment.
				SentimentReasoning string `json:"sentiment_reasoning"`

				// Ticker The ticker symbol associated with the insight.
				Ticker string `json:"ticker"`
			} `json:"insights,omitempty"`

			// Keywords The keywords associated with the article (which will vary depending on
			// the publishing source).
			Keywords *[]string `json:"keywords,omitempty"`

			// PublishedUtc The UTC date and time when the article was published, formatted in RFC3339 standard (e.g. YYYY-MM-DDTHH:MM:SSZ).
			PublishedUtc time.Time `json:"published_utc"`

			// Publisher Details the source of the news article, including the publisher's name, logo, and homepage URLs. This information helps users identify and access the original source of news content.
			Publisher struct {
				// FaviconUrl The publisher's homepage favicon URL.
				FaviconUrl *string `json:"favicon_url,omitempty"`

				// HomepageUrl The publisher's homepage URL.
				HomepageUrl string `json:"homepage_url"`

				// LogoUrl The publisher's logo URL.
				LogoUrl string `json:"logo_url"`

				// Name The publisher's name.
				Name string `json:"name"`
			} `json:"publisher"`

			// Tickers The ticker symbols associated with the article.
			Tickers []string `json:"tickers"`

			// Title The title of the news article.
			Title string `json:"title"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type ListNews200ResultsInsightsSentiment string

// Status returns HTTPResponse.Status
func (r ListNewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoSnapshotTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Tickers An array of snapshot data for the specified tickers.
		Tickers *[]struct {
			// Day The most recent daily bar for this ticker.
			Day struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"day"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastTrade The most recent trade for this ticker.
			LastTrade struct {
				// C The trade conditions.
				C []int `json:"c"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size (volume) of the trade.
				BidSize float32 `json:"s"`

				// T The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
				Timestamp int `json:"t"`

				// X The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				BidExchange int `json:"x"`
			} `json:"lastTrade"`

			// Min The most recent minute bar for this ticker.
			Min struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N int `json:"n"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"min"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange float64 `json:"todaysChange"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc float64 `json:"todaysChangePerc"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"tickers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoSnapshotTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoSnapshotTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoSnapshotTickerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`
		// Embedded fields due to inline allOf schema
		// Ticker Contains the requested snapshot data for the specified ticker.
		Ticker *struct {
			// Day The most recent daily bar for this ticker.
			Day struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"day"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastTrade The most recent trade for this ticker.
			LastTrade struct {
				// C The trade conditions.
				C []int `json:"c"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size (volume) of the trade.
				BidSize float32 `json:"s"`

				// T The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
				Timestamp int `json:"t"`

				// X The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				BidExchange int `json:"x"`
			} `json:"lastTrade"`

			// Min The most recent minute bar for this ticker.
			Min struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N int `json:"n"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"min"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange float64 `json:"todaysChange"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc float64 `json:"todaysChangePerc"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"ticker,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoSnapshotTickerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoSnapshotTickerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedGetCryptoSnapshotTickerBookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		Data *struct {
			// AskCount The combined total number of asks in the book.
			AskCount float64 `json:"askCount"`
			Asks     []struct {
				// P The price of this book level.
				BidPrice float64 `json:"p"`

				// X A map of the exchange ID to number of shares at this price level.
				// <br />
				// <br />
				// **Example:**
				// <br />
				// `{
				//   "p": 16302.94,
				//   "x": {
				//     "1": 0.02859424,
				//     "6": 0.023455
				//   }
				// }`
				// <br />
				// <br />
				// In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94,
				// and exchange ID 6 has 0.023455 shares at the same price level.
				BidExchange map[string]interface{} `json:"x"`
			} `json:"asks"`

			// BidCount The combined total number of bids in the book.
			BidCount float64 `json:"bidCount"`
			Bids     []struct {
				// P The price of this book level.
				BidPrice float64 `json:"p"`

				// X A map of the exchange ID to number of shares at this price level.
				// <br />
				// <br />
				// **Example:**
				// <br />
				// `{
				//   "p": 16302.94,
				//   "x": {
				//     "1": 0.02859424,
				//     "6": 0.023455
				//   }
				// }`
				// <br />
				// <br />
				// In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94,
				// and exchange ID 6 has 0.023455 shares at the same price level.
				BidExchange map[string]interface{} `json:"x"`
			} `json:"bids"`

			// Spread The difference between the best bid and the best ask price across exchanges.
			Spread float64 `json:"spread"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeprecatedGetCryptoSnapshotTickerBookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedGetCryptoSnapshotTickerBookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoSnapshotDirectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		// Tickers An array of snapshot data for the specified tickers.
		Tickers *[]struct {
			// Day The most recent daily bar for this ticker.
			Day struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"day"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastTrade The most recent trade for this ticker.
			LastTrade struct {
				// C The trade conditions.
				C []int `json:"c"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size (volume) of the trade.
				BidSize float32 `json:"s"`

				// T The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
				Timestamp int `json:"t"`

				// X The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				BidExchange int `json:"x"`
			} `json:"lastTrade"`

			// Min The most recent minute bar for this ticker.
			Min struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N int `json:"n"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"min"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange float64 `json:"todaysChange"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc float64 `json:"todaysChangePerc"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"tickers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoSnapshotDirectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoSnapshotDirectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexSnapshotTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Tickers An array of snapshot data for the specified tickers.
		Tickers *[]struct {
			// Day The most recent daily bar for this ticker.
			Day struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`
			} `json:"day"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastQuote The most recent quote for this ticker.
			LastQuote struct {
				// A The ask price.
				A float64 `json:"a"`

				// B The bid price.
				B float64 `json:"b"`

				// T The millisecond accuracy timestamp of the quote.
				Timestamp int `json:"t"`

				// X The exchange ID on which this quote happened.
				BidExchange int `json:"x"`
			} `json:"lastQuote"`

			// Min The most recent minute bar for this ticker.
			Min struct {
				// C The close price for the symbol in the given time period.
				C *float64 `json:"c,omitempty"`

				// H The highest price for the symbol in the given time period.
				H *float64 `json:"h,omitempty"`

				// L The lowest price for the symbol in the given time period.
				L *float64 `json:"l,omitempty"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O *float64 `json:"o,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp *int `json:"t,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V *float64 `json:"v,omitempty"`
			} `json:"min"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange float64 `json:"todaysChange"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc float64 `json:"todaysChangePerc"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"tickers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexSnapshotTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexSnapshotTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexSnapshotTickerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`
		// Embedded fields due to inline allOf schema
		// Ticker Contains the requested snapshot data for the specified ticker.
		Ticker *struct {
			// Day The most recent daily bar for this ticker.
			Day struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`
			} `json:"day"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastQuote The most recent quote for this ticker.
			LastQuote struct {
				// A The ask price.
				A float64 `json:"a"`

				// B The bid price.
				B float64 `json:"b"`

				// T The millisecond accuracy timestamp of the quote.
				Timestamp int `json:"t"`

				// X The exchange ID on which this quote happened.
				BidExchange int `json:"x"`
			} `json:"lastQuote"`

			// Min The most recent minute bar for this ticker.
			Min struct {
				// C The close price for the symbol in the given time period.
				C *float64 `json:"c,omitempty"`

				// H The highest price for the symbol in the given time period.
				H *float64 `json:"h,omitempty"`

				// L The lowest price for the symbol in the given time period.
				L *float64 `json:"l,omitempty"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O *float64 `json:"o,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp *int `json:"t,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V *float64 `json:"v,omitempty"`
			} `json:"min"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange float64 `json:"todaysChange"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc float64 `json:"todaysChangePerc"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"ticker,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexSnapshotTickerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexSnapshotTickerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexSnapshotDirectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Tickers An array of snapshot data for the specified tickers.
		Tickers *[]struct {
			// Day The most recent daily bar for this ticker.
			Day struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`
			} `json:"day"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastQuote The most recent quote for this ticker.
			LastQuote struct {
				// A The ask price.
				A float64 `json:"a"`

				// B The bid price.
				B float64 `json:"b"`

				// T The millisecond accuracy timestamp of the quote.
				Timestamp int `json:"t"`

				// X The exchange ID on which this quote happened.
				BidExchange int `json:"x"`
			} `json:"lastQuote"`

			// Min The most recent minute bar for this ticker.
			Min struct {
				// C The close price for the symbol in the given time period.
				C *float64 `json:"c,omitempty"`

				// H The highest price for the symbol in the given time period.
				H *float64 `json:"h,omitempty"`

				// L The lowest price for the symbol in the given time period.
				L *float64 `json:"l,omitempty"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O *float64 `json:"o,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp *int `json:"t,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V *float64 `json:"v,omitempty"`
			} `json:"min"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange float64 `json:"todaysChange"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc float64 `json:"todaysChangePerc"`

			// Updated The last updated timestamp.
			Updated int `json:"updated"`
		} `json:"tickers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexSnapshotDirectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexSnapshotDirectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksSnapshotTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Tickers An array of snapshot data for the specified tickers.
		Tickers *[]struct {
			// Day The most recent daily bar for this ticker.
			Day *struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// Dv The volume including fractional shares, respresented as a string.
				Dv *string `json:"dv,omitempty"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"day,omitempty"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastQuote The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
			LastQuote *struct {
				// P The ask price.
				AskPrice float64 `json:"P"`

				// S The ask size in lots.
				AskSize int `json:"S"`

				// P The bid price.
				BidPrice float64 `json:"p"`

				// S The bid size in lots.
				BidSize int `json:"s"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`
			} `json:"lastQuote,omitempty"`

			// LastTrade The most recent trade for this ticker.  This is only returned if your current plan includes trades.
			LastTrade *struct {
				// C The trade conditions.
				C []int `json:"c"`

				// Ds The size of the trade including fractional shares, respresented as a string.
				Ds string `json:"ds"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size (volume) of the trade.
				BidSize int `json:"s"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`
			} `json:"lastTrade,omitempty"`

			// Min The most recent minute bar for this ticker.
			Min *struct {
				// Av The accumulated volume.
				Av int `json:"av"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// Dav The accumulated volume including fractional shares, respresented as a string.
				Dav string `json:"dav"`

				// Dv The volume including fractional shares, respresented as a string.
				Dv *string `json:"dv,omitempty"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N int `json:"n"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"min,omitempty"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay *struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker *string `json:"ticker,omitempty"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange *float64 `json:"todaysChange,omitempty"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc *float64 `json:"todaysChangePerc,omitempty"`

			// Updated The last updated timestamp.
			Updated *int `json:"updated,omitempty"`
		} `json:"tickers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksSnapshotTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksSnapshotTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksSnapshotTickerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`
		// Embedded fields due to inline allOf schema
		// Ticker Contains the requested snapshot data for the specified ticker.
		Ticker *struct {
			// Day The most recent daily bar for this ticker.
			Day *struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// Dv The volume including fractional shares, respresented as a string.
				Dv *string `json:"dv,omitempty"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"day,omitempty"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastQuote The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
			LastQuote *struct {
				// P The ask price.
				AskPrice float64 `json:"P"`

				// S The ask size in lots.
				AskSize int `json:"S"`

				// P The bid price.
				BidPrice float64 `json:"p"`

				// S The bid size in lots.
				BidSize int `json:"s"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`
			} `json:"lastQuote,omitempty"`

			// LastTrade The most recent trade for this ticker.  This is only returned if your current plan includes trades.
			LastTrade *struct {
				// C The trade conditions.
				C []int `json:"c"`

				// Ds The size of the trade including fractional shares, respresented as a string.
				Ds string `json:"ds"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size (volume) of the trade.
				BidSize int `json:"s"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`
			} `json:"lastTrade,omitempty"`

			// Min The most recent minute bar for this ticker.
			Min *struct {
				// Av The accumulated volume.
				Av int `json:"av"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// Dav The accumulated volume including fractional shares, respresented as a string.
				Dav string `json:"dav"`

				// Dv The volume including fractional shares, respresented as a string.
				Dv *string `json:"dv,omitempty"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N int `json:"n"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"min,omitempty"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay *struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker *string `json:"ticker,omitempty"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange *float64 `json:"todaysChange,omitempty"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc *float64 `json:"todaysChangePerc,omitempty"`

			// Updated The last updated timestamp.
			Updated *int `json:"updated,omitempty"`
		} `json:"ticker,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksSnapshotTickerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksSnapshotTickerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksSnapshotDirectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// Status The status of this request's response.
		Status string `json:"status"`
		// Embedded fields due to inline allOf schema
		// Tickers An array of snapshot data for the specified tickers.
		Tickers *[]struct {
			// Day The most recent daily bar for this ticker.
			Day *struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// Dv The volume including fractional shares, respresented as a string.
				Dv *string `json:"dv,omitempty"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"day,omitempty"`

			// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float64 `json:"fmv,omitempty"`

			// LastQuote The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
			LastQuote *struct {
				// P The ask price.
				AskPrice float64 `json:"P"`

				// S The ask size in lots.
				AskSize int `json:"S"`

				// P The bid price.
				BidPrice float64 `json:"p"`

				// S The bid size in lots.
				BidSize int `json:"s"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`
			} `json:"lastQuote,omitempty"`

			// LastTrade The most recent trade for this ticker.  This is only returned if your current plan includes trades.
			LastTrade *struct {
				// C The trade conditions.
				C []int `json:"c"`

				// Ds The size of the trade including fractional shares, respresented as a string.
				Ds string `json:"ds"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size (volume) of the trade.
				BidSize int `json:"s"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`
			} `json:"lastTrade,omitempty"`

			// Min The most recent minute bar for this ticker.
			Min *struct {
				// Av The accumulated volume.
				Av int `json:"av"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// Dav The accumulated volume including fractional shares, respresented as a string.
				Dav string `json:"dav"`

				// Dv The volume including fractional shares, respresented as a string.
				Dv *string `json:"dv,omitempty"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N int `json:"n"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"min,omitempty"`

			// PrevDay The previous day's bar for this ticker.
			PrevDay *struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw float64 `json:"vw"`
			} `json:"prevDay,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker *string `json:"ticker,omitempty"`

			// TodaysChange The value of the change from the previous day.
			TodaysChange *float64 `json:"todaysChange,omitempty"`

			// TodaysChangePerc The percentage change since the previous day.
			TodaysChangePerc *float64 `json:"todaysChangePerc,omitempty"`

			// Updated The last updated timestamp.
			Updated *int `json:"updated,omitempty"`
		} `json:"tickers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksSnapshotDirectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksSnapshotDirectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedGetHistoricStocksQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// DbLatency Latency in milliseconds for the query results from the database.
		DbLatency *int `json:"db_latency,omitempty"`

		// ResultsCount The total number of results for this request.
		ResultsCount *int `json:"results_count,omitempty"`

		// Success Whether or not this query was executed successfully.
		Success *bool `json:"success,omitempty"`

		// Ticker The exchange symbol that this item is traded under.
		Ticker *string `json:"ticker,omitempty"`
		// Embedded fields due to inline allOf schema
		Results *[]struct {
			// Embedded fields due to inline allOf schema
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
			F int `json:"f"`

			// Q The sequence number represents the sequence in which message events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11).
			Q int64 `json:"q"`

			// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
			Timestamp int `json:"t"`

			// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			Y int `json:"y"`
			// Embedded fields due to inline allOf schema
			// P The ask price.
			AskPrice float64 `json:"P"`

			// S The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
			AskSize int `json:"S"`

			// X The ask exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			AskExchange int `json:"X"`

			// C A list of condition codes.
			C []int `json:"c"`

			// I The indicators. For more information, see our glossary of [Conditions and
			// Indicators](https://massive.com/glossary/conditions-indicators).
			I []int `json:"i"`

			// P The bid price.
			BidPrice float64 `json:"p"`

			// S The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
			BidSize int `json:"s"`

			// X The bid exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			BidExchange int `json:"x"`

			// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Z int `json:"z"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeprecatedGetHistoricStocksQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedGetHistoricStocksQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedGetHistoricStocksTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema
		// DbLatency Latency in milliseconds for the query results from the database.
		DbLatency *int `json:"db_latency,omitempty"`

		// ResultsCount The total number of results for this request.
		ResultsCount *int `json:"results_count,omitempty"`

		// Success Whether or not this query was executed successfully.
		Success *bool `json:"success,omitempty"`

		// Ticker The exchange symbol that this item is traded under.
		Ticker *string `json:"ticker,omitempty"`
		// Embedded fields due to inline allOf schema
		Results *[]struct {
			// Embedded fields due to inline allOf schema
			// T The exchange symbol that this item is traded under.
			Ticker string `json:"T"`

			// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
			F int `json:"f"`

			// Q The sequence number represents the sequence in which message events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11).
			Q int64 `json:"q"`

			// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
			Timestamp int `json:"t"`

			// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			Y int `json:"y"`
			// Embedded fields due to inline allOf schema
			// C A list of condition codes.
			C []int `json:"c"`

			// E The trade correction indicator.
			E int `json:"e"`

			// I The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			I string `json:"i"`

			// P The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			BidPrice float64 `json:"p"`

			// R The ID for the Trade Reporting Facility where the trade took place.
			R int `json:"r"`

			// S The size of a trade (also known as volume).
			BidSize float64 `json:"s"`

			// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			BidExchange int `json:"x"`

			// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Z int `json:"z"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeprecatedGetHistoricStocksTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedGetHistoricStocksTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForexQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AskExchange The ask exchange ID
			AskExchange *int `json:"ask_exchange,omitempty"`

			// AskPrice The ask price.
			AskPrice *float64 `json:"ask_price,omitempty"`

			// BidExchange The bid exchange ID
			BidExchange *int `json:"bid_exchange,omitempty"`

			// BidPrice The bid price.
			BidPrice *float64 `json:"bid_price,omitempty"`

			// ParticipantTimestamp The nanosecond Exchange Unix Timestamp. This is the timestamp of when the quote was generated at the exchange.
			ParticipantTimestamp int64 `json:"participant_timestamp"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForexQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForexQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AskExchange The ask exchange ID
			AskExchange *int `json:"ask_exchange,omitempty"`

			// AskPrice The ask price.
			AskPrice *float64 `json:"ask_price,omitempty"`

			// AskSize The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
			AskSize *float64 `json:"ask_size,omitempty"`

			// BidExchange The bid exchange ID
			BidExchange *int `json:"bid_exchange,omitempty"`

			// BidPrice The bid price.
			BidPrice *float64 `json:"bid_price,omitempty"`

			// BidSize The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
			BidSize *float64 `json:"bid_size,omitempty"`

			// SequenceNumber The sequence number represents the sequence in which quote events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11).
			SequenceNumber int64 `json:"sequence_number"`

			// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
			SipTimestamp int64 `json:"sip_timestamp"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AskExchange The ask exchange ID
			AskExchange *int `json:"ask_exchange,omitempty"`

			// AskPrice The ask price.
			AskPrice *float64 `json:"ask_price,omitempty"`

			// AskSize The total number of shares available for sale at the current ask price.
			AskSize *float64 `json:"ask_size,omitempty"`

			// BidExchange The bid exchange ID
			BidExchange *int `json:"bid_exchange,omitempty"`

			// BidPrice The bid price.
			BidPrice *float64 `json:"bid_price,omitempty"`

			// BidSize The total number of shares that buyers want to purchase at the current bid price.
			BidSize *float64 `json:"bid_size,omitempty"`

			// Conditions A list of condition codes.
			Conditions *[]int32 `json:"conditions,omitempty"`

			// Indicators A list of indicator codes.
			Indicators *[]int32 `json:"indicators,omitempty"`

			// ParticipantTimestamp The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
			ParticipantTimestamp int64 `json:"participant_timestamp"`

			// SequenceNumber The sequence number represents the sequence in which quote events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
			SequenceNumber int64 `json:"sequence_number"`

			// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
			SipTimestamp int64 `json:"sip_timestamp"`

			// Tape There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Tape *int32 `json:"tape,omitempty"`

			// TrfTimestamp The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
			TrfTimestamp *int64 `json:"trf_timestamp,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count int `json:"count"`

		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of conditions that match your query.
		Results []struct {
			// Abbreviation A commonly-used abbreviation for this condition.
			Abbreviation *string `json:"abbreviation,omitempty"`

			// AssetClass An identifier for a group of similar financial instruments.
			AssetClass ListConditions200ResultsAssetClass `json:"asset_class"`

			// DataTypes Data types that this condition applies to.
			DataTypes []ListConditions200ResultsDataTypes `json:"data_types"`

			// Description A short description of the semantics of this condition.
			Description *string `json:"description,omitempty"`

			// Exchange If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute.
			// In other words, data with this condition attached comes exclusively from the given exchange.
			Exchange *int `json:"exchange,omitempty"`

			// Id An identifier used by Massive for this condition. Unique per data type.
			Id int `json:"id"`

			// Legacy If true, this condition is from an old version of the SIPs' specs and no longer is used.
			// Other conditions may or may not reuse the same symbol as this one.
			Legacy *bool `json:"legacy,omitempty"`

			// Name The name of this condition.
			Name string `json:"name"`

			// SipMapping A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
			SipMapping struct {
				// CTA Condition code from the Consolidated Tape Association (CTA).
				CTA *string `json:"CTA,omitempty"`

				// OPRA Condition code from the Options Price Reporting Authority (OPRA).
				OPRA *string `json:"OPRA,omitempty"`

				// UTP Condition code from UTP Plan (UTP).
				UTP *string `json:"UTP,omitempty"`
			} `json:"sip_mapping"`

			// Type An identifier for a collection of related conditions.
			Type ListConditions200ResultsType `json:"type"`

			// UpdateRules A list of aggregation rules.
			UpdateRules *struct {
				// Consolidated Describes aggregation rules on a consolidated (all exchanges) basis.
				Consolidated struct {
					// UpdatesHighLow Whether or not trades with this condition update the high/low.
					UpdatesHighLow bool `json:"updates_high_low"`

					// UpdatesOpenClose Whether or not trades with this condition update the open/close.
					UpdatesOpenClose bool `json:"updates_open_close"`

					// UpdatesVolume Whether or not trades with this condition update the volume.
					UpdatesVolume bool `json:"updates_volume"`
				} `json:"consolidated"`

				// MarketCenter Describes aggregation rules on a per-market-center basis.
				MarketCenter struct {
					// UpdatesHighLow Whether or not trades with this condition update the high/low.
					UpdatesHighLow bool `json:"updates_high_low"`

					// UpdatesOpenClose Whether or not trades with this condition update the open/close.
					UpdatesOpenClose bool `json:"updates_open_close"`

					// UpdatesVolume Whether or not trades with this condition update the volume.
					UpdatesVolume bool `json:"updates_volume"`
				} `json:"market_center"`
			} `json:"update_rules,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
	JSON400 *struct {
		// Count The total number of results for this request.
		Count int `json:"count"`

		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of conditions that match your query.
		Results []struct {
			// Abbreviation A commonly-used abbreviation for this condition.
			Abbreviation *string `json:"abbreviation,omitempty"`

			// AssetClass An identifier for a group of similar financial instruments.
			AssetClass ListConditions400ResultsAssetClass `json:"asset_class"`

			// DataTypes Data types that this condition applies to.
			DataTypes []ListConditions400ResultsDataTypes `json:"data_types"`

			// Description A short description of the semantics of this condition.
			Description *string `json:"description,omitempty"`

			// Exchange If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute.
			// In other words, data with this condition attached comes exclusively from the given exchange.
			Exchange *int `json:"exchange,omitempty"`

			// Id An identifier used by Massive for this condition. Unique per data type.
			Id int `json:"id"`

			// Legacy If true, this condition is from an old version of the SIPs' specs and no longer is used.
			// Other conditions may or may not reuse the same symbol as this one.
			Legacy *bool `json:"legacy,omitempty"`

			// Name The name of this condition.
			Name string `json:"name"`

			// SipMapping A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
			SipMapping struct {
				// CTA Condition code from the Consolidated Tape Association (CTA).
				CTA *string `json:"CTA,omitempty"`

				// OPRA Condition code from the Options Price Reporting Authority (OPRA).
				OPRA *string `json:"OPRA,omitempty"`

				// UTP Condition code from UTP Plan (UTP).
				UTP *string `json:"UTP,omitempty"`
			} `json:"sip_mapping"`

			// Type An identifier for a collection of related conditions.
			Type ListConditions400ResultsType `json:"type"`

			// UpdateRules A list of aggregation rules.
			UpdateRules *struct {
				// Consolidated Describes aggregation rules on a consolidated (all exchanges) basis.
				Consolidated struct {
					// UpdatesHighLow Whether or not trades with this condition update the high/low.
					UpdatesHighLow bool `json:"updates_high_low"`

					// UpdatesOpenClose Whether or not trades with this condition update the open/close.
					UpdatesOpenClose bool `json:"updates_open_close"`

					// UpdatesVolume Whether or not trades with this condition update the volume.
					UpdatesVolume bool `json:"updates_volume"`
				} `json:"consolidated"`

				// MarketCenter Describes aggregation rules on a per-market-center basis.
				MarketCenter struct {
					// UpdatesHighLow Whether or not trades with this condition update the high/low.
					UpdatesHighLow bool `json:"updates_high_low"`

					// UpdatesOpenClose Whether or not trades with this condition update the open/close.
					UpdatesOpenClose bool `json:"updates_open_close"`

					// UpdatesVolume Whether or not trades with this condition update the volume.
					UpdatesVolume bool `json:"updates_volume"`
				} `json:"market_center"`
			} `json:"update_rules,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
	JSONDefault *struct {
		// Count The total number of results for this request.
		Count int `json:"count"`

		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of conditions that match your query.
		Results []struct {
			// Abbreviation A commonly-used abbreviation for this condition.
			Abbreviation *string `json:"abbreviation,omitempty"`

			// AssetClass An identifier for a group of similar financial instruments.
			AssetClass ListConditionsDefaultResultsAssetClass `json:"asset_class"`

			// DataTypes Data types that this condition applies to.
			DataTypes []ListConditionsDefaultResultsDataTypes `json:"data_types"`

			// Description A short description of the semantics of this condition.
			Description *string `json:"description,omitempty"`

			// Exchange If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute.
			// In other words, data with this condition attached comes exclusively from the given exchange.
			Exchange *int `json:"exchange,omitempty"`

			// Id An identifier used by Massive for this condition. Unique per data type.
			Id int `json:"id"`

			// Legacy If true, this condition is from an old version of the SIPs' specs and no longer is used.
			// Other conditions may or may not reuse the same symbol as this one.
			Legacy *bool `json:"legacy,omitempty"`

			// Name The name of this condition.
			Name string `json:"name"`

			// SipMapping A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
			SipMapping struct {
				// CTA Condition code from the Consolidated Tape Association (CTA).
				CTA *string `json:"CTA,omitempty"`

				// OPRA Condition code from the Options Price Reporting Authority (OPRA).
				OPRA *string `json:"OPRA,omitempty"`

				// UTP Condition code from UTP Plan (UTP).
				UTP *string `json:"UTP,omitempty"`
			} `json:"sip_mapping"`

			// Type An identifier for a collection of related conditions.
			Type ListConditionsDefaultResultsType `json:"type"`

			// UpdateRules A list of aggregation rules.
			UpdateRules *struct {
				// Consolidated Describes aggregation rules on a consolidated (all exchanges) basis.
				Consolidated struct {
					// UpdatesHighLow Whether or not trades with this condition update the high/low.
					UpdatesHighLow bool `json:"updates_high_low"`

					// UpdatesOpenClose Whether or not trades with this condition update the open/close.
					UpdatesOpenClose bool `json:"updates_open_close"`

					// UpdatesVolume Whether or not trades with this condition update the volume.
					UpdatesVolume bool `json:"updates_volume"`
				} `json:"consolidated"`

				// MarketCenter Describes aggregation rules on a per-market-center basis.
				MarketCenter struct {
					// UpdatesHighLow Whether or not trades with this condition update the high/low.
					UpdatesHighLow bool `json:"updates_high_low"`

					// UpdatesOpenClose Whether or not trades with this condition update the open/close.
					UpdatesOpenClose bool `json:"updates_open_close"`

					// UpdatesVolume Whether or not trades with this condition update the volume.
					UpdatesVolume bool `json:"updates_volume"`
				} `json:"market_center"`
			} `json:"update_rules,omitempty"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type ListConditions200ResultsAssetClass string
type ListConditions200ResultsDataTypes string
type ListConditions200ResultsType string
type ListConditions400ResultsAssetClass string
type ListConditions400ResultsDataTypes string
type ListConditions400ResultsType string
type ListConditionsDefaultResultsAssetClass string
type ListConditionsDefaultResultsDataTypes string
type ListConditionsDefaultResultsType string

// Status returns HTTPResponse.Status
func (r ListConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDividendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// CashAmount The cash amount of the dividend per share owned.
			CashAmount float32 `json:"cash_amount"`

			// Currency The currency in which the dividend is paid.
			Currency *string `json:"currency,omitempty"`

			// DeclarationDate The date that the dividend was announced.
			DeclarationDate *string `json:"declaration_date,omitempty"`

			// DividendType The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD.
			// Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
			// Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
			DividendType ListDividends200ResultsDividendType `json:"dividend_type"`

			// ExDividendDate The date that the stock first trades without the dividend, determined by the exchange.
			ExDividendDate string `json:"ex_dividend_date"`

			// Frequency The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
			Frequency int `json:"frequency"`

			// Id The unique identifier of the dividend.
			Id string `json:"id"`

			// PayDate The date that the dividend is paid out.
			PayDate *string `json:"pay_date,omitempty"`

			// RecordDate The date that the stock must be held to receive the dividend, set by the company.
			RecordDate *string `json:"record_date,omitempty"`

			// Ticker The ticker symbol of the dividend.
			Ticker string `json:"ticker"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type ListDividends200ResultsDividendType string

// Status returns HTTPResponse.Status
func (r ListDividendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDividendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// Acronym A commonly used abbreviation for this exchange.
			Acronym *string `json:"acronym,omitempty"`

			// AssetClass An identifier for a group of similar financial instruments.
			AssetClass ListExchanges200ResultsAssetClass `json:"asset_class"`

			// Id A unique identifier used by Massive for this exchange.
			Id int `json:"id"`

			// Locale An identifier for a geographical location.
			Locale ListExchanges200ResultsLocale `json:"locale"`

			// Mic The Market Identifier Code of this exchange (see ISO 10383).
			Mic *string `json:"mic,omitempty"`

			// Name Name of this exchange.
			Name string `json:"name"`

			// OperatingMic The MIC of the entity that operates this exchange.
			OperatingMic *string `json:"operating_mic,omitempty"`

			// ParticipantId The ID used by SIP's to represent this exchange.
			ParticipantId *string `json:"participant_id,omitempty"`

			// Type Represents the type of exchange.
			Type ListExchanges200ResultsType `json:"type"`

			// Url A link to this exchange's website, if one exists.
			Url *string `json:"url,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
	JSON400 *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
	JSONDefault *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type ListExchanges200ResultsAssetClass string
type ListExchanges200ResultsLocale string
type ListExchanges200ResultsType string

// Status returns HTTPResponse.Status
func (r ListExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOptionsContractsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AdditionalUnderlyings If an option contract has additional underlyings or deliverables associated with it, they will appear here.
			// See <a rel="noopener noreferrer nofollow" target="_blank" href="https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies">here</a> for some examples of what might cause a contract to have additional underlyings.
			AdditionalUnderlyings *[]struct {
				// Amount The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
				Amount *float32 `json:"amount,omitempty"`

				// Type The type of the additional underlying asset, either equity or currency.
				Type *string `json:"type,omitempty"`

				// Underlying The name of the additional underlying asset.
				Underlying *string `json:"underlying,omitempty"`
			} `json:"additional_underlyings,omitempty"`

			// Cfi The 6 letter CFI code of the contract (defined in <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/ISO_10962">ISO 10962</a>)
			Cfi *string `json:"cfi,omitempty"`

			// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
			ContractType *string `json:"contract_type,omitempty"`

			// Correction The correction number for this option contract.
			Correction *int `json:"correction,omitempty"`

			// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
			ExerciseStyle *ListOptionsContracts200ResultsExerciseStyle `json:"exercise_style,omitempty"`

			// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
			ExpirationDate *string `json:"expiration_date,omitempty"`

			// PrimaryExchange The MIC code of the primary exchange that this contract is listed on.
			PrimaryExchange *string `json:"primary_exchange,omitempty"`

			// SharesPerContract The number of shares per contract for this contract.
			SharesPerContract *float32 `json:"shares_per_contract,omitempty"`

			// StrikePrice The strike price of the option contract.
			StrikePrice *float32 `json:"strike_price,omitempty"`

			// Ticker The ticker for the option contract.
			Ticker *string `json:"ticker,omitempty"`

			// UnderlyingTicker The underlying ticker that the option contract relates to.
			UnderlyingTicker *string `json:"underlying_ticker,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type ListOptionsContracts200ResultsExerciseStyle string

// Status returns HTTPResponse.Status
func (r ListOptionsContractsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOptionsContractsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsContractResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results Contains the requested data for the specified options contract.
		Results *struct {
			// AdditionalUnderlyings If an option contract has additional underlyings or deliverables associated with it, they will appear here.
			// See <a rel="noopener noreferrer nofollow" target="_blank" href="https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies">here</a> for some examples of what might cause a contract to have additional underlyings.
			AdditionalUnderlyings *[]struct {
				// Amount The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
				Amount *float32 `json:"amount,omitempty"`

				// Type The type of the additional underlying asset, either equity or currency.
				Type *string `json:"type,omitempty"`

				// Underlying The name of the additional underlying asset.
				Underlying *string `json:"underlying,omitempty"`
			} `json:"additional_underlyings,omitempty"`

			// Cfi The 6 letter CFI code of the contract (defined in <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/ISO_10962">ISO 10962</a>)
			Cfi *string `json:"cfi,omitempty"`

			// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
			ContractType *string `json:"contract_type,omitempty"`

			// Correction The correction number for this option contract.
			Correction *int `json:"correction,omitempty"`

			// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
			ExerciseStyle *GetOptionsContract200ResultsExerciseStyle `json:"exercise_style,omitempty"`

			// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
			ExpirationDate *string `json:"expiration_date,omitempty"`

			// PrimaryExchange The MIC code of the primary exchange that this contract is listed on.
			PrimaryExchange *string `json:"primary_exchange,omitempty"`

			// SharesPerContract The number of shares per contract for this contract.
			SharesPerContract *float32 `json:"shares_per_contract,omitempty"`

			// StrikePrice The strike price of the option contract.
			StrikePrice *float32 `json:"strike_price,omitempty"`

			// Ticker The ticker for the option contract.
			Ticker *string `json:"ticker,omitempty"`

			// UnderlyingTicker The underlying ticker that the option contract relates to.
			UnderlyingTicker *string `json:"underlying_ticker,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type GetOptionsContract200ResultsExerciseStyle string

// Status returns HTTPResponse.Status
func (r GetOptionsContractResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsContractResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStockSplitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// ExecutionDate The execution date of the stock split. On this date the stock split was applied.
			ExecutionDate string `json:"execution_date"`

			// Id The unique identifier for this stock split.
			Id string `json:"id"`

			// SplitFrom The second number in the split ratio.
			//
			// For example: In a 2-for-1 split, split_from would be 1.
			SplitFrom float32 `json:"split_from"`

			// SplitTo The first number in the split ratio.
			//
			// For example: In a 2-for-1 split, split_to would be 2.
			SplitTo float32 `json:"split_to"`

			// Ticker The ticker symbol of the stock split.
			Ticker string `json:"ticker"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListStockSplitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStockSplitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of tickers that match your query.
		//
		// Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
		Results *[]struct {
			// Active Whether or not the asset is actively traded. False means the asset has been delisted.
			Active *bool `json:"active,omitempty"`

			// BaseCurrencyName The name of the currency that this asset is priced against.
			BaseCurrencyName *string `json:"base_currency_name,omitempty"`

			// BaseCurrencySymbol The ISO 4217 code of the currency that this asset is priced against.
			BaseCurrencySymbol *string `json:"base_currency_symbol,omitempty"`

			// Cik The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
			Cik *string `json:"cik,omitempty"`

			// CompositeFigi The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
			CompositeFigi *string `json:"composite_figi,omitempty"`

			// CurrencyName The name of the currency that this asset is traded with.
			CurrencyName *string `json:"currency_name,omitempty"`

			// CurrencySymbol The ISO 4217 code of the currency that this asset is traded with.
			CurrencySymbol *string `json:"currency_symbol,omitempty"`

			// DelistedUtc The last date that the asset was traded.
			DelistedUtc *time.Time `json:"delisted_utc,omitempty"`

			// LastUpdatedUtc The information is accurate up to this time.
			LastUpdatedUtc *time.Time `json:"last_updated_utc,omitempty"`

			// Locale The locale of the asset.
			Locale ListTickers200ResultsLocale `json:"locale"`

			// Market The market type of the asset.
			Market ListTickers200ResultsMarket `json:"market"`

			// Name The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
			Name string `json:"name"`

			// PrimaryExchange The ISO code of the primary listing exchange for this asset.
			PrimaryExchange *string `json:"primary_exchange,omitempty"`

			// ShareClassFigi The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
			ShareClassFigi *string `json:"share_class_figi,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// Type The type of the asset. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
			Type *string `json:"type,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type ListTickers200ResultsLocale string
type ListTickers200ResultsMarket string

// Status returns HTTPResponse.Status
func (r ListTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTickerTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AssetClass An identifier for a group of similar financial instruments.
			AssetClass ListTickerTypes200ResultsAssetClass `json:"asset_class"`

			// Code A code used by Massive to refer to this ticker type.
			Code string `json:"code"`

			// Description A short description of this ticker type.
			Description string `json:"description"`

			// Locale An identifier for a geographical location.
			Locale ListTickerTypes200ResultsLocale `json:"locale"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
	JSON400 *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
	JSONDefault *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request ID assigned by the server.
		RequestId string `json:"request_id"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type ListTickerTypes200ResultsAssetClass string
type ListTickerTypes200ResultsLocale string

// Status returns HTTPResponse.Status
func (r ListTickerTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTickerTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTickerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count *int `json:"count,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results Ticker with details.
		Results *struct {
			// Active Whether or not the asset is actively traded. False means the asset has been delisted.
			Active bool `json:"active"`

			// Address Company headquarters address details.
			Address *struct {
				// Address1 The first line of the company's headquarters address.
				Address1 *string `json:"address1,omitempty"`

				// Address2 The second line of the company's headquarters address, if applicable.
				Address2 *string `json:"address2,omitempty"`

				// City The city of the company's headquarters address.
				City *string `json:"city,omitempty"`

				// PostalCode The postal code of the company's headquarters address.
				PostalCode *string `json:"postal_code,omitempty"`

				// State The state of the company's headquarters address.
				State *string `json:"state,omitempty"`
			} `json:"address,omitempty"`

			// Branding Provides URLs aiding in visual identification.
			Branding *struct {
				// IconUrl A link to this ticker's company's icon. Icon's are generally smaller, square images that represent the company at a glance.
				// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
				IconUrl *string `json:"icon_url,omitempty"`

				// LogoUrl A link to this ticker's company's logo.
				// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
				LogoUrl *string `json:"logo_url,omitempty"`
			} `json:"branding,omitempty"`

			// Cik The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
			Cik *string `json:"cik,omitempty"`

			// CompositeFigi The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
			CompositeFigi *string `json:"composite_figi,omitempty"`

			// CurrencyName The name of the currency that this asset is traded with.
			CurrencyName string `json:"currency_name"`

			// DelistedUtc The last date that the asset was traded.
			DelistedUtc *time.Time `json:"delisted_utc,omitempty"`

			// Description A description of the company and what they do/offer.
			Description *string `json:"description,omitempty"`

			// HomepageUrl The URL of the company's website homepage.
			HomepageUrl *string `json:"homepage_url,omitempty"`

			// ListDate The date that the symbol was first publicly listed in the format YYYY-MM-DD.
			ListDate *string `json:"list_date,omitempty"`

			// Locale The locale of the asset.
			Locale GetTicker200ResultsLocale `json:"locale"`

			// Market The market type of the asset.
			Market GetTicker200ResultsMarket `json:"market"`

			// MarketCap The most recent close price of the ticker multiplied by weighted outstanding shares.
			MarketCap *float64 `json:"market_cap,omitempty"`

			// Name The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
			Name string `json:"name"`

			// PhoneNumber The phone number for the company behind this ticker.
			PhoneNumber *string `json:"phone_number,omitempty"`

			// PrimaryExchange The ISO code of the primary listing exchange for this asset.
			PrimaryExchange *string `json:"primary_exchange,omitempty"`

			// RoundLot Round lot size of this security.
			RoundLot *float64 `json:"round_lot,omitempty"`

			// ShareClassFigi The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
			ShareClassFigi *string `json:"share_class_figi,omitempty"`

			// ShareClassSharesOutstanding The recorded number of outstanding shares for this particular share class.
			ShareClassSharesOutstanding *float64 `json:"share_class_shares_outstanding,omitempty"`

			// SicCode The standard industrial classification code for this ticker.  For a list of SIC Codes, see the SEC's <a rel="nofollow" target="_blank" href="https://www.sec.gov/info/edgar/siccodes.htm">SIC Code List</a>.
			SicCode *string `json:"sic_code,omitempty"`

			// SicDescription A description of this ticker's SIC code.
			SicDescription *string `json:"sic_description,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`

			// TickerRoot The root of a specified ticker. For example, the root of BRK.A is BRK.
			TickerRoot *string `json:"ticker_root,omitempty"`

			// TickerSuffix The suffix of a specified ticker. For example, the suffix of BRK.A is A.
			TickerSuffix *string `json:"ticker_suffix,omitempty"`

			// TotalEmployees The approximate number of employees for the company.
			TotalEmployees *float32 `json:"total_employees,omitempty"`

			// Type The type of the asset. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
			Type *string `json:"type,omitempty"`

			// WeightedSharesOutstanding The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
			WeightedSharesOutstanding *float64 `json:"weighted_shares_outstanding,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type GetTicker200ResultsLocale string
type GetTicker200ResultsMarket string

// Status returns HTTPResponse.Status
func (r GetTickerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTickerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// BreakEvenPrice The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
			BreakEvenPrice *float64 `json:"break_even_price,omitempty"`

			// Details The details for this contract.
			Details *struct {
				// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
				ContractType GetSnapshots200ResultsDetailsContractType `json:"contract_type"`

				// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
				ExerciseStyle GetSnapshots200ResultsDetailsExerciseStyle `json:"exercise_style"`

				// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
				ExpirationDate openapi_types.Date `json:"expiration_date"`

				// SharesPerContract The number of shares per contract for this contract.
				SharesPerContract float32 `json:"shares_per_contract"`

				// StrikePrice The strike price of the option contract.
				StrikePrice float64 `json:"strike_price"`
			} `json:"details,omitempty"`

			// Error The error while looking for this ticker.
			Error *string `json:"error,omitempty"`

			// Fmv Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security.
			// For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float32 `json:"fmv,omitempty"`

			// FmvLastUpdated If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
			FmvLastUpdated *int64 `json:"fmv_last_updated,omitempty"`

			// Greeks The greeks for this contract.
			// There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money.
			// See this <a href="https://massive.com/blog/greeks-and-implied-volatility/#testing"
			// alt="link">article</a> for more information.
			Greeks *struct {
				// Delta The change in the option's price per $0.01 increment in the price of the underlying asset.
				Delta float64 `json:"delta"`

				// Gamma The change in delta per $0.01 change in the price of the underlying asset.
				Gamma float64 `json:"gamma"`

				// Theta The change in the option's price per day.
				Theta float64 `json:"theta"`

				// Vega The change in the option's price per 1% increment in volatility.
				Vega float64 `json:"vega"`
			} `json:"greeks,omitempty"`

			// ImpliedVolatility The market's forecast for the volatility of the underlying asset, based on this option's current price.
			ImpliedVolatility *float64 `json:"implied_volatility,omitempty"`

			// LastMinute The most recent minute aggregate for this stock.
			LastMinute *struct {
				// Close The closing value for the minute aggreate.
				Close float64 `json:"close"`

				// DecimalVolume The trading volume for the minute aggregate with decimal precision. This field provides support for fractional shares, representing volume as a decimal string where the fractional part is expressed in millionths. This field is only returned for stocks snapshots.
				DecimalVolume *string `json:"decimal_volume,omitempty"`

				// High The highest value for the minute aggregate.
				High float64 `json:"high"`

				// Low The lowest value for the minute aggregate.
				Low float64 `json:"low"`

				// Open The open value for the minute aggregate.
				Open float64 `json:"open"`

				// Transactions The number of transactions that took place within the minute aggregate.
				Transactions int32 `json:"transactions"`

				// Volume The trading volume for the minute aggregate.
				Volume float64 `json:"volume"`

				// Vwap The trading volume weighted average price for the minute aggregate.
				Vwap float64 `json:"vwap"`
			} `json:"last_minute,omitempty"`

			// LastQuote The most recent quote for this contract. This is only returned if your current plan includes quotes.
			LastQuote *struct {
				// Ask The ask price.
				Ask float64 `json:"ask"`

				// AskExchange The ask side exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				AskExchange *int `json:"ask_exchange,omitempty"`

				// AskSize The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
				AskSize *float64 `json:"ask_size,omitempty"`

				// Bid The bid price.
				Bid float64 `json:"bid"`

				// BidExchange The bid side exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange *int `json:"bid_exchange,omitempty"`

				// BidSize The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
				BidSize *float64 `json:"bid_size,omitempty"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated int64 `json:"last_updated"`

				// Midpoint The average of the bid and ask price.
				Midpoint *float64 `json:"midpoint,omitempty"`

				// Timeframe The time relevance of the data.
				Timeframe GetSnapshots200ResultsLastQuoteTimeframe `json:"timeframe"`
			} `json:"last_quote,omitempty"`

			// LastTrade The most recent quote for this contract. This is only returned if your current plan includes trades.
			LastTrade *struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// DecimalSize The size of a trade, including fractional shares, represented as a decimal string where the fractional part is expressed in millionths. This field is only returned for stocks snapshots.
				DecimalSize *string `json:"decimal_size,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange *int `json:"exchange,omitempty"`

				// Id The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
				Id *string `json:"id,omitempty"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// ParticipantTimestamp The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
				ParticipantTimestamp *int64 `json:"participant_timestamp,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				Price float64 `json:"price"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
				SipTimestamp *int64 `json:"sip_timestamp,omitempty"`

				// Size The size of a trade (also known as volume).
				Size int32 `json:"size"`

				// Timeframe The time relevance of the data.
				Timeframe *GetSnapshots200ResultsLastTradeTimeframe `json:"timeframe,omitempty"`
			} `json:"last_trade,omitempty"`

			// LastUpdated The nanosecond timestamp of when this information was updated.
			LastUpdated *int64 `json:"last_updated,omitempty"`

			// MarketStatus The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading.
			// Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
			MarketStatus *string `json:"market_status,omitempty"`

			// Message The error message while looking for this ticker.
			Message *string `json:"message,omitempty"`

			// Name The name of this contract.
			Name *string `json:"name,omitempty"`

			// OpenInterest The quantity of this contract held at the end of the last trading day.
			OpenInterest *float64 `json:"open_interest,omitempty"`

			// Session Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
			Session *struct {
				// Change The value of the price change for the asset from the previous trading day.
				Change float64 `json:"change"`

				// ChangePercent The percent of the price change for the asset from the previous trading day.
				ChangePercent float64 `json:"change_percent"`

				// Close The closing price of the asset for the day.
				Close float64 `json:"close"`

				// DecimalVolume The trading volume for the asset for the day with decimal precision. This field provides support for fractional shares, representing volume as a decimal string. This field is only returned for stocks snapshots.
				DecimalVolume *string `json:"decimal_volume,omitempty"`

				// EarlyTradingChange Today's early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
				EarlyTradingChange *float64 `json:"early_trading_change,omitempty"`

				// EarlyTradingChangePercent Today's early trading change as a percentage.
				EarlyTradingChangePercent *float64 `json:"early_trading_change_percent,omitempty"`

				// High The highest price of the asset for the day.
				High float64 `json:"high"`

				// LateTradingChange Today's late trading change amount, difference between price and today's close if in late trading hours, otherwise difference between last price during late trading and today's close.
				LateTradingChange *float64 `json:"late_trading_change,omitempty"`

				// LateTradingChangePercent Today's late trading change as a percentage.
				LateTradingChangePercent *float64 `json:"late_trading_change_percent,omitempty"`

				// Low The lowest price of the asset for the day.
				Low float64 `json:"low"`

				// Open The open price of the asset for the day.
				Open float64 `json:"open"`

				// PreviousClose The closing price of the asset for the previous trading day.
				PreviousClose float64 `json:"previous_close"`

				// Price The price of the most recent trade or bid price for this asset.
				Price *float64 `json:"price,omitempty"`

				// RegularTradingChange Today's change in regular trading hours, difference between current price and previous trading day's close, otherwise difference between today's close and previous day's close.
				RegularTradingChange *float64 `json:"regular_trading_change,omitempty"`

				// RegularTradingChangePercent Today's regular trading change as a percentage.
				RegularTradingChangePercent *float64 `json:"regular_trading_change_percent,omitempty"`

				// Volume The trading volume for the asset for the day.
				Volume *float64 `json:"volume,omitempty"`
			} `json:"session,omitempty"`

			// Ticker The ticker symbol for the asset.
			Ticker string `json:"ticker"`

			// Timeframe The time relevance of the data.
			Timeframe *GetSnapshots200ResultsTimeframe `json:"timeframe,omitempty"`

			// Type The asset class for this ticker.
			Type *GetSnapshots200ResultsType `json:"type,omitempty"`

			// UnderlyingAsset Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
			UnderlyingAsset *struct {
				// ChangeToBreakEven The change in price for the contract to break even.
				ChangeToBreakEven float64 `json:"change_to_break_even"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
				Price *float64 `json:"price,omitempty"`

				// Ticker The ticker symbol for the contract's underlying asset.
				Ticker string `json:"ticker"`

				// Timeframe The time relevance of the data.
				Timeframe *GetSnapshots200ResultsUnderlyingAssetTimeframe `json:"timeframe,omitempty"`

				// Value The value of the underlying index.
				Value *float64 `json:"value,omitempty"`
			} `json:"underlying_asset,omitempty"`

			// Value Value of Index.
			Value *float32 `json:"value,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type GetSnapshots200ResultsDetailsContractType string
type GetSnapshots200ResultsDetailsExerciseStyle string
type GetSnapshots200ResultsLastQuoteTimeframe string
type GetSnapshots200ResultsLastTradeTimeframe string
type GetSnapshots200ResultsTimeframe string
type GetSnapshots200ResultsType string
type GetSnapshots200ResultsUnderlyingAssetTimeframe string

// Status returns HTTPResponse.Status
func (r GetSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndicesSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// Error The error while looking for this ticker.
			Error *string `json:"error,omitempty"`

			// LastUpdated The nanosecond timestamp of when this information was updated.
			LastUpdated *int64 `json:"last_updated,omitempty"`

			// MarketStatus The market status for the market that trades this ticker.
			MarketStatus *string `json:"market_status,omitempty"`

			// Message The error message while looking for this ticker.
			Message *string `json:"message,omitempty"`

			// Name Name of Index.
			Name *string `json:"name,omitempty"`

			// Session Trading session metrics, detailing change percentages and key price points (open, close, high, low) for the asset within the current trading day.
			Session *struct {
				// Change The value of the change for the index from the previous trading day.
				Change *float64 `json:"change,omitempty"`

				// ChangePercent The percent of the change for the index from the previous trading day.
				ChangePercent *float64 `json:"change_percent,omitempty"`

				// Close The closing value for the index of the day.
				Close *float64 `json:"close,omitempty"`

				// High The highest value for the index of the day.
				High *float64 `json:"high,omitempty"`

				// Low The lowest value for the index of the day.
				Low *float64 `json:"low,omitempty"`

				// Open The open value for the index of the day.
				Open *float64 `json:"open,omitempty"`

				// PreviousClose The closing value for the index of previous trading day.
				PreviousClose *float64 `json:"previous_close,omitempty"`
			} `json:"session,omitempty"`

			// Ticker Ticker of asset queried.
			Ticker string `json:"ticker"`

			// Timeframe The time relevance of the data.
			Timeframe *GetIndicesSnapshot200ResultsTimeframe `json:"timeframe,omitempty"`

			// Type The indices market.
			Type *GetIndicesSnapshot200ResultsType `json:"type,omitempty"`

			// Value Value of Index.
			Value *float32 `json:"value,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type GetIndicesSnapshot200ResultsTimeframe string
type GetIndicesSnapshot200ResultsType string

// Status returns HTTPResponse.Status
func (r GetIndicesSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndicesSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsChainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// BreakEvenPrice The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
			BreakEvenPrice float64 `json:"break_even_price"`

			// Day The most recent daily bar for this contract.
			Day struct {
				// Change The value of the price change for the contract from the previous trading day.
				Change float64 `json:"change"`

				// ChangePercent The percent of the price change for the contract from the previous trading day.
				ChangePercent float64 `json:"change_percent"`

				// Close The closing price for the contract of the day.
				Close float64 `json:"close"`

				// High The highest price for the contract of the day.
				High float64 `json:"high"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Low The lowest price for the contract of the day.
				Low float64 `json:"low"`

				// Open The open price for the contract of the day.
				Open float64 `json:"open"`

				// PreviousClose The closing price for the contract of previous trading day.
				PreviousClose float64 `json:"previous_close"`

				// Volume The trading volume for the contract of the day.
				Volume float64 `json:"volume"`

				// Vwap The trading volume weighted average price for the contract of the day.
				Vwap float64 `json:"vwap"`
			} `json:"day"`

			// Details The details for this contract.
			Details struct {
				// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
				ContractType GetOptionsChain200ResultsDetailsContractType `json:"contract_type"`

				// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
				ExerciseStyle GetOptionsChain200ResultsDetailsExerciseStyle `json:"exercise_style"`

				// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
				ExpirationDate openapi_types.Date `json:"expiration_date"`

				// SharesPerContract The number of shares per contract for this contract.
				SharesPerContract float32 `json:"shares_per_contract"`

				// StrikePrice The strike price of the option contract.
				StrikePrice float64 `json:"strike_price"`

				// Ticker The ticker symbol for the asset.
				Ticker string `json:"ticker"`
			} `json:"details"`

			// Fmv Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security.
			// For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float32 `json:"fmv,omitempty"`

			// FmvLastUpdated If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
			FmvLastUpdated *int64 `json:"fmv_last_updated,omitempty"`

			// Greeks The greeks for this contract.
			// There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money.
			// See this <a href="https://massive.com/blog/greeks-and-implied-volatility/#testing"
			// alt="link">article</a> for more information.
			Greeks *struct {
				// Delta The change in the option's price per $0.01 increment in the price of the underlying asset.
				Delta float64 `json:"delta"`

				// Gamma The change in delta per $0.01 change in the price of the underlying asset.
				Gamma float64 `json:"gamma"`

				// Theta The change in the option's price per day.
				Theta float64 `json:"theta"`

				// Vega The change in the option's price per 1% increment in volatility.
				Vega float64 `json:"vega"`
			} `json:"greeks,omitempty"`

			// ImpliedVolatility The market's forecast for the volatility of the underlying asset, based on this option's current price.
			ImpliedVolatility *float64 `json:"implied_volatility,omitempty"`

			// LastQuote The most recent quote for this contract. This is only returned if your current plan includes quotes.
			LastQuote struct {
				// Ask The ask price.
				Ask float64 `json:"ask"`

				// AskExchange The ask side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				AskExchange *int32 `json:"ask_exchange,omitempty"`

				// AskSize The ask size.
				AskSize float64 `json:"ask_size"`

				// Bid The bid price.
				Bid float64 `json:"bid"`

				// BidExchange The bid side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange *int32 `json:"bid_exchange,omitempty"`

				// BidSize The bid size.
				BidSize float64 `json:"bid_size"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Midpoint The average of the bid and ask price.
				Midpoint float64 `json:"midpoint"`

				// Timeframe The time relevance of the data.
				Timeframe *GetOptionsChain200ResultsLastQuoteTimeframe `json:"timeframe,omitempty"`
			} `json:"last_quote"`

			// LastTrade The most recent trade for this contract. This is only returned if your current plan includes trades.
			LastTrade *struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// Price The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				Price float64 `json:"price"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
				SipTimestamp int64 `json:"sip_timestamp"`

				// Size The size of a trade (also known as volume).
				Size int32 `json:"size"`

				// Timeframe The time relevance of the data.
				Timeframe *GetOptionsChain200ResultsLastTradeTimeframe `json:"timeframe,omitempty"`
			} `json:"last_trade,omitempty"`

			// OpenInterest The quantity of this contract held at the end of the last trading day.
			OpenInterest float64 `json:"open_interest"`

			// UnderlyingAsset Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
			UnderlyingAsset struct {
				// ChangeToBreakEven The change in price for the contract to break even.
				ChangeToBreakEven float64 `json:"change_to_break_even"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
				Price *float64 `json:"price,omitempty"`

				// Ticker The ticker symbol for the contract's underlying asset.
				Ticker string `json:"ticker"`

				// Timeframe The time relevance of the data.
				Timeframe *GetOptionsChain200ResultsUnderlyingAssetTimeframe `json:"timeframe,omitempty"`

				// Value The value of the underlying index.
				Value *float64 `json:"value,omitempty"`
			} `json:"underlying_asset"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type GetOptionsChain200ResultsDetailsContractType string
type GetOptionsChain200ResultsDetailsExerciseStyle string
type GetOptionsChain200ResultsLastQuoteTimeframe string
type GetOptionsChain200ResultsLastTradeTimeframe string
type GetOptionsChain200ResultsUnderlyingAssetTimeframe string

// Status returns HTTPResponse.Status
func (r GetOptionsChainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsChainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionContractResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results Contains the requested snapshot data for the specified contract.
		Results *struct {
			// BreakEvenPrice The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
			BreakEvenPrice float64 `json:"break_even_price"`

			// Day The most recent daily bar for this contract.
			Day struct {
				// Change The value of the price change for the contract from the previous trading day.
				Change float64 `json:"change"`

				// ChangePercent The percent of the price change for the contract from the previous trading day.
				ChangePercent float64 `json:"change_percent"`

				// Close The closing price for the contract of the day.
				Close float64 `json:"close"`

				// High The highest price for the contract of the day.
				High float64 `json:"high"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Low The lowest price for the contract of the day.
				Low float64 `json:"low"`

				// Open The open price for the contract of the day.
				Open float64 `json:"open"`

				// PreviousClose The closing price for the contract of previous trading day.
				PreviousClose float64 `json:"previous_close"`

				// Volume The trading volume for the contract of the day.
				Volume float64 `json:"volume"`

				// Vwap The trading volume weighted average price for the contract of the day.
				Vwap float64 `json:"vwap"`
			} `json:"day"`

			// Details The details for this contract.
			Details struct {
				// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
				ContractType GetOptionContract200ResultsDetailsContractType `json:"contract_type"`

				// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
				ExerciseStyle GetOptionContract200ResultsDetailsExerciseStyle `json:"exercise_style"`

				// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
				ExpirationDate openapi_types.Date `json:"expiration_date"`

				// SharesPerContract The number of shares per contract for this contract.
				SharesPerContract float32 `json:"shares_per_contract"`

				// StrikePrice The strike price of the option contract.
				StrikePrice float64 `json:"strike_price"`

				// Ticker The ticker symbol for the asset.
				Ticker string `json:"ticker"`
			} `json:"details"`

			// Fmv Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security.
			// For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
			Fmv *float32 `json:"fmv,omitempty"`

			// FmvLastUpdated If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
			FmvLastUpdated *int64 `json:"fmv_last_updated,omitempty"`

			// Greeks The greeks for this contract.
			// There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money.
			// See this <a href="https://massive.com/blog/greeks-and-implied-volatility/#testing"
			// alt="link">article</a> for more information.
			Greeks *struct {
				// Delta The change in the option's price per $0.01 increment in the price of the underlying asset.
				Delta float64 `json:"delta"`

				// Gamma The change in delta per $0.01 change in the price of the underlying asset.
				Gamma float64 `json:"gamma"`

				// Theta The change in the option's price per day.
				Theta float64 `json:"theta"`

				// Vega The change in the option's price per 1% increment in volatility.
				Vega float64 `json:"vega"`
			} `json:"greeks,omitempty"`

			// ImpliedVolatility The market's forecast for the volatility of the underlying asset, based on this option's current price.
			ImpliedVolatility *float64 `json:"implied_volatility,omitempty"`

			// LastQuote The most recent quote for this contract. This is only returned if your current plan includes quotes.
			LastQuote struct {
				// Ask The ask price.
				Ask float64 `json:"ask"`

				// AskExchange The ask side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				AskExchange *int32 `json:"ask_exchange,omitempty"`

				// AskSize The ask size.
				AskSize float64 `json:"ask_size"`

				// Bid The bid price.
				Bid float64 `json:"bid"`

				// BidExchange The bid side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange *int32 `json:"bid_exchange,omitempty"`

				// BidSize The bid size.
				BidSize float64 `json:"bid_size"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Midpoint The average of the bid and ask price.
				Midpoint float64 `json:"midpoint"`

				// Timeframe The time relevance of the data.
				Timeframe *GetOptionContract200ResultsLastQuoteTimeframe `json:"timeframe,omitempty"`
			} `json:"last_quote"`

			// LastTrade The most recent trade for this contract. This is only returned if your current plan includes trades.
			LastTrade *struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// Price The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				Price float64 `json:"price"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
				SipTimestamp int64 `json:"sip_timestamp"`

				// Size The size of a trade (also known as volume).
				Size int32 `json:"size"`

				// Timeframe The time relevance of the data.
				Timeframe *GetOptionContract200ResultsLastTradeTimeframe `json:"timeframe,omitempty"`
			} `json:"last_trade,omitempty"`

			// OpenInterest The quantity of this contract held at the end of the last trading day.
			OpenInterest float64 `json:"open_interest"`

			// UnderlyingAsset Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
			UnderlyingAsset struct {
				// ChangeToBreakEven The change in price for the contract to break even.
				ChangeToBreakEven float64 `json:"change_to_break_even"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
				Price *float64 `json:"price,omitempty"`

				// Ticker The ticker symbol for the contract's underlying asset.
				Ticker string `json:"ticker"`

				// Timeframe The time relevance of the data.
				Timeframe *GetOptionContract200ResultsUnderlyingAssetTimeframe `json:"timeframe,omitempty"`

				// Value The value of the underlying index.
				Value *float64 `json:"value,omitempty"`
			} `json:"underlying_asset"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}
type GetOptionContract200ResultsDetailsContractType string
type GetOptionContract200ResultsDetailsExerciseStyle string
type GetOptionContract200ResultsLastQuoteTimeframe string
type GetOptionContract200ResultsLastTradeTimeframe string
type GetOptionContract200ResultsUnderlyingAssetTimeframe string

// Status returns HTTPResponse.Status
func (r GetOptionContractResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionContractResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// Conditions A list of condition codes.
			Conditions *[]int32 `json:"conditions,omitempty"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange int `json:"exchange"`

			// Id The Trade ID which uniquely identifies a trade on the exchange that the trade happened on.
			Id *string `json:"id,omitempty"`

			// ParticipantTimestamp The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
			ParticipantTimestamp *int64 `json:"participant_timestamp,omitempty"`

			// Price The price of the trade in the base currency of the crypto pair.
			Price float64 `json:"price"`

			// Size The size of a trade (also known as volume).
			Size float64 `json:"size"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCryptoTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptionsTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// Conditions A list of condition codes.
			Conditions *[]int32 `json:"conditions,omitempty"`

			// Correction The trade correction indicator.
			Correction *int `json:"correction,omitempty"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange int `json:"exchange"`

			// ParticipantTimestamp The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
			ParticipantTimestamp *int64 `json:"participant_timestamp,omitempty"`

			// Price The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			Price float64 `json:"price"`

			// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
			SipTimestamp int64 `json:"sip_timestamp"`

			// Size The size of a trade (also known as volume).
			Size float64 `json:"size"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOptionsTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptionsTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStocksTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// Conditions A list of condition codes.
			Conditions *[]int32 `json:"conditions,omitempty"`

			// Correction The trade correction indicator.
			Correction *int `json:"correction,omitempty"`

			// DecimalSize The size of the trade including the fractional component. This is represented as a decimal string.
			DecimalSize string `json:"decimal_size"`

			// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
			Exchange int `json:"exchange"`

			// Id The Trade ID which uniquely identifies a trade. These are unique per
			// combination of ticker, exchange, and TRF. For example: A trade for AAPL
			// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
			// have the same Trade ID.
			Id string `json:"id"`

			// ParticipantTimestamp The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
			ParticipantTimestamp int64 `json:"participant_timestamp"`

			// Price The price of the trade. This is the actual dollar value per whole share of
			// this trade. A trade of 100 shares with a price of $2.00 would be worth a
			// total dollar value of $200.00.
			Price float64 `json:"price"`

			// SequenceNumber The sequence number represents the sequence in which trade events happened.
			// These are increasing and unique per ticker symbol, but will not always be
			// sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
			SequenceNumber int64 `json:"sequence_number"`

			// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
			SipTimestamp int64 `json:"sip_timestamp"`

			// Size The size of a trade (also known as volume).
			Size float64 `json:"size"`

			// Tape There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
			// * Tape A is NYSE listed securities
			// * Tape B is NYSE ARCA / NYSE American
			// * Tape C is NASDAQ
			Tape *int32 `json:"tape,omitempty"`

			// TrfId The ID for the Trade Reporting Facility where the trade took place.
			TrfId *int `json:"trf_id,omitempty"`

			// TrfTimestamp The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
			TrfTimestamp *int64 `json:"trf_timestamp,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStocksTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStocksTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFinancialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results for this request.
		Count int `json:"count"`

		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId string `json:"request_id"`

		// Results An array of results containing the requested data.
		Results []struct {
			// AcceptanceDatetime The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
			AcceptanceDatetime *string `json:"acceptance_datetime,omitempty"`

			// Cik The CIK number for the company.
			Cik string `json:"cik"`

			// CompanyName The company name.
			CompanyName string `json:"company_name"`

			// EndDate The end date of the period that these financials cover in YYYYMMDD format.
			EndDate *string `json:"end_date,omitempty"`

			// FilingDate The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
			FilingDate *string `json:"filing_date,omitempty"`

			// Financials Structured financial statements with detailed data points and metadata.
			Financials struct {
				// BalanceSheet Balance sheet.
				// The keys in this object can be any of the fields listed in the Balance Sheet section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
				BalanceSheet *struct {
					// Asterisk An individual financial data point.
					Asterisk *struct {
						// DerivedFrom The list of report IDs (or errata) which were used to derive this data point.
						// This value is only returned for data points taken directly from XBRL when the `include_sources` query parameter is `true` and if source is SourceInterReportDerived.
						DerivedFrom *[]string `json:"derived_from,omitempty"`

						// Formula The name of the formula used to derive this data point from other financial data points.
						// Information about the formulas can be found <a rel="noopener noreferrer nofollow" target="_blank" href="http://xbrlsite.azurewebsites.net/2020/reporting-scheme/us-gaap/fac/documentation/ImputeRulesList.html">here</a>.
						// This value is only returned for data points that are not explicitly expressed within the XBRL source file when the `include_sources` query parameter is `true` and if source is SourceIntraReportImpute.
						Formula *string `json:"formula,omitempty"`

						// Label A human readable label for the financial data point.
						Label string `json:"label"`

						// Order An indicator of what order within the statement that you would find this data point.
						Order int `json:"order"`

						// Source The source where this data point came from. This will be one of: SourceDirectReport, SourceIntraReportImpute or SourceInterReportDerived.
						Source *string `json:"source,omitempty"`

						// Unit The unit of the financial data point.
						Unit string `json:"unit"`

						// Value The value of the financial data point.
						Value float32 `json:"value"`

						// Xpath The <a rel="noopener noreferrer nofollow" target="_blank" href="https://en.wikipedia.org/wiki/XPath">XPath 1.0</a> query that identifies the fact from within the XBRL source file.
						// This value is only returned for data points taken directly from XBRL when the `include_sources` query parameter is `true` and if source is SourceDirectReport.
						Xpath *string `json:"xpath,omitempty"`
					} `json:"*,omitempty"`
				} `json:"balance_sheet,omitempty"`

				// CashFlowStatement Cash flow statement.
				// The keys in this object can be any of the fields listed in the Cash Flow Statement section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
				// See the attributes of the objects within `balance_sheet` for more details.
				CashFlowStatement *map[string]interface{} `json:"cash_flow_statement,omitempty"`

				// ComprehensiveIncome Comprehensive income.
				// The keys in this object can be any of the fields listed in the Comprehensive Income section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
				// See the attributes of the objects within `balance_sheet` for more details.
				ComprehensiveIncome *map[string]interface{} `json:"comprehensive_income,omitempty"`

				// IncomeStatement Income statement.
				// The keys in this object can be any of the fields listed in the Income Statement section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
				// See the attributes of the objects within `balance_sheet` for more details.
				IncomeStatement *map[string]interface{} `json:"income_statement,omitempty"`
			} `json:"financials"`

			// FiscalPeriod Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
			FiscalPeriod string `json:"fiscal_period"`

			// FiscalYear Fiscal year of the report according to the company.
			FiscalYear *string `json:"fiscal_year,omitempty"`

			// Sic The Standard Industrial Classification (SIC) code for the company.
			Sic *string `json:"sic,omitempty"`

			// SourceFilingFileUrl The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
			SourceFilingFileUrl *string `json:"source_filing_file_url,omitempty"`

			// SourceFilingUrl The URL of the SEC filing that these financials were derived from.
			SourceFilingUrl *string `json:"source_filing_url,omitempty"`

			// StartDate The start date of the period that these financials cover in YYYYMMDD format.
			StartDate *string `json:"start_date,omitempty"`

			// Tickers The list of ticker symbols for the company.
			Tickers *[]string `json:"tickers,omitempty"`

			// Timeframe The timeframe of the report (quarterly, annual or ttm).
			Timeframe string `json:"timeframe"`
		} `json:"results"`

		// Status The status of this request's response.
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFinancialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFinancialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIPOsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextUrl If present, this value can be used to fetch the next page of data.
		NextUrl *string `json:"next_url,omitempty"`

		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results An array of results containing the requested data.
		Results *[]struct {
			// AnnouncedDate The date when the IPO event was announced.
			AnnouncedDate *openapi_types.Date `json:"announced_date,omitempty"`

			// CurrencyCode Underlying currency of the security.
			CurrencyCode *string `json:"currency_code,omitempty"`

			// FinalIssuePrice The price set by the company and its underwriters before the IPO goes live.
			FinalIssuePrice *float32 `json:"final_issue_price,omitempty"`

			// HighestOfferPrice The highest price within the IPO price range that the company might use to price the shares.
			HighestOfferPrice *float32 `json:"highest_offer_price,omitempty"`

			// IpoStatus The status of the IPO event. IPO events start out as status "rumor" or "pending". On listing day, the status changes to "new". After the listing day, the status changes to "history".
			//
			// The status "direct_listing_process" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
			IpoStatus ListIPOs200ResultsIpoStatus `json:"ipo_status"`

			// Isin International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
			Isin *string `json:"isin,omitempty"`

			// IssuerName Name of issuer.
			IssuerName string `json:"issuer_name"`

			// LastUpdated The date when the IPO event was last modified.
			LastUpdated openapi_types.Date `json:"last_updated"`

			// ListingDate First trading date for the newly listed entity.
			ListingDate *openapi_types.Date `json:"listing_date,omitempty"`

			// LotSize The minimum number of shares that can be bought or sold in a single transaction.
			LotSize *float32 `json:"lot_size,omitempty"`

			// LowestOfferPrice The lowest price within the IPO price range that the company is willing to offer its shares to investors.
			LowestOfferPrice *float32 `json:"lowest_offer_price,omitempty"`

			// MaxSharesOffered The upper limit of the shares that the company is offering to investors.
			MaxSharesOffered *float32 `json:"max_shares_offered,omitempty"`

			// MinSharesOffered The lower limit of shares that the company is willing to sell in the IPO.
			MinSharesOffered *float32 `json:"min_shares_offered,omitempty"`

			// PrimaryExchange Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
			PrimaryExchange *string `json:"primary_exchange,omitempty"`

			// SecurityDescription Description of the security.
			SecurityDescription *string `json:"security_description,omitempty"`

			// SecurityType The classification of the stock. For example, "CS" stands for Common Stock.
			SecurityType string `json:"security_type"`

			// SharesOutstanding The total number of shares that the company has issued and are held by investors.
			SharesOutstanding *float32 `json:"shares_outstanding,omitempty"`

			// Ticker The ticker symbol of the IPO event.
			Ticker string `json:"ticker"`

			// TotalOfferSize The total amount raised by the company for IPO.
			TotalOfferSize *float32 `json:"total_offer_size,omitempty"`

			// UsCode This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
			UsCode *string `json:"us_code,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type ListIPOs200ResultsIpoStatus string

// Status returns HTTPResponse.Status
func (r ListIPOsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIPOsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RequestId A request id assigned by the server.
		RequestId *string `json:"request_id,omitempty"`

		// Results Contains the requested event data for the specified ticker.
		Results *struct {
			// Events An array of event containing the requested data.
			Events *[]GetEvents_200_Results_Events_Item `json:"events,omitempty"`

			// Name The name of the asset.
			Name *string `json:"name,omitempty"`
		} `json:"results,omitempty"`

		// Status The status of this request's response.
		Status *string `json:"status,omitempty"`
	}
}
type GetEvents200ResultsEvents0 struct {
	// Date The date the event took place
	Date openapi_types.Date `json:"date"`

	// EventType The type of historical event for the asset
	EventType string `json:"event_type"`

	// TickerChange Details about a ticker change
	TickerChange *struct {
		// Ticker A ticker symbol
		Ticker *string `json:"ticker,omitempty"`
	} `json:"ticker_change,omitempty"`
}
type GetEvents_200_Results_Events_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBenzingaV1AnalystInsightsWithResponse request returning *GetBenzingaV1AnalystInsightsResponse
func (c *ClientWithResponses) GetBenzingaV1AnalystInsightsWithResponse(ctx context.Context, params *GetBenzingaV1AnalystInsightsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1AnalystInsightsResponse, error) {
	rsp, err := c.GetBenzingaV1AnalystInsights(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1AnalystInsightsResponse(rsp)
}

// GetBenzingaV1AnalystsWithResponse request returning *GetBenzingaV1AnalystsResponse
func (c *ClientWithResponses) GetBenzingaV1AnalystsWithResponse(ctx context.Context, params *GetBenzingaV1AnalystsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1AnalystsResponse, error) {
	rsp, err := c.GetBenzingaV1Analysts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1AnalystsResponse(rsp)
}

// GetBenzingaV1BullsBearsSayWithResponse request returning *GetBenzingaV1BullsBearsSayResponse
func (c *ClientWithResponses) GetBenzingaV1BullsBearsSayWithResponse(ctx context.Context, params *GetBenzingaV1BullsBearsSayParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1BullsBearsSayResponse, error) {
	rsp, err := c.GetBenzingaV1BullsBearsSay(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1BullsBearsSayResponse(rsp)
}

// GetBenzingaV1ConsensusRatingsWithResponse request returning *GetBenzingaV1ConsensusRatingsResponse
func (c *ClientWithResponses) GetBenzingaV1ConsensusRatingsWithResponse(ctx context.Context, ticker string, params *GetBenzingaV1ConsensusRatingsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1ConsensusRatingsResponse, error) {
	rsp, err := c.GetBenzingaV1ConsensusRatings(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1ConsensusRatingsResponse(rsp)
}

// GetBenzingaV1EarningsWithResponse request returning *GetBenzingaV1EarningsResponse
func (c *ClientWithResponses) GetBenzingaV1EarningsWithResponse(ctx context.Context, params *GetBenzingaV1EarningsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1EarningsResponse, error) {
	rsp, err := c.GetBenzingaV1Earnings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1EarningsResponse(rsp)
}

// GetBenzingaV1FirmsWithResponse request returning *GetBenzingaV1FirmsResponse
func (c *ClientWithResponses) GetBenzingaV1FirmsWithResponse(ctx context.Context, params *GetBenzingaV1FirmsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1FirmsResponse, error) {
	rsp, err := c.GetBenzingaV1Firms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1FirmsResponse(rsp)
}

// GetBenzingaV1GuidanceWithResponse request returning *GetBenzingaV1GuidanceResponse
func (c *ClientWithResponses) GetBenzingaV1GuidanceWithResponse(ctx context.Context, params *GetBenzingaV1GuidanceParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1GuidanceResponse, error) {
	rsp, err := c.GetBenzingaV1Guidance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1GuidanceResponse(rsp)
}

// GetBenzingaV1RatingsWithResponse request returning *GetBenzingaV1RatingsResponse
func (c *ClientWithResponses) GetBenzingaV1RatingsWithResponse(ctx context.Context, params *GetBenzingaV1RatingsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV1RatingsResponse, error) {
	rsp, err := c.GetBenzingaV1Ratings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV1RatingsResponse(rsp)
}

// GetBenzingaV2NewsWithResponse request returning *GetBenzingaV2NewsResponse
func (c *ClientWithResponses) GetBenzingaV2NewsWithResponse(ctx context.Context, params *GetBenzingaV2NewsParams, reqEditors ...RequestEditorFn) (*GetBenzingaV2NewsResponse, error) {
	rsp, err := c.GetBenzingaV2News(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenzingaV2NewsResponse(rsp)
}

// GetCryptoV1ExchangesWithResponse request returning *GetCryptoV1ExchangesResponse
func (c *ClientWithResponses) GetCryptoV1ExchangesWithResponse(ctx context.Context, params *GetCryptoV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetCryptoV1ExchangesResponse, error) {
	rsp, err := c.GetCryptoV1Exchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoV1ExchangesResponse(rsp)
}

// GetEtfGlobalV1AnalyticsWithResponse request returning *GetEtfGlobalV1AnalyticsResponse
func (c *ClientWithResponses) GetEtfGlobalV1AnalyticsWithResponse(ctx context.Context, params *GetEtfGlobalV1AnalyticsParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1AnalyticsResponse, error) {
	rsp, err := c.GetEtfGlobalV1Analytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEtfGlobalV1AnalyticsResponse(rsp)
}

// GetEtfGlobalV1ConstituentsWithResponse request returning *GetEtfGlobalV1ConstituentsResponse
func (c *ClientWithResponses) GetEtfGlobalV1ConstituentsWithResponse(ctx context.Context, params *GetEtfGlobalV1ConstituentsParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1ConstituentsResponse, error) {
	rsp, err := c.GetEtfGlobalV1Constituents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEtfGlobalV1ConstituentsResponse(rsp)
}

// GetEtfGlobalV1FundFlowsWithResponse request returning *GetEtfGlobalV1FundFlowsResponse
func (c *ClientWithResponses) GetEtfGlobalV1FundFlowsWithResponse(ctx context.Context, params *GetEtfGlobalV1FundFlowsParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1FundFlowsResponse, error) {
	rsp, err := c.GetEtfGlobalV1FundFlows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEtfGlobalV1FundFlowsResponse(rsp)
}

// GetEtfGlobalV1ProfilesWithResponse request returning *GetEtfGlobalV1ProfilesResponse
func (c *ClientWithResponses) GetEtfGlobalV1ProfilesWithResponse(ctx context.Context, params *GetEtfGlobalV1ProfilesParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1ProfilesResponse, error) {
	rsp, err := c.GetEtfGlobalV1Profiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEtfGlobalV1ProfilesResponse(rsp)
}

// GetEtfGlobalV1TaxonomiesWithResponse request returning *GetEtfGlobalV1TaxonomiesResponse
func (c *ClientWithResponses) GetEtfGlobalV1TaxonomiesWithResponse(ctx context.Context, params *GetEtfGlobalV1TaxonomiesParams, reqEditors ...RequestEditorFn) (*GetEtfGlobalV1TaxonomiesResponse, error) {
	rsp, err := c.GetEtfGlobalV1Taxonomies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEtfGlobalV1TaxonomiesResponse(rsp)
}

// GetFedV1InflationWithResponse request returning *GetFedV1InflationResponse
func (c *ClientWithResponses) GetFedV1InflationWithResponse(ctx context.Context, params *GetFedV1InflationParams, reqEditors ...RequestEditorFn) (*GetFedV1InflationResponse, error) {
	rsp, err := c.GetFedV1Inflation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFedV1InflationResponse(rsp)
}

// GetFedV1InflationExpectationsWithResponse request returning *GetFedV1InflationExpectationsResponse
func (c *ClientWithResponses) GetFedV1InflationExpectationsWithResponse(ctx context.Context, params *GetFedV1InflationExpectationsParams, reqEditors ...RequestEditorFn) (*GetFedV1InflationExpectationsResponse, error) {
	rsp, err := c.GetFedV1InflationExpectations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFedV1InflationExpectationsResponse(rsp)
}

// GetFedV1LaborMarketWithResponse request returning *GetFedV1LaborMarketResponse
func (c *ClientWithResponses) GetFedV1LaborMarketWithResponse(ctx context.Context, params *GetFedV1LaborMarketParams, reqEditors ...RequestEditorFn) (*GetFedV1LaborMarketResponse, error) {
	rsp, err := c.GetFedV1LaborMarket(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFedV1LaborMarketResponse(rsp)
}

// GetFedV1TreasuryYieldsWithResponse request returning *GetFedV1TreasuryYieldsResponse
func (c *ClientWithResponses) GetFedV1TreasuryYieldsWithResponse(ctx context.Context, params *GetFedV1TreasuryYieldsParams, reqEditors ...RequestEditorFn) (*GetFedV1TreasuryYieldsResponse, error) {
	rsp, err := c.GetFedV1TreasuryYields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFedV1TreasuryYieldsResponse(rsp)
}

// GetForexV1ExchangesWithResponse request returning *GetForexV1ExchangesResponse
func (c *ClientWithResponses) GetForexV1ExchangesWithResponse(ctx context.Context, params *GetForexV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetForexV1ExchangesResponse, error) {
	rsp, err := c.GetForexV1Exchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexV1ExchangesResponse(rsp)
}

// GetFuturesAggregatesWithResponse request returning *GetFuturesAggregatesResponse
func (c *ClientWithResponses) GetFuturesAggregatesWithResponse(ctx context.Context, ticker string, params *GetFuturesAggregatesParams, reqEditors ...RequestEditorFn) (*GetFuturesAggregatesResponse, error) {
	rsp, err := c.GetFuturesAggregates(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesAggregatesResponse(rsp)
}

// GetFuturesVXContractsWithResponse request returning *GetFuturesVXContractsResponse
func (c *ClientWithResponses) GetFuturesVXContractsWithResponse(ctx context.Context, params *GetFuturesVXContractsParams, reqEditors ...RequestEditorFn) (*GetFuturesVXContractsResponse, error) {
	rsp, err := c.GetFuturesVXContracts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXContractsResponse(rsp)
}

// GetFuturesVXExchangesWithResponse request returning *GetFuturesVXExchangesResponse
func (c *ClientWithResponses) GetFuturesVXExchangesWithResponse(ctx context.Context, params *GetFuturesVXExchangesParams, reqEditors ...RequestEditorFn) (*GetFuturesVXExchangesResponse, error) {
	rsp, err := c.GetFuturesVXExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXExchangesResponse(rsp)
}

// GetFuturesVXMarketStatusWithResponse request returning *GetFuturesVXMarketStatusResponse
func (c *ClientWithResponses) GetFuturesVXMarketStatusWithResponse(ctx context.Context, params *GetFuturesVXMarketStatusParams, reqEditors ...RequestEditorFn) (*GetFuturesVXMarketStatusResponse, error) {
	rsp, err := c.GetFuturesVXMarketStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXMarketStatusResponse(rsp)
}

// GetFuturesVXProductsWithResponse request returning *GetFuturesVXProductsResponse
func (c *ClientWithResponses) GetFuturesVXProductsWithResponse(ctx context.Context, params *GetFuturesVXProductsParams, reqEditors ...RequestEditorFn) (*GetFuturesVXProductsResponse, error) {
	rsp, err := c.GetFuturesVXProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXProductsResponse(rsp)
}

// GetFuturesVXQuotesNewWithResponse request returning *GetFuturesVXQuotesNewResponse
func (c *ClientWithResponses) GetFuturesVXQuotesNewWithResponse(ctx context.Context, ticker string, params *GetFuturesVXQuotesNewParams, reqEditors ...RequestEditorFn) (*GetFuturesVXQuotesNewResponse, error) {
	rsp, err := c.GetFuturesVXQuotesNew(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXQuotesNewResponse(rsp)
}

// GetFuturesQuotesWithResponse request returning *GetFuturesQuotesResponse
func (c *ClientWithResponses) GetFuturesQuotesWithResponse(ctx context.Context, ticker string, params *GetFuturesQuotesParams, reqEditors ...RequestEditorFn) (*GetFuturesQuotesResponse, error) {
	rsp, err := c.GetFuturesQuotes(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesQuotesResponse(rsp)
}

// GetFuturesVXSchedulesWithResponse request returning *GetFuturesVXSchedulesResponse
func (c *ClientWithResponses) GetFuturesVXSchedulesWithResponse(ctx context.Context, params *GetFuturesVXSchedulesParams, reqEditors ...RequestEditorFn) (*GetFuturesVXSchedulesResponse, error) {
	rsp, err := c.GetFuturesVXSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXSchedulesResponse(rsp)
}

// GetFuturesVXSnapshotWithResponse request returning *GetFuturesVXSnapshotResponse
func (c *ClientWithResponses) GetFuturesVXSnapshotWithResponse(ctx context.Context, params *GetFuturesVXSnapshotParams, reqEditors ...RequestEditorFn) (*GetFuturesVXSnapshotResponse, error) {
	rsp, err := c.GetFuturesVXSnapshot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXSnapshotResponse(rsp)
}

// GetFuturesVXSnapshotNativeWithResponse request returning *GetFuturesVXSnapshotNativeResponse
func (c *ClientWithResponses) GetFuturesVXSnapshotNativeWithResponse(ctx context.Context, params *GetFuturesVXSnapshotNativeParams, reqEditors ...RequestEditorFn) (*GetFuturesVXSnapshotNativeResponse, error) {
	rsp, err := c.GetFuturesVXSnapshotNative(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXSnapshotNativeResponse(rsp)
}

// GetFuturesVXTradesNewWithResponse request returning *GetFuturesVXTradesNewResponse
func (c *ClientWithResponses) GetFuturesVXTradesNewWithResponse(ctx context.Context, ticker string, params *GetFuturesVXTradesNewParams, reqEditors ...RequestEditorFn) (*GetFuturesVXTradesNewResponse, error) {
	rsp, err := c.GetFuturesVXTradesNew(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesVXTradesNewResponse(rsp)
}

// GetFuturesTradesWithResponse request returning *GetFuturesTradesResponse
func (c *ClientWithResponses) GetFuturesTradesWithResponse(ctx context.Context, ticker string, params *GetFuturesTradesParams, reqEditors ...RequestEditorFn) (*GetFuturesTradesResponse, error) {
	rsp, err := c.GetFuturesTrades(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFuturesTradesResponse(rsp)
}

// GetOptionsV1ExchangesWithResponse request returning *GetOptionsV1ExchangesResponse
func (c *ClientWithResponses) GetOptionsV1ExchangesWithResponse(ctx context.Context, params *GetOptionsV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetOptionsV1ExchangesResponse, error) {
	rsp, err := c.GetOptionsV1Exchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsV1ExchangesResponse(rsp)
}

// GetStocksFilings10KVXSectionsWithResponse request returning *GetStocksFilings10KVXSectionsResponse
func (c *ClientWithResponses) GetStocksFilings10KVXSectionsWithResponse(ctx context.Context, params *GetStocksFilings10KVXSectionsParams, reqEditors ...RequestEditorFn) (*GetStocksFilings10KVXSectionsResponse, error) {
	rsp, err := c.GetStocksFilings10KVXSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFilings10KVXSectionsResponse(rsp)
}

// GetStocksFilingsVXIndexWithResponse request returning *GetStocksFilingsVXIndexResponse
func (c *ClientWithResponses) GetStocksFilingsVXIndexWithResponse(ctx context.Context, params *GetStocksFilingsVXIndexParams, reqEditors ...RequestEditorFn) (*GetStocksFilingsVXIndexResponse, error) {
	rsp, err := c.GetStocksFilingsVXIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFilingsVXIndexResponse(rsp)
}

// GetStocksFilingsVXRiskFactorsWithResponse request returning *GetStocksFilingsVXRiskFactorsResponse
func (c *ClientWithResponses) GetStocksFilingsVXRiskFactorsWithResponse(ctx context.Context, params *GetStocksFilingsVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*GetStocksFilingsVXRiskFactorsResponse, error) {
	rsp, err := c.GetStocksFilingsVXRiskFactors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFilingsVXRiskFactorsResponse(rsp)
}

// GetStocksFinancialsV1BalanceSheetsWithResponse request returning *GetStocksFinancialsV1BalanceSheetsResponse
func (c *ClientWithResponses) GetStocksFinancialsV1BalanceSheetsWithResponse(ctx context.Context, params *GetStocksFinancialsV1BalanceSheetsParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1BalanceSheetsResponse, error) {
	rsp, err := c.GetStocksFinancialsV1BalanceSheets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFinancialsV1BalanceSheetsResponse(rsp)
}

// GetStocksFinancialsV1CashFlowStatementsWithResponse request returning *GetStocksFinancialsV1CashFlowStatementsResponse
func (c *ClientWithResponses) GetStocksFinancialsV1CashFlowStatementsWithResponse(ctx context.Context, params *GetStocksFinancialsV1CashFlowStatementsParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1CashFlowStatementsResponse, error) {
	rsp, err := c.GetStocksFinancialsV1CashFlowStatements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFinancialsV1CashFlowStatementsResponse(rsp)
}

// GetStocksFinancialsV1IncomeStatementsWithResponse request returning *GetStocksFinancialsV1IncomeStatementsResponse
func (c *ClientWithResponses) GetStocksFinancialsV1IncomeStatementsWithResponse(ctx context.Context, params *GetStocksFinancialsV1IncomeStatementsParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1IncomeStatementsResponse, error) {
	rsp, err := c.GetStocksFinancialsV1IncomeStatements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFinancialsV1IncomeStatementsResponse(rsp)
}

// GetStocksFinancialsV1RatiosWithResponse request returning *GetStocksFinancialsV1RatiosResponse
func (c *ClientWithResponses) GetStocksFinancialsV1RatiosWithResponse(ctx context.Context, params *GetStocksFinancialsV1RatiosParams, reqEditors ...RequestEditorFn) (*GetStocksFinancialsV1RatiosResponse, error) {
	rsp, err := c.GetStocksFinancialsV1Ratios(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksFinancialsV1RatiosResponse(rsp)
}

// GetStocksTaxonomiesVXRiskFactorsWithResponse request returning *GetStocksTaxonomiesVXRiskFactorsResponse
func (c *ClientWithResponses) GetStocksTaxonomiesVXRiskFactorsWithResponse(ctx context.Context, params *GetStocksTaxonomiesVXRiskFactorsParams, reqEditors ...RequestEditorFn) (*GetStocksTaxonomiesVXRiskFactorsResponse, error) {
	rsp, err := c.GetStocksTaxonomiesVXRiskFactors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksTaxonomiesVXRiskFactorsResponse(rsp)
}

// GetStocksV1DividendsWithResponse request returning *GetStocksV1DividendsResponse
func (c *ClientWithResponses) GetStocksV1DividendsWithResponse(ctx context.Context, params *GetStocksV1DividendsParams, reqEditors ...RequestEditorFn) (*GetStocksV1DividendsResponse, error) {
	rsp, err := c.GetStocksV1Dividends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksV1DividendsResponse(rsp)
}

// GetStocksV1ExchangesWithResponse request returning *GetStocksV1ExchangesResponse
func (c *ClientWithResponses) GetStocksV1ExchangesWithResponse(ctx context.Context, params *GetStocksV1ExchangesParams, reqEditors ...RequestEditorFn) (*GetStocksV1ExchangesResponse, error) {
	rsp, err := c.GetStocksV1Exchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksV1ExchangesResponse(rsp)
}

// GetStocksV1ShortInterestWithResponse request returning *GetStocksV1ShortInterestResponse
func (c *ClientWithResponses) GetStocksV1ShortInterestWithResponse(ctx context.Context, params *GetStocksV1ShortInterestParams, reqEditors ...RequestEditorFn) (*GetStocksV1ShortInterestResponse, error) {
	rsp, err := c.GetStocksV1ShortInterest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksV1ShortInterestResponse(rsp)
}

// GetStocksV1ShortVolumeWithResponse request returning *GetStocksV1ShortVolumeResponse
func (c *ClientWithResponses) GetStocksV1ShortVolumeWithResponse(ctx context.Context, params *GetStocksV1ShortVolumeParams, reqEditors ...RequestEditorFn) (*GetStocksV1ShortVolumeResponse, error) {
	rsp, err := c.GetStocksV1ShortVolume(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksV1ShortVolumeResponse(rsp)
}

// GetStocksV1SplitsWithResponse request returning *GetStocksV1SplitsResponse
func (c *ClientWithResponses) GetStocksV1SplitsWithResponse(ctx context.Context, params *GetStocksV1SplitsParams, reqEditors ...RequestEditorFn) (*GetStocksV1SplitsResponse, error) {
	rsp, err := c.GetStocksV1Splits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksV1SplitsResponse(rsp)
}

// GetStocksVXFloatWithResponse request returning *GetStocksVXFloatResponse
func (c *ClientWithResponses) GetStocksVXFloatWithResponse(ctx context.Context, params *GetStocksVXFloatParams, reqEditors ...RequestEditorFn) (*GetStocksVXFloatResponse, error) {
	rsp, err := c.GetStocksVXFloat(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksVXFloatResponse(rsp)
}

// GetTmxV1CorporateEventsWithResponse request returning *GetTmxV1CorporateEventsResponse
func (c *ClientWithResponses) GetTmxV1CorporateEventsWithResponse(ctx context.Context, params *GetTmxV1CorporateEventsParams, reqEditors ...RequestEditorFn) (*GetTmxV1CorporateEventsResponse, error) {
	rsp, err := c.GetTmxV1CorporateEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTmxV1CorporateEventsResponse(rsp)
}

// GetCurrencyConversionWithResponse request returning *GetCurrencyConversionResponse
func (c *ClientWithResponses) GetCurrencyConversionWithResponse(ctx context.Context, from string, to string, params *GetCurrencyConversionParams, reqEditors ...RequestEditorFn) (*GetCurrencyConversionResponse, error) {
	rsp, err := c.GetCurrencyConversion(ctx, from, to, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrencyConversionResponse(rsp)
}

// DeprecatedGetHistoricCryptoTradesWithResponse request returning *DeprecatedGetHistoricCryptoTradesResponse
func (c *ClientWithResponses) DeprecatedGetHistoricCryptoTradesWithResponse(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricCryptoTradesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricCryptoTradesResponse, error) {
	rsp, err := c.DeprecatedGetHistoricCryptoTrades(ctx, from, to, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedGetHistoricCryptoTradesResponse(rsp)
}

// DeprecatedGetHistoricForexQuotesWithResponse request returning *DeprecatedGetHistoricForexQuotesResponse
func (c *ClientWithResponses) DeprecatedGetHistoricForexQuotesWithResponse(ctx context.Context, from string, to string, date openapi_types.Date, params *DeprecatedGetHistoricForexQuotesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricForexQuotesResponse, error) {
	rsp, err := c.DeprecatedGetHistoricForexQuotes(ctx, from, to, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedGetHistoricForexQuotesResponse(rsp)
}

// GetCryptoEMAWithResponse request returning *GetCryptoEMAResponse
func (c *ClientWithResponses) GetCryptoEMAWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoEMAParams, reqEditors ...RequestEditorFn) (*GetCryptoEMAResponse, error) {
	rsp, err := c.GetCryptoEMA(ctx, cryptoTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoEMAResponse(rsp)
}

// GetForexEMAWithResponse request returning *GetForexEMAResponse
func (c *ClientWithResponses) GetForexEMAWithResponse(ctx context.Context, fxTicker string, params *GetForexEMAParams, reqEditors ...RequestEditorFn) (*GetForexEMAResponse, error) {
	rsp, err := c.GetForexEMA(ctx, fxTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexEMAResponse(rsp)
}

// GetIndicesEMAWithResponse request returning *GetIndicesEMAResponse
func (c *ClientWithResponses) GetIndicesEMAWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesEMAParams, reqEditors ...RequestEditorFn) (*GetIndicesEMAResponse, error) {
	rsp, err := c.GetIndicesEMA(ctx, indicesTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesEMAResponse(rsp)
}

// GetOptionsEMAWithResponse request returning *GetOptionsEMAResponse
func (c *ClientWithResponses) GetOptionsEMAWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsEMAParams, reqEditors ...RequestEditorFn) (*GetOptionsEMAResponse, error) {
	rsp, err := c.GetOptionsEMA(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsEMAResponse(rsp)
}

// GetStocksEMAWithResponse request returning *GetStocksEMAResponse
func (c *ClientWithResponses) GetStocksEMAWithResponse(ctx context.Context, stockTicker string, params *GetStocksEMAParams, reqEditors ...RequestEditorFn) (*GetStocksEMAResponse, error) {
	rsp, err := c.GetStocksEMA(ctx, stockTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksEMAResponse(rsp)
}

// GetCryptoMACDWithResponse request returning *GetCryptoMACDResponse
func (c *ClientWithResponses) GetCryptoMACDWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoMACDParams, reqEditors ...RequestEditorFn) (*GetCryptoMACDResponse, error) {
	rsp, err := c.GetCryptoMACD(ctx, cryptoTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoMACDResponse(rsp)
}

// GetForexMACDWithResponse request returning *GetForexMACDResponse
func (c *ClientWithResponses) GetForexMACDWithResponse(ctx context.Context, fxTicker string, params *GetForexMACDParams, reqEditors ...RequestEditorFn) (*GetForexMACDResponse, error) {
	rsp, err := c.GetForexMACD(ctx, fxTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexMACDResponse(rsp)
}

// GetIndicesMACDWithResponse request returning *GetIndicesMACDResponse
func (c *ClientWithResponses) GetIndicesMACDWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesMACDParams, reqEditors ...RequestEditorFn) (*GetIndicesMACDResponse, error) {
	rsp, err := c.GetIndicesMACD(ctx, indicesTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesMACDResponse(rsp)
}

// GetOptionsMACDWithResponse request returning *GetOptionsMACDResponse
func (c *ClientWithResponses) GetOptionsMACDWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsMACDParams, reqEditors ...RequestEditorFn) (*GetOptionsMACDResponse, error) {
	rsp, err := c.GetOptionsMACD(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsMACDResponse(rsp)
}

// GetStocksMACDWithResponse request returning *GetStocksMACDResponse
func (c *ClientWithResponses) GetStocksMACDWithResponse(ctx context.Context, stockTicker string, params *GetStocksMACDParams, reqEditors ...RequestEditorFn) (*GetStocksMACDResponse, error) {
	rsp, err := c.GetStocksMACD(ctx, stockTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksMACDResponse(rsp)
}

// GetCryptoRSIWithResponse request returning *GetCryptoRSIResponse
func (c *ClientWithResponses) GetCryptoRSIWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoRSIParams, reqEditors ...RequestEditorFn) (*GetCryptoRSIResponse, error) {
	rsp, err := c.GetCryptoRSI(ctx, cryptoTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoRSIResponse(rsp)
}

// GetForexRSIWithResponse request returning *GetForexRSIResponse
func (c *ClientWithResponses) GetForexRSIWithResponse(ctx context.Context, fxTicker string, params *GetForexRSIParams, reqEditors ...RequestEditorFn) (*GetForexRSIResponse, error) {
	rsp, err := c.GetForexRSI(ctx, fxTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexRSIResponse(rsp)
}

// GetIndicesRSIWithResponse request returning *GetIndicesRSIResponse
func (c *ClientWithResponses) GetIndicesRSIWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesRSIParams, reqEditors ...RequestEditorFn) (*GetIndicesRSIResponse, error) {
	rsp, err := c.GetIndicesRSI(ctx, indicesTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesRSIResponse(rsp)
}

// GetOptionsRSIWithResponse request returning *GetOptionsRSIResponse
func (c *ClientWithResponses) GetOptionsRSIWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsRSIParams, reqEditors ...RequestEditorFn) (*GetOptionsRSIResponse, error) {
	rsp, err := c.GetOptionsRSI(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsRSIResponse(rsp)
}

// GetStocksRSIWithResponse request returning *GetStocksRSIResponse
func (c *ClientWithResponses) GetStocksRSIWithResponse(ctx context.Context, stockTicker string, params *GetStocksRSIParams, reqEditors ...RequestEditorFn) (*GetStocksRSIResponse, error) {
	rsp, err := c.GetStocksRSI(ctx, stockTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksRSIResponse(rsp)
}

// GetCryptoSMAWithResponse request returning *GetCryptoSMAResponse
func (c *ClientWithResponses) GetCryptoSMAWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoSMAParams, reqEditors ...RequestEditorFn) (*GetCryptoSMAResponse, error) {
	rsp, err := c.GetCryptoSMA(ctx, cryptoTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoSMAResponse(rsp)
}

// GetForexSMAWithResponse request returning *GetForexSMAResponse
func (c *ClientWithResponses) GetForexSMAWithResponse(ctx context.Context, fxTicker string, params *GetForexSMAParams, reqEditors ...RequestEditorFn) (*GetForexSMAResponse, error) {
	rsp, err := c.GetForexSMA(ctx, fxTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexSMAResponse(rsp)
}

// GetIndicesSMAWithResponse request returning *GetIndicesSMAResponse
func (c *ClientWithResponses) GetIndicesSMAWithResponse(ctx context.Context, indicesTicker string, params *GetIndicesSMAParams, reqEditors ...RequestEditorFn) (*GetIndicesSMAResponse, error) {
	rsp, err := c.GetIndicesSMA(ctx, indicesTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesSMAResponse(rsp)
}

// GetOptionsSMAWithResponse request returning *GetOptionsSMAResponse
func (c *ClientWithResponses) GetOptionsSMAWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsSMAParams, reqEditors ...RequestEditorFn) (*GetOptionsSMAResponse, error) {
	rsp, err := c.GetOptionsSMA(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsSMAResponse(rsp)
}

// GetStocksSMAWithResponse request returning *GetStocksSMAResponse
func (c *ClientWithResponses) GetStocksSMAWithResponse(ctx context.Context, stockTicker string, params *GetStocksSMAParams, reqEditors ...RequestEditorFn) (*GetStocksSMAResponse, error) {
	rsp, err := c.GetStocksSMA(ctx, stockTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksSMAResponse(rsp)
}

// GetLastCryptoTradeWithResponse request returning *GetLastCryptoTradeResponse
func (c *ClientWithResponses) GetLastCryptoTradeWithResponse(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*GetLastCryptoTradeResponse, error) {
	rsp, err := c.GetLastCryptoTrade(ctx, from, to, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastCryptoTradeResponse(rsp)
}

// GetLastCurrencyQuoteWithResponse request returning *GetLastCurrencyQuoteResponse
func (c *ClientWithResponses) GetLastCurrencyQuoteWithResponse(ctx context.Context, from string, to string, reqEditors ...RequestEditorFn) (*GetLastCurrencyQuoteResponse, error) {
	rsp, err := c.GetLastCurrencyQuote(ctx, from, to, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastCurrencyQuoteResponse(rsp)
}

// GetMarketStatusWithResponse request returning *GetMarketStatusResponse
func (c *ClientWithResponses) GetMarketStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketStatusResponse, error) {
	rsp, err := c.GetMarketStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketStatusResponse(rsp)
}

// GetMarketHolidaysWithResponse request returning *GetMarketHolidaysResponse
func (c *ClientWithResponses) GetMarketHolidaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketHolidaysResponse, error) {
	rsp, err := c.GetMarketHolidays(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketHolidaysResponse(rsp)
}

// GetCryptoOpenCloseWithResponse request returning *GetCryptoOpenCloseResponse
func (c *ClientWithResponses) GetCryptoOpenCloseWithResponse(ctx context.Context, from string, to string, date openapi_types.Date, params *GetCryptoOpenCloseParams, reqEditors ...RequestEditorFn) (*GetCryptoOpenCloseResponse, error) {
	rsp, err := c.GetCryptoOpenClose(ctx, from, to, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoOpenCloseResponse(rsp)
}

// GetIndicesOpenCloseWithResponse request returning *GetIndicesOpenCloseResponse
func (c *ClientWithResponses) GetIndicesOpenCloseWithResponse(ctx context.Context, indicesTicker string, date string, reqEditors ...RequestEditorFn) (*GetIndicesOpenCloseResponse, error) {
	rsp, err := c.GetIndicesOpenClose(ctx, indicesTicker, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesOpenCloseResponse(rsp)
}

// GetOptionsOpenCloseWithResponse request returning *GetOptionsOpenCloseResponse
func (c *ClientWithResponses) GetOptionsOpenCloseWithResponse(ctx context.Context, optionsTicker string, date openapi_types.Date, params *GetOptionsOpenCloseParams, reqEditors ...RequestEditorFn) (*GetOptionsOpenCloseResponse, error) {
	rsp, err := c.GetOptionsOpenClose(ctx, optionsTicker, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsOpenCloseResponse(rsp)
}

// GetStocksOpenCloseWithResponse request returning *GetStocksOpenCloseResponse
func (c *ClientWithResponses) GetStocksOpenCloseWithResponse(ctx context.Context, stocksTicker string, date openapi_types.Date, params *GetStocksOpenCloseParams, reqEditors ...RequestEditorFn) (*GetStocksOpenCloseResponse, error) {
	rsp, err := c.GetStocksOpenClose(ctx, stocksTicker, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksOpenCloseResponse(rsp)
}

// GetV1ReferenceIposWithResponse request returning *GetV1ReferenceIposResponse
func (c *ClientWithResponses) GetV1ReferenceIposWithResponse(ctx context.Context, params *GetV1ReferenceIposParams, reqEditors ...RequestEditorFn) (*GetV1ReferenceIposResponse, error) {
	rsp, err := c.GetV1ReferenceIpos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV1ReferenceIposResponse(rsp)
}

// GetRelatedCompaniesWithResponse request returning *GetRelatedCompaniesResponse
func (c *ClientWithResponses) GetRelatedCompaniesWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*GetRelatedCompaniesResponse, error) {
	rsp, err := c.GetRelatedCompanies(ctx, ticker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRelatedCompaniesResponse(rsp)
}

// GetSnapshotSummaryWithResponse request returning *GetSnapshotSummaryResponse
func (c *ClientWithResponses) GetSnapshotSummaryWithResponse(ctx context.Context, params *GetSnapshotSummaryParams, reqEditors ...RequestEditorFn) (*GetSnapshotSummaryResponse, error) {
	rsp, err := c.GetSnapshotSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSnapshotSummaryResponse(rsp)
}

// GetGroupedCryptoAggregatesWithResponse request returning *GetGroupedCryptoAggregatesResponse
func (c *ClientWithResponses) GetGroupedCryptoAggregatesWithResponse(ctx context.Context, date string, params *GetGroupedCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*GetGroupedCryptoAggregatesResponse, error) {
	rsp, err := c.GetGroupedCryptoAggregates(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupedCryptoAggregatesResponse(rsp)
}

// GetGroupedForexAggregatesWithResponse request returning *GetGroupedForexAggregatesResponse
func (c *ClientWithResponses) GetGroupedForexAggregatesWithResponse(ctx context.Context, date string, params *GetGroupedForexAggregatesParams, reqEditors ...RequestEditorFn) (*GetGroupedForexAggregatesResponse, error) {
	rsp, err := c.GetGroupedForexAggregates(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupedForexAggregatesResponse(rsp)
}

// GetGroupedStocksAggregatesWithResponse request returning *GetGroupedStocksAggregatesResponse
func (c *ClientWithResponses) GetGroupedStocksAggregatesWithResponse(ctx context.Context, date string, params *GetGroupedStocksAggregatesParams, reqEditors ...RequestEditorFn) (*GetGroupedStocksAggregatesResponse, error) {
	rsp, err := c.GetGroupedStocksAggregates(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupedStocksAggregatesResponse(rsp)
}

// GetPreviousCryptoAggregatesWithResponse request returning *GetPreviousCryptoAggregatesResponse
func (c *ClientWithResponses) GetPreviousCryptoAggregatesWithResponse(ctx context.Context, cryptoTicker string, params *GetPreviousCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousCryptoAggregatesResponse, error) {
	rsp, err := c.GetPreviousCryptoAggregates(ctx, cryptoTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreviousCryptoAggregatesResponse(rsp)
}

// GetCryptoAggregatesWithResponse request returning *GetCryptoAggregatesResponse
func (c *ClientWithResponses) GetCryptoAggregatesWithResponse(ctx context.Context, cryptoTicker string, multiplier int, timespan GetCryptoAggregatesParamsTimespan, from string, to string, params *GetCryptoAggregatesParams, reqEditors ...RequestEditorFn) (*GetCryptoAggregatesResponse, error) {
	rsp, err := c.GetCryptoAggregates(ctx, cryptoTicker, multiplier, timespan, from, to, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoAggregatesResponse(rsp)
}

// GetPreviousForexAggregatesWithResponse request returning *GetPreviousForexAggregatesResponse
func (c *ClientWithResponses) GetPreviousForexAggregatesWithResponse(ctx context.Context, forexTicker string, params *GetPreviousForexAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousForexAggregatesResponse, error) {
	rsp, err := c.GetPreviousForexAggregates(ctx, forexTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreviousForexAggregatesResponse(rsp)
}

// GetForexAggregatesWithResponse request returning *GetForexAggregatesResponse
func (c *ClientWithResponses) GetForexAggregatesWithResponse(ctx context.Context, forexTicker string, multiplier int, timespan GetForexAggregatesParamsTimespan, from string, to string, params *GetForexAggregatesParams, reqEditors ...RequestEditorFn) (*GetForexAggregatesResponse, error) {
	rsp, err := c.GetForexAggregates(ctx, forexTicker, multiplier, timespan, from, to, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexAggregatesResponse(rsp)
}

// GetPreviousIndicesAggregatesWithResponse request returning *GetPreviousIndicesAggregatesResponse
func (c *ClientWithResponses) GetPreviousIndicesAggregatesWithResponse(ctx context.Context, indicesTicker string, reqEditors ...RequestEditorFn) (*GetPreviousIndicesAggregatesResponse, error) {
	rsp, err := c.GetPreviousIndicesAggregates(ctx, indicesTicker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreviousIndicesAggregatesResponse(rsp)
}

// GetIndicesAggregatesWithResponse request returning *GetIndicesAggregatesResponse
func (c *ClientWithResponses) GetIndicesAggregatesWithResponse(ctx context.Context, indicesTicker string, multiplier int, timespan GetIndicesAggregatesParamsTimespan, from string, to string, params *GetIndicesAggregatesParams, reqEditors ...RequestEditorFn) (*GetIndicesAggregatesResponse, error) {
	rsp, err := c.GetIndicesAggregates(ctx, indicesTicker, multiplier, timespan, from, to, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesAggregatesResponse(rsp)
}

// GetPreviousOptionsAggregatesWithResponse request returning *GetPreviousOptionsAggregatesResponse
func (c *ClientWithResponses) GetPreviousOptionsAggregatesWithResponse(ctx context.Context, optionsTicker string, params *GetPreviousOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousOptionsAggregatesResponse, error) {
	rsp, err := c.GetPreviousOptionsAggregates(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreviousOptionsAggregatesResponse(rsp)
}

// GetOptionsAggregatesWithResponse request returning *GetOptionsAggregatesResponse
func (c *ClientWithResponses) GetOptionsAggregatesWithResponse(ctx context.Context, optionsTicker string, multiplier int, timespan GetOptionsAggregatesParamsTimespan, from string, to string, params *GetOptionsAggregatesParams, reqEditors ...RequestEditorFn) (*GetOptionsAggregatesResponse, error) {
	rsp, err := c.GetOptionsAggregates(ctx, optionsTicker, multiplier, timespan, from, to, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsAggregatesResponse(rsp)
}

// GetPreviousStocksAggregatesWithResponse request returning *GetPreviousStocksAggregatesResponse
func (c *ClientWithResponses) GetPreviousStocksAggregatesWithResponse(ctx context.Context, stocksTicker string, params *GetPreviousStocksAggregatesParams, reqEditors ...RequestEditorFn) (*GetPreviousStocksAggregatesResponse, error) {
	rsp, err := c.GetPreviousStocksAggregates(ctx, stocksTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreviousStocksAggregatesResponse(rsp)
}

// GetStocksAggregatesWithResponse request returning *GetStocksAggregatesResponse
func (c *ClientWithResponses) GetStocksAggregatesWithResponse(ctx context.Context, stocksTicker string, multiplier int, timespan GetStocksAggregatesParamsTimespan, from string, to string, params *GetStocksAggregatesParams, reqEditors ...RequestEditorFn) (*GetStocksAggregatesResponse, error) {
	rsp, err := c.GetStocksAggregates(ctx, stocksTicker, multiplier, timespan, from, to, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksAggregatesResponse(rsp)
}

// GetLastStocksQuoteWithResponse request returning *GetLastStocksQuoteResponse
func (c *ClientWithResponses) GetLastStocksQuoteWithResponse(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*GetLastStocksQuoteResponse, error) {
	rsp, err := c.GetLastStocksQuote(ctx, stocksTicker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastStocksQuoteResponse(rsp)
}

// GetLastOptionsTradeWithResponse request returning *GetLastOptionsTradeResponse
func (c *ClientWithResponses) GetLastOptionsTradeWithResponse(ctx context.Context, optionsTicker string, reqEditors ...RequestEditorFn) (*GetLastOptionsTradeResponse, error) {
	rsp, err := c.GetLastOptionsTrade(ctx, optionsTicker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastOptionsTradeResponse(rsp)
}

// GetLastStocksTradeWithResponse request returning *GetLastStocksTradeResponse
func (c *ClientWithResponses) GetLastStocksTradeWithResponse(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*GetLastStocksTradeResponse, error) {
	rsp, err := c.GetLastStocksTrade(ctx, stocksTicker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastStocksTradeResponse(rsp)
}

// ListNewsWithResponse request returning *ListNewsResponse
func (c *ClientWithResponses) ListNewsWithResponse(ctx context.Context, params *ListNewsParams, reqEditors ...RequestEditorFn) (*ListNewsResponse, error) {
	rsp, err := c.ListNews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNewsResponse(rsp)
}

// GetCryptoSnapshotTickersWithResponse request returning *GetCryptoSnapshotTickersResponse
func (c *ClientWithResponses) GetCryptoSnapshotTickersWithResponse(ctx context.Context, params *GetCryptoSnapshotTickersParams, reqEditors ...RequestEditorFn) (*GetCryptoSnapshotTickersResponse, error) {
	rsp, err := c.GetCryptoSnapshotTickers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoSnapshotTickersResponse(rsp)
}

// GetCryptoSnapshotTickerWithResponse request returning *GetCryptoSnapshotTickerResponse
func (c *ClientWithResponses) GetCryptoSnapshotTickerWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*GetCryptoSnapshotTickerResponse, error) {
	rsp, err := c.GetCryptoSnapshotTicker(ctx, ticker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoSnapshotTickerResponse(rsp)
}

// DeprecatedGetCryptoSnapshotTickerBookWithResponse request returning *DeprecatedGetCryptoSnapshotTickerBookResponse
func (c *ClientWithResponses) DeprecatedGetCryptoSnapshotTickerBookWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*DeprecatedGetCryptoSnapshotTickerBookResponse, error) {
	rsp, err := c.DeprecatedGetCryptoSnapshotTickerBook(ctx, ticker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedGetCryptoSnapshotTickerBookResponse(rsp)
}

// GetCryptoSnapshotDirectionWithResponse request returning *GetCryptoSnapshotDirectionResponse
func (c *ClientWithResponses) GetCryptoSnapshotDirectionWithResponse(ctx context.Context, direction GetCryptoSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*GetCryptoSnapshotDirectionResponse, error) {
	rsp, err := c.GetCryptoSnapshotDirection(ctx, direction, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoSnapshotDirectionResponse(rsp)
}

// GetForexSnapshotTickersWithResponse request returning *GetForexSnapshotTickersResponse
func (c *ClientWithResponses) GetForexSnapshotTickersWithResponse(ctx context.Context, params *GetForexSnapshotTickersParams, reqEditors ...RequestEditorFn) (*GetForexSnapshotTickersResponse, error) {
	rsp, err := c.GetForexSnapshotTickers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexSnapshotTickersResponse(rsp)
}

// GetForexSnapshotTickerWithResponse request returning *GetForexSnapshotTickerResponse
func (c *ClientWithResponses) GetForexSnapshotTickerWithResponse(ctx context.Context, ticker string, reqEditors ...RequestEditorFn) (*GetForexSnapshotTickerResponse, error) {
	rsp, err := c.GetForexSnapshotTicker(ctx, ticker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexSnapshotTickerResponse(rsp)
}

// GetForexSnapshotDirectionWithResponse request returning *GetForexSnapshotDirectionResponse
func (c *ClientWithResponses) GetForexSnapshotDirectionWithResponse(ctx context.Context, direction GetForexSnapshotDirectionParamsDirection, reqEditors ...RequestEditorFn) (*GetForexSnapshotDirectionResponse, error) {
	rsp, err := c.GetForexSnapshotDirection(ctx, direction, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexSnapshotDirectionResponse(rsp)
}

// GetStocksSnapshotTickersWithResponse request returning *GetStocksSnapshotTickersResponse
func (c *ClientWithResponses) GetStocksSnapshotTickersWithResponse(ctx context.Context, params *GetStocksSnapshotTickersParams, reqEditors ...RequestEditorFn) (*GetStocksSnapshotTickersResponse, error) {
	rsp, err := c.GetStocksSnapshotTickers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksSnapshotTickersResponse(rsp)
}

// GetStocksSnapshotTickerWithResponse request returning *GetStocksSnapshotTickerResponse
func (c *ClientWithResponses) GetStocksSnapshotTickerWithResponse(ctx context.Context, stocksTicker string, reqEditors ...RequestEditorFn) (*GetStocksSnapshotTickerResponse, error) {
	rsp, err := c.GetStocksSnapshotTicker(ctx, stocksTicker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksSnapshotTickerResponse(rsp)
}

// GetStocksSnapshotDirectionWithResponse request returning *GetStocksSnapshotDirectionResponse
func (c *ClientWithResponses) GetStocksSnapshotDirectionWithResponse(ctx context.Context, direction GetStocksSnapshotDirectionParamsDirection, params *GetStocksSnapshotDirectionParams, reqEditors ...RequestEditorFn) (*GetStocksSnapshotDirectionResponse, error) {
	rsp, err := c.GetStocksSnapshotDirection(ctx, direction, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksSnapshotDirectionResponse(rsp)
}

// DeprecatedGetHistoricStocksQuotesWithResponse request returning *DeprecatedGetHistoricStocksQuotesResponse
func (c *ClientWithResponses) DeprecatedGetHistoricStocksQuotesWithResponse(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksQuotesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricStocksQuotesResponse, error) {
	rsp, err := c.DeprecatedGetHistoricStocksQuotes(ctx, ticker, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedGetHistoricStocksQuotesResponse(rsp)
}

// DeprecatedGetHistoricStocksTradesWithResponse request returning *DeprecatedGetHistoricStocksTradesResponse
func (c *ClientWithResponses) DeprecatedGetHistoricStocksTradesWithResponse(ctx context.Context, ticker string, date openapi_types.Date, params *DeprecatedGetHistoricStocksTradesParams, reqEditors ...RequestEditorFn) (*DeprecatedGetHistoricStocksTradesResponse, error) {
	rsp, err := c.DeprecatedGetHistoricStocksTrades(ctx, ticker, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedGetHistoricStocksTradesResponse(rsp)
}

// GetForexQuotesWithResponse request returning *GetForexQuotesResponse
func (c *ClientWithResponses) GetForexQuotesWithResponse(ctx context.Context, fxTicker string, params *GetForexQuotesParams, reqEditors ...RequestEditorFn) (*GetForexQuotesResponse, error) {
	rsp, err := c.GetForexQuotes(ctx, fxTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForexQuotesResponse(rsp)
}

// GetOptionsQuotesWithResponse request returning *GetOptionsQuotesResponse
func (c *ClientWithResponses) GetOptionsQuotesWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsQuotesParams, reqEditors ...RequestEditorFn) (*GetOptionsQuotesResponse, error) {
	rsp, err := c.GetOptionsQuotes(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsQuotesResponse(rsp)
}

// GetStocksQuotesWithResponse request returning *GetStocksQuotesResponse
func (c *ClientWithResponses) GetStocksQuotesWithResponse(ctx context.Context, stockTicker string, params *GetStocksQuotesParams, reqEditors ...RequestEditorFn) (*GetStocksQuotesResponse, error) {
	rsp, err := c.GetStocksQuotes(ctx, stockTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksQuotesResponse(rsp)
}

// ListConditionsWithResponse request returning *ListConditionsResponse
func (c *ClientWithResponses) ListConditionsWithResponse(ctx context.Context, params *ListConditionsParams, reqEditors ...RequestEditorFn) (*ListConditionsResponse, error) {
	rsp, err := c.ListConditions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConditionsResponse(rsp)
}

// ListDividendsWithResponse request returning *ListDividendsResponse
func (c *ClientWithResponses) ListDividendsWithResponse(ctx context.Context, params *ListDividendsParams, reqEditors ...RequestEditorFn) (*ListDividendsResponse, error) {
	rsp, err := c.ListDividends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDividendsResponse(rsp)
}

// ListExchangesWithResponse request returning *ListExchangesResponse
func (c *ClientWithResponses) ListExchangesWithResponse(ctx context.Context, params *ListExchangesParams, reqEditors ...RequestEditorFn) (*ListExchangesResponse, error) {
	rsp, err := c.ListExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExchangesResponse(rsp)
}

// ListOptionsContractsWithResponse request returning *ListOptionsContractsResponse
func (c *ClientWithResponses) ListOptionsContractsWithResponse(ctx context.Context, params *ListOptionsContractsParams, reqEditors ...RequestEditorFn) (*ListOptionsContractsResponse, error) {
	rsp, err := c.ListOptionsContracts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOptionsContractsResponse(rsp)
}

// GetOptionsContractWithResponse request returning *GetOptionsContractResponse
func (c *ClientWithResponses) GetOptionsContractWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsContractParams, reqEditors ...RequestEditorFn) (*GetOptionsContractResponse, error) {
	rsp, err := c.GetOptionsContract(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsContractResponse(rsp)
}

// ListStockSplitsWithResponse request returning *ListStockSplitsResponse
func (c *ClientWithResponses) ListStockSplitsWithResponse(ctx context.Context, params *ListStockSplitsParams, reqEditors ...RequestEditorFn) (*ListStockSplitsResponse, error) {
	rsp, err := c.ListStockSplits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStockSplitsResponse(rsp)
}

// ListTickersWithResponse request returning *ListTickersResponse
func (c *ClientWithResponses) ListTickersWithResponse(ctx context.Context, params *ListTickersParams, reqEditors ...RequestEditorFn) (*ListTickersResponse, error) {
	rsp, err := c.ListTickers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTickersResponse(rsp)
}

// ListTickerTypesWithResponse request returning *ListTickerTypesResponse
func (c *ClientWithResponses) ListTickerTypesWithResponse(ctx context.Context, params *ListTickerTypesParams, reqEditors ...RequestEditorFn) (*ListTickerTypesResponse, error) {
	rsp, err := c.ListTickerTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTickerTypesResponse(rsp)
}

// GetTickerWithResponse request returning *GetTickerResponse
func (c *ClientWithResponses) GetTickerWithResponse(ctx context.Context, ticker string, params *GetTickerParams, reqEditors ...RequestEditorFn) (*GetTickerResponse, error) {
	rsp, err := c.GetTicker(ctx, ticker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTickerResponse(rsp)
}

// GetSnapshotsWithResponse request returning *GetSnapshotsResponse
func (c *ClientWithResponses) GetSnapshotsWithResponse(ctx context.Context, params *GetSnapshotsParams, reqEditors ...RequestEditorFn) (*GetSnapshotsResponse, error) {
	rsp, err := c.GetSnapshots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSnapshotsResponse(rsp)
}

// GetIndicesSnapshotWithResponse request returning *GetIndicesSnapshotResponse
func (c *ClientWithResponses) GetIndicesSnapshotWithResponse(ctx context.Context, params *GetIndicesSnapshotParams, reqEditors ...RequestEditorFn) (*GetIndicesSnapshotResponse, error) {
	rsp, err := c.GetIndicesSnapshot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndicesSnapshotResponse(rsp)
}

// GetOptionsChainWithResponse request returning *GetOptionsChainResponse
func (c *ClientWithResponses) GetOptionsChainWithResponse(ctx context.Context, underlyingAsset string, params *GetOptionsChainParams, reqEditors ...RequestEditorFn) (*GetOptionsChainResponse, error) {
	rsp, err := c.GetOptionsChain(ctx, underlyingAsset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsChainResponse(rsp)
}

// GetOptionContractWithResponse request returning *GetOptionContractResponse
func (c *ClientWithResponses) GetOptionContractWithResponse(ctx context.Context, underlyingAsset string, optionContract string, reqEditors ...RequestEditorFn) (*GetOptionContractResponse, error) {
	rsp, err := c.GetOptionContract(ctx, underlyingAsset, optionContract, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionContractResponse(rsp)
}

// GetCryptoTradesWithResponse request returning *GetCryptoTradesResponse
func (c *ClientWithResponses) GetCryptoTradesWithResponse(ctx context.Context, cryptoTicker string, params *GetCryptoTradesParams, reqEditors ...RequestEditorFn) (*GetCryptoTradesResponse, error) {
	rsp, err := c.GetCryptoTrades(ctx, cryptoTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoTradesResponse(rsp)
}

// GetOptionsTradesWithResponse request returning *GetOptionsTradesResponse
func (c *ClientWithResponses) GetOptionsTradesWithResponse(ctx context.Context, optionsTicker string, params *GetOptionsTradesParams, reqEditors ...RequestEditorFn) (*GetOptionsTradesResponse, error) {
	rsp, err := c.GetOptionsTrades(ctx, optionsTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptionsTradesResponse(rsp)
}

// GetStocksTradesWithResponse request returning *GetStocksTradesResponse
func (c *ClientWithResponses) GetStocksTradesWithResponse(ctx context.Context, stockTicker string, params *GetStocksTradesParams, reqEditors ...RequestEditorFn) (*GetStocksTradesResponse, error) {
	rsp, err := c.GetStocksTrades(ctx, stockTicker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStocksTradesResponse(rsp)
}

// ListFinancialsWithResponse request returning *ListFinancialsResponse
func (c *ClientWithResponses) ListFinancialsWithResponse(ctx context.Context, params *ListFinancialsParams, reqEditors ...RequestEditorFn) (*ListFinancialsResponse, error) {
	rsp, err := c.ListFinancials(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFinancialsResponse(rsp)
}

// ListIPOsWithResponse request returning *ListIPOsResponse
func (c *ClientWithResponses) ListIPOsWithResponse(ctx context.Context, params *ListIPOsParams, reqEditors ...RequestEditorFn) (*ListIPOsResponse, error) {
	rsp, err := c.ListIPOs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIPOsResponse(rsp)
}

// GetEventsWithResponse request returning *GetEventsResponse
func (c *ClientWithResponses) GetEventsWithResponse(ctx context.Context, id string, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error) {
	rsp, err := c.GetEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsResponse(rsp)
}

// ParseGetBenzingaV1AnalystInsightsResponse parses an HTTP response from a GetBenzingaV1AnalystInsightsWithResponse call
func ParseGetBenzingaV1AnalystInsightsResponse(rsp *http.Response) (*GetBenzingaV1AnalystInsightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1AnalystInsightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BenzingaFirmId The identifer used by Benzinga for the firm record.
				BenzingaFirmId *string `json:"benzinga_firm_id,omitempty"`

				// BenzingaId The identifer used by Benzinga for this record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// BenzingaRatingId The identifier used by Benzinga for the rating record.
				BenzingaRatingId *string `json:"benzinga_rating_id,omitempty"`

				// CompanyName The name of the company being rated.
				CompanyName *string `json:"company_name,omitempty"`

				// Date The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
				Date *string `json:"date,omitempty"`

				// Firm The name of the research firm or investment bank issuing the rating.
				Firm *string `json:"firm,omitempty"`

				// Insight Narrative commentary or reasoning provided by the analyst or firm to explain the rating or price target.
				Insight *string `json:"insight,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
				LastUpdated *time.Time `json:"last_updated,omitempty"`

				// PriceTarget The current price target set by the analyst.
				PriceTarget *float64 `json:"price_target,omitempty"`

				// Rating The current rating set by the analyst.
				Rating *string `json:"rating,omitempty"`

				// RatingAction The description of the change in rating from the firm's last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
				RatingAction *string `json:"rating_action,omitempty"`

				// Ticker The stock symbol of the company being rated.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1AnalystInsights200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1AnalystInsights400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1AnalystsResponse parses an HTTP response from a GetBenzingaV1AnalystsWithResponse call
func ParseGetBenzingaV1AnalystsResponse(rsp *http.Response) (*GetBenzingaV1AnalystsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1AnalystsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BenzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank.
				BenzingaFirmId *string `json:"benzinga_firm_id,omitempty"`

				// BenzingaId The identifier used by Benzinga for this record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// FirmName The name of the research firm or investment bank issuing the ratings.
				FirmName *string `json:"firm_name,omitempty"`

				// FullName The full name of the analyst associated with the ratings.
				FullName *string `json:"full_name,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the analyst record was last updated in the system.
				LastUpdated *string `json:"last_updated,omitempty"`

				// OverallAvgReturn The average percent price difference per rating since the date of recommendation.
				OverallAvgReturn *float64 `json:"overall_avg_return,omitempty"`

				// OverallAvgReturnPercentile The analyst's percentile rank based on average return, relative to other analysts.
				OverallAvgReturnPercentile *float64 `json:"overall_avg_return_percentile,omitempty"`

				// OverallSuccessRate The percentage of gain/loss ratings that resulted in a gain overall.
				OverallSuccessRate *float64 `json:"overall_success_rate,omitempty"`

				// SmartScore A weighted average of the total_ratings_percentile, overall_avg_return_percentile, and overall_success_rate.
				SmartScore *float64 `json:"smart_score,omitempty"`

				// TotalRatings The total number of ratings issued by the analyst included in the performance calculation.
				TotalRatings *float64 `json:"total_ratings,omitempty"`

				// TotalRatingsPercentile The analyst's percentile rank based on the total number of ratings issued, relative to other analysts.
				TotalRatingsPercentile *float64 `json:"total_ratings_percentile,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1Analysts200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1Analysts400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1BullsBearsSayResponse parses an HTTP response from a GetBenzingaV1BullsBearsSayWithResponse call
func ParseGetBenzingaV1BullsBearsSayResponse(rsp *http.Response) (*GetBenzingaV1BullsBearsSayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1BullsBearsSayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BearCase A concise summary of the bearish investment thesis, highlighting potential risks, challenges, and reasons why the stock could decline in value.
				BearCase *string `json:"bear_case,omitempty"`

				// BenzingaId The unique identifier used by Benzinga for this bull/bear case record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// BullCase A concise summary of the bullish investment thesis, highlighting positive aspects, growth opportunities, and reasons why the stock could appreciate in value.
				BullCase *string `json:"bull_case,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the bull/bear case was last updated in the system.
				LastUpdated *time.Time `json:"last_updated,omitempty"`

				// Ticker The stock ticker symbol for the company associated with the bull and bear case summaries.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1BullsBearsSay200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1BullsBearsSay400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1ConsensusRatingsResponse parses an HTTP response from a GetBenzingaV1ConsensusRatingsWithResponse call
func ParseGetBenzingaV1ConsensusRatingsResponse(rsp *http.Response) (*GetBenzingaV1ConsensusRatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1ConsensusRatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BuyRatings The count of 'Buy' ratings from contributing analysts.
				BuyRatings int64 `json:"buy_ratings"`

				// ConsensusPriceTarget The average price target across all analysts, rounded to 2 decimal places.
				ConsensusPriceTarget *float64 `json:"consensus_price_target,omitempty"`

				// ConsensusRating The overall rating category determined by the average consensus weight. Possible values: 'strong_buy', 'buy', 'hold', 'sell', 'strong_sell'.
				ConsensusRating *string `json:"consensus_rating,omitempty"`

				// ConsensusRatingValue The numerical average of all consensus weights, rounded to 2 decimal places. Scale ranges from 1 (Strong Sell) to 5 (Strong Buy).
				ConsensusRatingValue *float64 `json:"consensus_rating_value,omitempty"`

				// HighPriceTarget The highest price target among all contributing analysts.
				HighPriceTarget *float64 `json:"high_price_target,omitempty"`

				// HoldRatings The count of 'Hold' ratings from contributing analysts.
				HoldRatings int64 `json:"hold_ratings"`

				// LowPriceTarget The lowest price target among all contributing analysts.
				LowPriceTarget *float64 `json:"low_price_target,omitempty"`

				// PriceTargetContributors The number of unique analysts contributing price targets.
				PriceTargetContributors int64 `json:"price_target_contributors"`

				// RatingsContributors The number of unique analysts contributing to the overall ratings consensus.
				RatingsContributors int64 `json:"ratings_contributors"`

				// SellRatings The count of 'Sell' ratings from contributing analysts.
				SellRatings int64 `json:"sell_ratings"`

				// StrongBuyRatings The count of 'Strong Buy' ratings from contributing analysts.
				StrongBuyRatings int64 `json:"strong_buy_ratings"`

				// StrongSellRatings The count of 'Strong Sell' ratings from contributing analysts.
				StrongSellRatings int64 `json:"strong_sell_ratings"`

				// Ticker The requested ticker.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1ConsensusRatings200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1ConsensusRatings400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1EarningsResponse parses an HTTP response from a GetBenzingaV1EarningsWithResponse call
func ParseGetBenzingaV1EarningsResponse(rsp *http.Response) (*GetBenzingaV1EarningsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1EarningsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// ActualEps The actual earnings per share (EPS) reported by the company for the given period.
				ActualEps *float64 `json:"actual_eps,omitempty"`

				// ActualRevenue The actual revenue reported by the company for the given fiscal period.
				ActualRevenue *float64 `json:"actual_revenue,omitempty"`

				// BenzingaId The identifer used by Benzinga for this record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// CompanyName The name of the company releasing earnings.
				CompanyName *string `json:"company_name,omitempty"`

				// Currency The ISO 4217 currency code indicating the denomination in which the figures are reported.
				Currency *string `json:"currency,omitempty"`

				// Date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
				Date *string `json:"date,omitempty"`

				// DateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
				DateStatus *string `json:"date_status,omitempty"`

				// EpsMethod The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
				EpsMethod *string `json:"eps_method,omitempty"`

				// EpsSurprise The difference between the actual and estimated EPS.
				EpsSurprise *float64 `json:"eps_surprise,omitempty"`

				// EpsSurprisePercent The percentage difference between the actual and estimated EPS.
				EpsSurprisePercent *float64 `json:"eps_surprise_percent,omitempty"`

				// EstimatedEps The analyst consensus estimate for earnings per share (EPS) for the given period.
				EstimatedEps *float64 `json:"estimated_eps,omitempty"`

				// EstimatedRevenue The analyst consensus estimate for the company's revenue in the given period.
				EstimatedRevenue *float64 `json:"estimated_revenue,omitempty"`

				// FiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
				FiscalPeriod *string `json:"fiscal_period,omitempty"`

				// FiscalYear The fiscal year in which the earnings period falls.
				FiscalYear *int64 `json:"fiscal_year,omitempty"`

				// Importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
				Importance *int64 `json:"importance,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
				LastUpdated *time.Time `json:"last_updated,omitempty"`

				// Notes Additional context, commentary, or clarifying notes related to the earnings event.
				Notes *string `json:"notes,omitempty"`

				// PreviousEps The company's reported earnings per share (EPS) for the previous comparable period.
				PreviousEps *float64 `json:"previous_eps,omitempty"`

				// PreviousRevenue The company's revenue for the previous comparable fiscal period.
				PreviousRevenue *float64 `json:"previous_revenue,omitempty"`

				// RevenueMethod The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), adj (adjusted, non-GAAP figures that exclude certain items like one-time charges or divestitures), and rental (revenue specifically derived from rental operations, typically used by REITs, leasing companies, or businesses with a rental-based model).
				RevenueMethod *string `json:"revenue_method,omitempty"`

				// RevenueSurprise The difference between the actual and estimated revenue.
				RevenueSurprise *float64 `json:"revenue_surprise,omitempty"`

				// RevenueSurprisePercent The percentage difference between the actual and estimated revenue.
				RevenueSurprisePercent *float64 `json:"revenue_surprise_percent,omitempty"`

				// Ticker The stock symbol of the company reporting earnings.
				Ticker *string `json:"ticker,omitempty"`

				// Time The time (formatted as 24-hour HH:MM:SS UTC) when the earnings are scheduled or were reported.
				Time *string `json:"time,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1Earnings200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1Earnings400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1FirmsResponse parses an HTTP response from a GetBenzingaV1FirmsWithResponse call
func ParseGetBenzingaV1FirmsResponse(rsp *http.Response) (*GetBenzingaV1FirmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1FirmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BenzingaId The identifer used by Benzinga for this record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// Currency Primary currency used by the financial firm, with some entries having null values.
				Currency *string `json:"currency,omitempty"`

				// LastUpdated Timestamp indicating when the firm's information was last modified or verified in the database.
				LastUpdated *string `json:"last_updated,omitempty"`

				// Name The name of a research firm or investment bank which issues ratings.
				Name *string `json:"name,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1Firms200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1Firms400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1GuidanceResponse parses an HTTP response from a GetBenzingaV1GuidanceWithResponse call
func ParseGetBenzingaV1GuidanceResponse(rsp *http.Response) (*GetBenzingaV1GuidanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1GuidanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BenzingaId A unique identifier assigned by Benzinga to the guidance record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// CompanyName The name of the company issuing guidance.
				CompanyName *string `json:"company_name,omitempty"`

				// Currency The ISO 4217 code representing the currency in which the company issued its guidance figures.
				Currency *string `json:"currency,omitempty"`

				// Date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
				Date *string `json:"date,omitempty"`

				// EpsMethod The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
				EpsMethod *string `json:"eps_method,omitempty"`

				// EstimatedEpsGuidance The midpoint or central earnings per share (EPS) value the company expects for the given fiscal period.
				EstimatedEpsGuidance *float64 `json:"estimated_eps_guidance,omitempty"`

				// EstimatedRevenueGuidance The midpoint or central revenue figure the company expects for the given fiscal period.
				EstimatedRevenueGuidance *float64 `json:"estimated_revenue_guidance,omitempty"`

				// FiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
				FiscalPeriod *string `json:"fiscal_period,omitempty"`

				// FiscalYear The fiscal year corresponding to the period for which the guidance is issued.
				FiscalYear *int64 `json:"fiscal_year,omitempty"`

				// Importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
				Importance *int64 `json:"importance,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
				LastUpdated *string `json:"last_updated,omitempty"`

				// MaxEpsGuidance The highest EPS value the company expects for the fiscal period if a range was provided.
				MaxEpsGuidance *float64 `json:"max_eps_guidance,omitempty"`

				// MaxRevenueGuidance The highest revenue figure the company expects for the fiscal period if a range was provided.
				MaxRevenueGuidance *float64 `json:"max_revenue_guidance,omitempty"`

				// MinEpsGuidance The lowest EPS value the company expects for the fiscal period if a range was provided.
				MinEpsGuidance *float64 `json:"min_eps_guidance,omitempty"`

				// MinRevenueGuidance The lowest revenue figure the company expects for the fiscal period if a range was provided.
				MinRevenueGuidance *float64 `json:"min_revenue_guidance,omitempty"`

				// Notes Additional descriptive text or commentary provided about the guidance record.
				Notes *string `json:"notes,omitempty"`

				// Positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are 'primary' (the emphasized figure) and 'secondary' (a supporting or alternate figure)
				Positioning *string `json:"positioning,omitempty"`

				// PreviousMaxEpsGuidance The highest EPS value issued in a previous guidance record for the same fiscal period.
				PreviousMaxEpsGuidance *float64 `json:"previous_max_eps_guidance,omitempty"`

				// PreviousMaxRevenueGuidance The highest revenue value issued in a previous guidance record for the same fiscal period.
				PreviousMaxRevenueGuidance *float64 `json:"previous_max_revenue_guidance,omitempty"`

				// PreviousMinEpsGuidance The lowest EPS value issued in a previous guidance record for the same fiscal period.
				PreviousMinEpsGuidance *float64 `json:"previous_min_eps_guidance,omitempty"`

				// PreviousMinRevenueGuidance The lowest revenue value issued in a previous guidance record for the same fiscal period.
				PreviousMinRevenueGuidance *float64 `json:"previous_min_revenue_guidance,omitempty"`

				// ReleaseType Indicates whether the guidance was issued as part of a scheduled earnings release ('official') or as an unscheduled update ('preliminary').
				ReleaseType *string `json:"release_type,omitempty"`

				// RevenueMethod The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles) and adj (adjusted, non-GAAP).
				RevenueMethod *string `json:"revenue_method,omitempty"`

				// Ticker The stock symbol of the company issuing guidance.
				Ticker *string `json:"ticker,omitempty"`

				// Time The time of day the guidance was announced, in HH:mm:ss format.
				Time *string `json:"time,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1Guidance200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1Guidance400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV1RatingsResponse parses an HTTP response from a GetBenzingaV1RatingsWithResponse call
func ParseGetBenzingaV1RatingsResponse(rsp *http.Response) (*GetBenzingaV1RatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV1RatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AdjustedPriceTarget The current price target adjusted for stock splits and dividends.
				AdjustedPriceTarget *float64 `json:"adjusted_price_target,omitempty"`

				// Analyst The name of the individual analyst who issued the rating.
				Analyst *string `json:"analyst,omitempty"`

				// BenzingaAnalystId The identifer used by Benzinga for this analyst.
				BenzingaAnalystId *string `json:"benzinga_analyst_id,omitempty"`

				// BenzingaCalendarUrl A link to the Benzinga calendar page for this ticker
				BenzingaCalendarUrl *string `json:"benzinga_calendar_url,omitempty"`

				// BenzingaFirmId The identifer used by Benzinga for this firm.
				BenzingaFirmId *string `json:"benzinga_firm_id,omitempty"`

				// BenzingaId The identifer used by Benzinga for this record.
				BenzingaId *string `json:"benzinga_id,omitempty"`

				// BenzingaNewsUrl A link to the Benzinga articles page for this ticker
				BenzingaNewsUrl *string `json:"benzinga_news_url,omitempty"`

				// CompanyName The name of the company being rated.
				CompanyName *string `json:"company_name,omitempty"`

				// Currency The ISO 4217 currency code in which the price target is denominated.
				Currency *string `json:"currency,omitempty"`

				// Date The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
				Date *string `json:"date,omitempty"`

				// Firm The name of the research firm or investment bank issuing the rating.
				Firm *string `json:"firm,omitempty"`

				// Importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest).
				Importance *int64 `json:"importance,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
				LastUpdated *time.Time `json:"last_updated,omitempty"`

				// Notes Additional context or commentary.
				Notes *string `json:"notes,omitempty"`

				// PreviousAdjustedPriceTarget The previous price target adjusted for stock splits and dividends.
				PreviousAdjustedPriceTarget *float64 `json:"previous_adjusted_price_target,omitempty"`

				// PreviousPriceTarget The previous price target set by the analyst.
				PreviousPriceTarget *float64 `json:"previous_price_target,omitempty"`

				// PreviousRating The previous rating set by the analyst.
				PreviousRating *string `json:"previous_rating,omitempty"`

				// PricePercentChange The percentage change in price target if price target and previous price target exists
				PricePercentChange *float64 `json:"price_percent_change,omitempty"`

				// PriceTarget The current price target set by the analyst.
				PriceTarget *float64 `json:"price_target,omitempty"`

				// PriceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
				PriceTargetAction *string `json:"price_target_action,omitempty"`

				// Rating The current rating set by the analyst.
				Rating *string `json:"rating,omitempty"`

				// RatingAction The description of the change in rating from the firm's last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
				RatingAction *string `json:"rating_action,omitempty"`

				// Ticker The stock symbol of the company being rated.
				Ticker *string `json:"ticker,omitempty"`

				// Time The time (formatted as 24-hour HH:MM:SS UTC) when the rating was issued.
				Time *string `json:"time,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV1Ratings200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV1Ratings400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBenzingaV2NewsResponse parses an HTTP response from a GetBenzingaV2NewsWithResponse call
func ParseGetBenzingaV2NewsResponse(rsp *http.Response) (*GetBenzingaV2NewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenzingaV2NewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Author The name of the journalist or entity that authored the news article.
				Author string `json:"author"`

				// BenzingaId The identifer used by Benzinga for this record.
				BenzingaId int64 `json:"benzinga_id"`

				// Body The full text content of the news article.
				Body *string `json:"body,omitempty"`

				// Channels A list of categories or topics that the article belongs to (e.g., 'News', 'Price Target').
				Channels *[]string `json:"channels,omitempty"`

				// Images A list of images associated with the article.
				Images *[]string `json:"images,omitempty"`

				// LastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
				LastUpdated time.Time `json:"last_updated"`

				// Published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
				Published time.Time `json:"published"`

				// Tags A list of tags that describe the themes or content of the article.
				Tags *[]string `json:"tags,omitempty"`

				// Teaser A short summary or lead-in to the news article's content.
				Teaser *string `json:"teaser,omitempty"`

				// Tickers A list of stock or crypto tickers mentioned in the article.
				Tickers *[]string `json:"tickers,omitempty"`

				// Title The headline of the news article.
				Title string `json:"title"`

				// Url The direct link to the source of the news article.
				Url string `json:"url"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetBenzingaV2News200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetBenzingaV2News400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetCryptoV1ExchangesResponse parses an HTTP response from a GetCryptoV1ExchangesWithResponse call
func ParseGetCryptoV1ExchangesResponse(rsp *http.Response) (*GetCryptoV1ExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoV1ExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Id Numeric identifier for the cryptocurrency exchange or trading platform.
				Id string `json:"id"`

				// Name Full official name of the cryptocurrency exchange or digital asset trading platform.
				Name string `json:"name"`

				// Type Type of crypto venue - 'exchange' for cryptocurrency exchanges and digital asset trading platforms.
				Type string `json:"type"`

				// Url Official website URL of the cryptocurrency exchange.
				Url *string `json:"url,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetCryptoV1Exchanges200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetCryptoV1Exchanges400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEtfGlobalV1AnalyticsResponse parses an HTTP response from a GetEtfGlobalV1AnalyticsWithResponse call
func ParseGetEtfGlobalV1AnalyticsResponse(rsp *http.Response) (*GetEtfGlobalV1AnalyticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEtfGlobalV1AnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
				CompositeTicker *string `json:"composite_ticker,omitempty"`

				// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
				EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

				// ProcessedDate The date showing when ETF Global received and processed the data.
				ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

				// QuantCompositeBehavioral Behavioral analysis score measuring investor psychology and market behavior patterns.
				QuantCompositeBehavioral *float64 `json:"quant_composite_behavioral,omitempty"`

				// QuantCompositeFundamental Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics.
				QuantCompositeFundamental *float64 `json:"quant_composite_fundamental,omitempty"`

				// QuantCompositeGlobal Overall global theme score combining sector and country analysis for macro investment views.
				QuantCompositeGlobal *float64 `json:"quant_composite_global,omitempty"`

				// QuantCompositeQuality Overall quality assessment score combining liquidity, diversification, and issuing firm factors.
				QuantCompositeQuality *float64 `json:"quant_composite_quality,omitempty"`

				// QuantCompositeSentiment Overall market sentiment score combining put/call ratios, short interest, and implied volatility.
				QuantCompositeSentiment *float64 `json:"quant_composite_sentiment,omitempty"`

				// QuantCompositeTechnical Combined technical analysis score aggregating short, intermediate, and long-term technical factors.
				QuantCompositeTechnical *float64 `json:"quant_composite_technical,omitempty"`

				// QuantFundamentalDiv Fundamental analysis score based on dividend yields of the ETF's underlying securities.
				QuantFundamentalDiv *float64 `json:"quant_fundamental_div,omitempty"`

				// QuantFundamentalPb Fundamental analysis score based on price-to-book value ratios of the ETF's holdings.
				QuantFundamentalPb *float64 `json:"quant_fundamental_pb,omitempty"`

				// QuantFundamentalPcf Fundamental analysis score based on price-to-cash-flow ratios of the ETF's underlying assets.
				QuantFundamentalPcf *float64 `json:"quant_fundamental_pcf,omitempty"`

				// QuantFundamentalPe Fundamental analysis score based on price-to-earnings ratios of the ETF's underlying holdings.
				QuantFundamentalPe *float64 `json:"quant_fundamental_pe,omitempty"`

				// QuantGlobalCountry Quantitative score analyzing global country themes and country-specific market factors.
				QuantGlobalCountry *float64 `json:"quant_global_country,omitempty"`

				// QuantGlobalSector Quantitative score analyzing global sector themes and sector-specific performance factors.
				QuantGlobalSector *float64 `json:"quant_global_sector,omitempty"`

				// QuantGrade Letter grade summarizing the ETF's overall quantitative assessment, where A = 71-100, B = 56-70, etc.
				QuantGrade *string `json:"quant_grade,omitempty"`

				// QuantQualityDiversification Quality assessment score evaluating the diversification benefits and risk distribution of the ETF.
				QuantQualityDiversification *float64 `json:"quant_quality_diversification,omitempty"`

				// QuantQualityFirm Quality assessment score evaluating the reputation and capabilities of the ETF's issuing firm.
				QuantQualityFirm *float64 `json:"quant_quality_firm,omitempty"`

				// QuantQualityLiquidity Quality assessment score measuring the liquidity characteristics and trading ease of the ETF.
				QuantQualityLiquidity *float64 `json:"quant_quality_liquidity,omitempty"`

				// QuantSentimentIv Market sentiment score derived from implied volatility levels in options markets.
				QuantSentimentIv *float64 `json:"quant_sentiment_iv,omitempty"`

				// QuantSentimentPc Market sentiment score derived from put/call option ratios and options activity.
				QuantSentimentPc *float64 `json:"quant_sentiment_pc,omitempty"`

				// QuantSentimentSi Market sentiment score based on short interest levels and short selling activity.
				QuantSentimentSi *float64 `json:"quant_sentiment_si,omitempty"`

				// QuantTechnicalIt Intermediate-term technical analysis score evaluating medium-term price trends.
				QuantTechnicalIt *float64 `json:"quant_technical_it,omitempty"`

				// QuantTechnicalLt Long-term technical analysis score assessing extended price trend patterns.
				QuantTechnicalLt *float64 `json:"quant_technical_lt,omitempty"`

				// QuantTechnicalSt Short-term technical analysis score based on recent price movements and trading patterns.
				QuantTechnicalSt *float64 `json:"quant_technical_st,omitempty"`

				// QuantTotalScore ETF Global's comprehensive quantitative analysis score combining all quantitative factors.
				QuantTotalScore *float64 `json:"quant_total_score,omitempty"`

				// RewardScore ETF Global's proprietary Green Diamond score measuring the potential reward and return prospects of the ETF.
				RewardScore *float64 `json:"reward_score,omitempty"`

				// RiskCountry A component score assessing country-specific risks based on the ETF's geographic exposure.
				RiskCountry *float64 `json:"risk_country,omitempty"`

				// RiskDeviation A component score measuring how much the ETF deviates from expected performance.
				RiskDeviation *float64 `json:"risk_deviation,omitempty"`

				// RiskEfficiency A component score assessing the operational efficiency and cost-effectiveness of the ETF.
				RiskEfficiency *float64 `json:"risk_efficiency,omitempty"`

				// RiskLiquidity A component score measuring the liquidity risk and ease of trading the ETF.
				RiskLiquidity *float64 `json:"risk_liquidity,omitempty"`

				// RiskStructure A component score evaluating risks related to the ETF's structural design and mechanics.
				RiskStructure *float64 `json:"risk_structure,omitempty"`

				// RiskTotalScore ETF Global's proprietary Red Diamond overall risk assessment score for the ETF.
				RiskTotalScore *float64 `json:"risk_total_score,omitempty"`

				// RiskVolatility A component score measuring the volatility risk of the ETF's price movements.
				RiskVolatility *float64 `json:"risk_volatility,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Analytics200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Analytics400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEtfGlobalV1ConstituentsResponse parses an HTTP response from a GetEtfGlobalV1ConstituentsWithResponse call
func ParseGetEtfGlobalV1ConstituentsResponse(rsp *http.Response) (*GetEtfGlobalV1ConstituentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEtfGlobalV1ConstituentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AssetClass The broad category of asset type, such as Equity, Corporate Bond, Municipal Bond, etc.
				AssetClass *string `json:"asset_class,omitempty"`

				// CompositeTicker The stock ticker symbol of the ETF that holds these constituent securities.
				CompositeTicker *string `json:"composite_ticker,omitempty"`

				// ConstituentName The full company or security name of the constituent holding.
				ConstituentName *string `json:"constituent_name,omitempty"`

				// ConstituentRank The rank of this constituent within the ETF for a given effective_date, ordered by weight (descending), market_value (descending), and constituent_ticker (ascending). A rank of 1 indicates the largest holding.
				ConstituentRank int64 `json:"constituent_rank"`

				// ConstituentTicker The stock ticker symbol of the individual security held within the ETF.
				ConstituentTicker *string `json:"constituent_ticker,omitempty"`

				// CountryOfExchange The country where the exchange that lists this constituent security is located.
				CountryOfExchange *string `json:"country_of_exchange,omitempty"`

				// CurrencyTraded The local currency in which this constituent security is denominated and traded.
				CurrencyTraded *string `json:"currency_traded,omitempty"`

				// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
				EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

				// Exchange The name of the stock exchange where this constituent security is primarily traded.
				Exchange *string `json:"exchange,omitempty"`

				// Figi The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
				Figi *string `json:"figi,omitempty"`

				// Isin The International Securities Identification Number, a global standard for identifying securities.
				Isin *string `json:"isin,omitempty"`

				// MarketValue The total market value of this constituent position held by the ETF.
				MarketValue *float64 `json:"market_value,omitempty"`

				// ProcessedDate The date showing when ETF Global received and processed the data.
				ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

				// SecurityType The specific classification of security type using ETF Global's taxonomy, such as Common Equity, Domestic, Global, etc.
				SecurityType *string `json:"security_type,omitempty"`

				// Sedol The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
				Sedol *string `json:"sedol,omitempty"`

				// SharesHeld The number of shares of this constituent security that the ETF currently owns.
				SharesHeld *float64 `json:"shares_held,omitempty"`

				// UsCode A unique identifier code for the constituent security in US markets.
				UsCode *string `json:"us_code,omitempty"`

				// Weight The percentage weight of this constituent security within the ETF's total portfolio.
				Weight *float64 `json:"weight,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Constituents200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Constituents400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEtfGlobalV1FundFlowsResponse parses an HTTP response from a GetEtfGlobalV1FundFlowsWithResponse call
func ParseGetEtfGlobalV1FundFlowsResponse(rsp *http.Response) (*GetEtfGlobalV1FundFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEtfGlobalV1FundFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// CompositeTicker The stock ticker symbol used to identify this ETF on exchanges.
				CompositeTicker *string `json:"composite_ticker,omitempty"`

				// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
				EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

				// FundFlow The net daily capital flow into or out of the ETF through the creation and redemption process, where positive values indicate inflows and negative values indicate outflows.
				FundFlow *float64 `json:"fund_flow,omitempty"`

				// Nav The net asset value per share, representing the per-share value of the ETF's underlying holdings.
				Nav *float64 `json:"nav,omitempty"`

				// ProcessedDate The date showing when ETF Global received and processed the data.
				ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

				// SharesOutstanding The total number of ETF shares currently issued and outstanding in the market.
				SharesOutstanding *float64 `json:"shares_outstanding,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1FundFlows200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1FundFlows400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEtfGlobalV1ProfilesResponse parses an HTTP response from a GetEtfGlobalV1ProfilesWithResponse call
func ParseGetEtfGlobalV1ProfilesResponse(rsp *http.Response) (*GetEtfGlobalV1ProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEtfGlobalV1ProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Administrator The administrator of the ETF.
				Administrator *string `json:"administrator,omitempty"`

				// Advisor The investment advisor of the ETF.
				Advisor *string `json:"advisor,omitempty"`

				// AssetClass The primary type of assets held by the ETF, such as equities, bonds, commodities, or other securities.
				AssetClass *string `json:"asset_class,omitempty"`

				// Aum The total assets under management, representing the current market value of all assets held by the ETF.
				Aum *float64 `json:"aum,omitempty"`

				// AvgDailyTradingVolume The average number of shares traded daily over the past month, indicating liquidity and investor interest.
				AvgDailyTradingVolume *float64 `json:"avg_daily_trading_volume,omitempty"`

				// BidAskSpread The average intraday bid-ask spread as a percentage, calculated by dividing the spread by the lowest ask price sampled during the day.
				BidAskSpread *float64 `json:"bid_ask_spread,omitempty"`

				// CallVolume Call options volume.
				CallVolume *float64 `json:"call_volume,omitempty"`

				// Category The broad investment category that describes the ETF's investment focus and strategy.
				Category *string `json:"category,omitempty"`

				// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
				CompositeTicker *string `json:"composite_ticker,omitempty"`

				// CouponExposure Coupon exposure breakdown for fixed income ETFs.
				CouponExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"coupon_exposure,omitempty"`

				// CreationFee The fee for creating new shares of the ETF.
				CreationFee *float64 `json:"creation_fee,omitempty"`

				// CreationUnitSize The size of creation units for the ETF.
				CreationUnitSize *float64 `json:"creation_unit_size,omitempty"`

				// CurrencyExposure Currency exposure breakdown of the ETF.
				CurrencyExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"currency_exposure,omitempty"`

				// Custodian The custodian of the ETF assets.
				Custodian *string `json:"custodian,omitempty"`

				// Description The official name and description of the ETF product.
				Description *string `json:"description,omitempty"`

				// DevelopmentClass The economic development classification of the markets the ETF invests in, such as developed, emerging, or frontier markets.
				DevelopmentClass *string `json:"development_class,omitempty"`

				// DiscountPremium Discount or premium to net asset value.
				DiscountPremium *float64 `json:"discount_premium,omitempty"`

				// DistributionFrequency How frequently the ETF makes distributions.
				DistributionFrequency *string `json:"distribution_frequency,omitempty"`

				// Distributor The distributor of the ETF.
				Distributor *string `json:"distributor,omitempty"`

				// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
				EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

				// FeeWaivers Any fee waivers applied to the ETF.
				FeeWaivers *float64 `json:"fee_waivers,omitempty"`

				// FiscalYearEnd The fiscal year end date for the ETF.
				FiscalYearEnd *string `json:"fiscal_year_end,omitempty"`

				// Focus The specific investment focus or exposure that the ETF provides, such as sector, geography, or investment style.
				Focus *string `json:"focus,omitempty"`

				// FuturesCommissionMerchant The futures commission merchant, if applicable.
				FuturesCommissionMerchant *string `json:"futures_commission_merchant,omitempty"`

				// GeographicExposure Geographic exposure breakdown of the ETF.
				GeographicExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"geographic_exposure,omitempty"`

				// InceptionDate The date when this ETF was first launched and became available for trading.
				InceptionDate *openapi_types.Date `json:"inception_date,omitempty"`

				// IndustryExposure Industry exposure breakdown of the ETF.
				IndustryExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"industry_exposure,omitempty"`

				// IndustryGroupExposure Industry group exposure breakdown of the ETF.
				IndustryGroupExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"industry_group_exposure,omitempty"`

				// Issuer The financial institution or fund company that created and sponsors this ETF.
				Issuer *string `json:"issuer,omitempty"`

				// LeadMarketMaker The lead market maker for the ETF.
				LeadMarketMaker *string `json:"lead_market_maker,omitempty"`

				// LeverageStyle Indicates whether the ETF uses leverage to amplify returns ('leveraged'), or does not use leverage ('unleveraged').
				LeverageStyle string `json:"leverage_style"`

				// LeveredAmount The leverage multiplier applied by the ETF, where positive numbers indicate leveraged exposure and negative numbers indicate inverse exposure.
				LeveredAmount *float64 `json:"levered_amount,omitempty"`

				// ListingExchange The primary exchange where the ETF is listed.
				ListingExchange *string `json:"listing_exchange,omitempty"`

				// ManagementClassification Defines whether an ETF is considered active under SEC rules, with managers making investment decisions, or passive, tracking an index.
				ManagementClassification string `json:"management_classification"`

				// ManagementFee The annual fee charged by the fund manager for managing the ETF's portfolio and operations.
				ManagementFee *float64 `json:"management_fee,omitempty"`

				// MaturityExposure Maturity exposure breakdown for fixed income ETFs.
				MaturityExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"maturity_exposure,omitempty"`

				// NetExpenses Net expenses after waivers.
				NetExpenses *float64 `json:"net_expenses,omitempty"`

				// NumHoldings Number of holdings in the ETF.
				NumHoldings *float64 `json:"num_holdings,omitempty"`

				// OptionsAvailable Availability of options on the ETF.
				OptionsAvailable *int32 `json:"options_available,omitempty"`

				// OptionsVolume Options trading volume for the ETF.
				OptionsVolume *float64 `json:"options_volume,omitempty"`

				// OtherExpenses Other expenses charged by the ETF.
				OtherExpenses *float64 `json:"other_expenses,omitempty"`

				// PortfolioManager The portfolio manager of the ETF.
				PortfolioManager *string `json:"portfolio_manager,omitempty"`

				// PrimaryBenchmark The main index or benchmark that this ETF is designed to track or replicate.
				PrimaryBenchmark *string `json:"primary_benchmark,omitempty"`

				// ProcessedDate The date showing when ETF Global received and processed the data.
				ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

				// ProductType Indicates whether the product is an Exchange-Traded Note ('etn') or an Exchange-Traded Fund ('etf').
				ProductType string `json:"product_type"`

				// PutCallRatio Put/call ratio for options on the ETF.
				PutCallRatio *float64 `json:"put_call_ratio,omitempty"`

				// PutVolume Put options volume.
				PutVolume *float64 `json:"put_volume,omitempty"`

				// Region The geographic region or area of the world where the ETF concentrates its investments.
				Region *string `json:"region,omitempty"`

				// SectorExposure Sector exposure breakdown of the ETF.
				SectorExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"sector_exposure,omitempty"`

				// ShortInterest Short interest in the ETF.
				ShortInterest *float64 `json:"short_interest,omitempty"`

				// Subadvisor The subadvisor of the ETF, if applicable.
				Subadvisor *string `json:"subadvisor,omitempty"`

				// SubindustryExposure Sub-industry exposure breakdown of the ETF.
				SubindustryExposure *[]struct {
					Key   string  `json:"key"`
					Value float64 `json:"value"`
				} `json:"subindustry_exposure,omitempty"`

				// TaxClassification The tax structure of the ETF, determining whether investors receive 1099 or K1 tax forms (RIC, Partnership, or UIT).
				TaxClassification *string `json:"tax_classification,omitempty"`

				// TotalExpenses The total annual expense ratio of the ETF, including all fees and costs passed on to investors.
				TotalExpenses *float64 `json:"total_expenses,omitempty"`

				// TransferAgent The transfer agent for the ETF.
				TransferAgent *string `json:"transfer_agent,omitempty"`

				// Trustee The trustee of the ETF.
				Trustee *string `json:"trustee,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Profiles200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Profiles400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEtfGlobalV1TaxonomiesResponse parses an HTTP response from a GetEtfGlobalV1TaxonomiesWithResponse call
func ParseGetEtfGlobalV1TaxonomiesResponse(rsp *http.Response) (*GetEtfGlobalV1TaxonomiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEtfGlobalV1TaxonomiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AssetClass The primary type of assets held by the ETF, such as equities, bonds, commodities, or other securities.
				AssetClass *string `json:"asset_class,omitempty"`

				// Category The broad investment category that describes the ETF's investment focus and strategy.
				Category *string `json:"category,omitempty"`

				// CompositeTicker The stock ticker symbol used to identify this ETF product on exchanges.
				CompositeTicker *string `json:"composite_ticker,omitempty"`

				// Country The specific country focus of the ETF, if applicable.
				Country *string `json:"country,omitempty"`

				// CreditQualityRating Credit quality rating for fixed income ETFs.
				CreditQualityRating *string `json:"credit_quality_rating,omitempty"`

				// Description The official name and description of the ETF product.
				Description *string `json:"description,omitempty"`

				// DevelopmentClass The economic development classification of the markets the ETF invests in, such as developed, emerging, or frontier markets.
				DevelopmentClass *string `json:"development_class,omitempty"`

				// Duration The duration characteristics for fixed income ETFs.
				Duration *string `json:"duration,omitempty"`

				// EffectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
				EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

				// Esg Environmental, Social, and Governance characteristics.
				Esg *string `json:"esg,omitempty"`

				// ExposureMechanism The mechanism used to achieve exposure.
				ExposureMechanism *string `json:"exposure_mechanism,omitempty"`

				// Factor Factor exposure characteristics of the ETF.
				Factor *string `json:"factor,omitempty"`

				// Focus The specific investment focus or exposure that the ETF provides, such as sector, geography, or investment style.
				Focus *string `json:"focus,omitempty"`

				// HedgeReset The frequency of hedge reset, if applicable.
				HedgeReset *string `json:"hedge_reset,omitempty"`

				// HoldingsDisclosureFrequency How frequently holdings are disclosed.
				HoldingsDisclosureFrequency *string `json:"holdings_disclosure_frequency,omitempty"`

				// InceptionDate The date when this ETF was first launched and became available for trading.
				InceptionDate *openapi_types.Date `json:"inception_date,omitempty"`

				// Isin The International Securities Identification Number, a global standard code for uniquely identifying this ETF worldwide.
				Isin *string `json:"isin,omitempty"`

				// Issuer The financial institution or fund company that created and sponsors this ETF.
				Issuer *string `json:"issuer,omitempty"`

				// LeverageReset The frequency of leverage reset, if applicable.
				LeverageReset *string `json:"leverage_reset,omitempty"`

				// LeverageStyle Indicates whether the ETF uses leverage to amplify returns ('leveraged'), or does not use leverage ('unleveraged').
				LeverageStyle string `json:"leverage_style"`

				// LeveredAmount The leverage multiplier applied by the ETF, where positive numbers indicate leveraged exposure and negative numbers indicate inverse exposure.
				LeveredAmount *float64 `json:"levered_amount,omitempty"`

				// ManagementClassification Defines whether an ETF is considered active under SEC rules, with managers making investment decisions, or passive, tracking an index.
				ManagementClassification string `json:"management_classification"`

				// ManagementStyle Indicates whether an ETF is managed actively or passively, and the level of transparency or replication method used.
				ManagementStyle *string `json:"management_style,omitempty"`

				// Maturity The maturity profile for fixed income ETFs.
				Maturity *string `json:"maturity,omitempty"`

				// Objective The primary investment objective of the ETF.
				Objective *string `json:"objective,omitempty"`

				// PrimaryBenchmark The main index or benchmark that this ETF is designed to track or replicate.
				PrimaryBenchmark *string `json:"primary_benchmark,omitempty"`

				// ProcessedDate The date showing when ETF Global received and processed the data.
				ProcessedDate *openapi_types.Date `json:"processed_date,omitempty"`

				// ProductType Indicates whether the product is an Exchange-Traded Note ('etn') or an Exchange-Traded Fund ('etf').
				ProductType string `json:"product_type"`

				// RebalanceFrequency How frequently the ETF rebalances its holdings.
				RebalanceFrequency *string `json:"rebalance_frequency,omitempty"`

				// ReconstitutionFrequency How frequently the index is reconstituted.
				ReconstitutionFrequency *string `json:"reconstitution_frequency,omitempty"`

				// Region The geographic region or area of the world where the ETF concentrates its investments.
				Region *string `json:"region,omitempty"`

				// SecondaryObjective The secondary investment objective, if applicable.
				SecondaryObjective *string `json:"secondary_objective,omitempty"`

				// SelectionMethodology The methodology used to select securities.
				SelectionMethodology *string `json:"selection_methodology,omitempty"`

				// SelectionUniverse The universe from which securities are selected.
				SelectionUniverse *string `json:"selection_universe,omitempty"`

				// StrategicFocus The strategic investment focus of the ETF.
				StrategicFocus *string `json:"strategic_focus,omitempty"`

				// TargetedFocus The targeted investment focus of the ETF.
				TargetedFocus *string `json:"targeted_focus,omitempty"`

				// TaxClassification The tax structure of the ETF, determining whether investors receive 1099 or K1 tax forms (RIC, Partnership, or UIT).
				TaxClassification *string `json:"tax_classification,omitempty"`

				// UsCode A unique identifier code that identifies this ETF in US markets.
				UsCode *string `json:"us_code,omitempty"`

				// WeightingMethodology The methodology used to weight holdings.
				WeightingMethodology *string `json:"weighting_methodology,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Taxonomies200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetEtfGlobalV1Taxonomies400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFedV1InflationResponse parses an HTTP response from a GetFedV1InflationWithResponse call
func ParseGetFedV1InflationResponse(rsp *http.Response) (*GetFedV1InflationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFedV1InflationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Cpi Consumer Price Index (CPI) for All Urban Consumers  a standard measure of headline inflation based on a fixed basket of goods and services, not seasonally adjusted.
				Cpi *float32 `json:"cpi,omitempty"`

				// CpiCore Core Consumer Price Index  the CPI excluding food and energy, used to understand underlying inflation trends without short-term volatility.
				CpiCore *float32 `json:"cpi_core,omitempty"`

				// CpiYearOverYear Year-over-year percentage change in the headline CPI  the most commonly cited inflation rate in public discourse and economic policy.
				CpiYearOverYear *float32 `json:"cpi_year_over_year,omitempty"`

				// Date Calendar date of the observation (YYYYMMDD).
				Date *string `json:"date,omitempty"`

				// Pce Personal Consumption Expenditures (PCE) Price Index  a broader measure of inflation used by the Federal Reserve, reflecting actual consumer spending patterns and updated basket weights.
				Pce *float32 `json:"pce,omitempty"`

				// PceCore Core PCE Price Index  excludes food and energy prices from the PCE index, and is the Fed's preferred measure of underlying inflation.
				PceCore *float32 `json:"pce_core,omitempty"`

				// PceSpending Nominal Personal Consumption Expenditures  total dollar value of consumer spending in the U.AskSize. economy, reported in billions of dollars and not adjusted for inflation.
				PceSpending *float32 `json:"pce_spending,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFedV1Inflation200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFedV1Inflation400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFedV1InflationExpectationsResponse parses an HTTP response from a GetFedV1InflationExpectationsWithResponse call
func ParseGetFedV1InflationExpectationsResponse(rsp *http.Response) (*GetFedV1InflationExpectationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFedV1InflationExpectationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Date Calendar date of the observation (YYYYMMDD).
				Date *string `json:"date,omitempty"`

				// ForwardYears5To10 5-Year, 5-Year Forward Inflation Expectation Rate  the market's expectation of average annual inflation for the 5-year period beginning 5 years from now, based on the spread between forward nominal and real yields.
				ForwardYears5To10 *float32 `json:"forward_years_5_to_10,omitempty"`

				// Market10Year 10-Year Breakeven Inflation Rate  the market's expectation of average annual inflation over the next 10 years, based on the spread between 10-year nominal Treasury yields and 10-year TIPS yields.
				Market10Year *float32 `json:"market_10_year,omitempty"`

				// Market5Year 5-Year Breakeven Inflation Rate  the market's expectation of average annual inflation over the next 5 years, based on the spread between 5-year nominal Treasury yields and 5-year TIPS yields.
				Market5Year *float32 `json:"market_5_year,omitempty"`

				// Model10Year The Cleveland Feds 10-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
				Model10Year *float32 `json:"model_10_year,omitempty"`

				// Model1Year The Cleveland Feds 1-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
				Model1Year *float32 `json:"model_1_year,omitempty"`

				// Model30Year The Cleveland Feds 30-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
				Model30Year *float32 `json:"model_30_year,omitempty"`

				// Model5Year The Cleveland Feds 5-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
				Model5Year *float32 `json:"model_5_year,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFedV1InflationExpectations200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFedV1InflationExpectations400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFedV1LaborMarketResponse parses an HTTP response from a GetFedV1LaborMarketWithResponse call
func ParseGetFedV1LaborMarketResponse(rsp *http.Response) (*GetFedV1LaborMarketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFedV1LaborMarketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AvgHourlyEarnings Average hourly earnings of all employees on private nonfarm payrolls in USD (CES0500000003 series from FRED).
				AvgHourlyEarnings *float32 `json:"avg_hourly_earnings,omitempty"`

				// Date Calendar date of the observation (YYYY-MM-DD).
				Date *string `json:"date,omitempty"`

				// JobOpenings Total nonfarm job openings in thousands (JTSJOL series from FRED).
				JobOpenings *float32 `json:"job_openings,omitempty"`

				// LaborForceParticipationRate Civilian labor force participation rate as a percentage of the civilian noninstitutional population (CIVPART series from FRED).
				LaborForceParticipationRate *float32 `json:"labor_force_participation_rate,omitempty"`

				// UnemploymentRate Civilian unemployment rate as a percentage of the labor force (UNRATE series from FRED).
				UnemploymentRate *float32 `json:"unemployment_rate,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFedV1LaborMarket200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFedV1LaborMarket400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFedV1TreasuryYieldsResponse parses an HTTP response from a GetFedV1TreasuryYieldsWithResponse call
func ParseGetFedV1TreasuryYieldsResponse(rsp *http.Response) (*GetFedV1TreasuryYieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFedV1TreasuryYieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Date Calendar date of the yield observation (YYYY-MM-DD).
				Date *string `json:"date,omitempty"`

				// Yield10Year Market Yield on U.AskSize. Treasury Securities at 10-Year Constant Maturity, Quoted on an Investment Basis
				Yield10Year *float32 `json:"yield_10_year,omitempty"`

				// Yield1Month Market Yield on U.AskSize. Treasury Securities at 1-Month Constant Maturity, Quoted on an Investment Basis
				Yield1Month *float32 `json:"yield_1_month,omitempty"`

				// Yield1Year Market Yield on U.AskSize. Treasury Securities at 1-Year Constant Maturity, Quoted on an Investment Basis
				Yield1Year *float32 `json:"yield_1_year,omitempty"`

				// Yield20Year Market Yield on U.AskSize. Treasury Securities at 20-Year Constant Maturity, Quoted on an Investment Basis
				Yield20Year *float32 `json:"yield_20_year,omitempty"`

				// Yield2Year Market Yield on U.AskSize. Treasury Securities at 2-Year Constant Maturity, Quoted on an Investment Basis
				Yield2Year *float32 `json:"yield_2_year,omitempty"`

				// Yield30Year Market Yield on U.AskSize. Treasury Securities at 30-Year Constant Maturity, Quoted on an Investment Basis
				Yield30Year *float32 `json:"yield_30_year,omitempty"`

				// Yield3Month Market Yield on U.AskSize. Treasury Securities at 3-Month Constant Maturity, Quoted on an Investment Basis
				Yield3Month *float32 `json:"yield_3_month,omitempty"`

				// Yield3Year Market Yield on U.AskSize. Treasury Securities at 3-Year Constant Maturity, Quoted on an Investment Basis
				Yield3Year *float32 `json:"yield_3_year,omitempty"`

				// Yield5Year Market Yield on U.AskSize. Treasury Securities at 5-Year Constant Maturity, Quoted on an Investment Basis
				Yield5Year *float32 `json:"yield_5_year,omitempty"`

				// Yield6Month Market Yield on U.AskSize. Treasury Securities at 6-Month Constant Maturity, Quoted on an Investment Basis
				Yield6Month *float32 `json:"yield_6_month,omitempty"`

				// Yield7Year Market Yield on U.AskSize. Treasury Securities at 7-Year Constant Maturity, Quoted on an Investment Basis
				Yield7Year *float32 `json:"yield_7_year,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFedV1TreasuryYields200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFedV1TreasuryYields400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetForexV1ExchangesResponse parses an HTTP response from a GetForexV1ExchangesWithResponse call
func ParseGetForexV1ExchangesResponse(rsp *http.Response) (*GetForexV1ExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexV1ExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Id Numeric identifier for the forex trading venue or institution.
				Id string `json:"id"`

				// Name Full name of the foreign exchange trading venue, platform, or financial institution.
				Name string `json:"name"`

				// Type Type of forex venue - 'exchange' for electronic trading platforms and institutional trading venues.
				Type string `json:"type"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetForexV1Exchanges200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetForexV1Exchanges400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesAggregatesResponse parses an HTTP response from a GetFuturesAggregatesWithResponse call
func ParseGetFuturesAggregatesResponse(rsp *http.Response) (*GetFuturesAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, the URL to the next page of results.
			NextUrl *string `json:"next_url,omitempty"`
			Results []struct {
				// Close The last price within the timeframe.
				Close float64 `json:"close"`

				// DollarVolume The total dollar volume of the transactions that occurred within the timeframe.
				DollarVolume float64 `json:"dollar_volume"`

				// High The highest price within the timeframe.
				High float64 `json:"high"`

				// Low The lowest price within the timeframe.
				Low float64 `json:"low"`

				// Open The opening price within the timeframe.
				Open float64 `json:"open"`

				// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
				SessionEndDate string `json:"session_end_date"`

				// SettlementPrice The price the contract would have cost to settle for this session.
				SettlementPrice *float64 `json:"settlement_price,omitempty"`

				// Ticker The ticker for the contract.
				Ticker string `json:"ticker"`

				// Transactions The number of transactions that occurred within the timeframe.
				Transactions int64 `json:"transactions"`

				// Volume The number of contracts that traded within the timeframe.
				Volume int64 `json:"volume"`

				// WindowStart The timestamp of the beginning of the candlesticks aggregation window.
				WindowStart int64 `json:"window_start"`
			} `json:"results"`

			// Status The status of the response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXContractsResponse parses an HTTP response from a GetFuturesVXContractsWithResponse call
func ParseGetFuturesVXContractsResponse(rsp *http.Response) (*GetFuturesVXContractsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXContractsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Active Whether or not a given contract was tradeable at the given point in time. Active is true when (first_trade_date <= date >= last_trade_date) and false otherwise.
				Active bool `json:"active"`

				// Date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about contracts for the specified day.
				Date openapi_types.Date `json:"date"`

				// DaysToMaturity The number of calendar days between the 'date' and the contract's final settlement date.
				DaysToMaturity *int64 `json:"days_to_maturity,omitempty"`

				// FirstTradeDate The first day on which the contract was tradeable.
				FirstTradeDate *openapi_types.Date `json:"first_trade_date,omitempty"`

				// GroupCode An identifier used to identify logical groups of products. The group_code is only populated for contracts listed for trading on CME Globex.
				GroupCode *string `json:"group_code,omitempty"`

				// LastTradeDate The last day on which the contract was tradeable.
				LastTradeDate *openapi_types.Date `json:"last_trade_date,omitempty"`

				// MaxOrderQuantity The maximum order quantity.
				MaxOrderQuantity *int64 `json:"max_order_quantity,omitempty"`

				// MinOrderQuantity The minimum order quantity.
				MinOrderQuantity *int64 `json:"min_order_quantity,omitempty"`

				// Name The name of this contract.
				Name *string `json:"name,omitempty"`

				// ProductCode The identifier for the contract's product.
				ProductCode *string `json:"product_code,omitempty"`

				// SettlementDate The date on which this contract settles.
				SettlementDate *openapi_types.Date `json:"settlement_date,omitempty"`

				// SettlementTickSize The tick size for settlement.
				SettlementTickSize *float64 `json:"settlement_tick_size,omitempty"`

				// SpreadTickSize The tick size for spreads.
				SpreadTickSize *float64 `json:"spread_tick_size,omitempty"`

				// Ticker The ticker for the contract.
				Ticker *string `json:"ticker,omitempty"`

				// TradeTickSize The tick size for trades.
				TradeTickSize *float64 `json:"trade_tick_size,omitempty"`

				// TradingVenue The trading venue (MIC) for the exchange on which this contract trades.
				TradingVenue *string `json:"trading_venue,omitempty"`

				// Type The type of contract, one of 'single' or 'combo'. Leaving this filter blank will query for both 'single' and 'combo' types.
				Type *string `json:"type,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXContracts200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXContracts400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXExchangesResponse parses an HTTP response from a GetFuturesVXExchangesWithResponse call
func ParseGetFuturesVXExchangesResponse(rsp *http.Response) (*GetFuturesVXExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Acronym Well-known acronym for the exchange (e.g., 'CME', 'NYMEX', 'CBOT', 'COMEX').
				Acronym *string `json:"acronym,omitempty"`

				// Id Numeric identifier for the futures exchange or trading venue.
				Id string `json:"id"`

				// Locale Geographic location code where the exchange operates.
				Locale *string `json:"locale,omitempty"`

				// Mic Market Identifier Code (MIC) - ISO 10383 standard four-character code for the futures market.
				Mic *string `json:"mic,omitempty"`

				// Name Full official name of the futures exchange (e.g., 'Chicago Mercantile Exchange', 'New York Mercantile Exchange').
				Name string `json:"name"`

				// OperatingMic Operating Market Identifier Code for the futures exchange.
				OperatingMic *string `json:"operating_mic,omitempty"`

				// Type Type of venue - 'exchange' for futures exchanges and derivatives trading platforms.
				Type string `json:"type"`

				// Url Official website URL of the futures exchange organization.
				Url *string `json:"url,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXExchanges200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXExchanges400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXMarketStatusResponse parses an HTTP response from a GetFuturesVXMarketStatusWithResponse call
func ParseGetFuturesVXMarketStatusResponse(rsp *http.Response) (*GetFuturesVXMarketStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXMarketStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// MarketEvent The current status of the market for the product.
				MarketEvent *string `json:"market_event,omitempty"`

				// Name The name of the futures product.
				Name *string `json:"name,omitempty"`

				// ProductCode The product code of the futures contracts for which you want statuses.
				ProductCode *string `json:"product_code,omitempty"`

				// SessionEndDate The trading date for the current session.
				SessionEndDate *string `json:"session_end_date,omitempty"`

				// Timestamp The timestamp for the given market event.
				Timestamp *string `json:"timestamp,omitempty"`

				// TradingVenue The trading venue (MIC) for the exchange on which the corresponding product trades.
				TradingVenue *string `json:"trading_venue,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXMarketStatus200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXMarketStatus400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXProductsResponse parses an HTTP response from a GetFuturesVXProductsWithResponse call
func ParseGetFuturesVXProductsResponse(rsp *http.Response) (*GetFuturesVXProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AssetClass The asset class to which the product belongs.
				AssetClass *string `json:"asset_class,omitempty"`

				// AssetSubClass The asset sub-class to which the product belongs.
				AssetSubClass *string `json:"asset_sub_class,omitempty"`

				// Date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day.
				Date openapi_types.Date `json:"date"`

				// LastUpdated The date and time at which this product was last updated.
				LastUpdated *time.Time `json:"last_updated,omitempty"`

				// Name The full name of the product.
				Name *string `json:"name,omitempty"`

				// PriceQuotation The quoted price for this product.
				PriceQuotation *string `json:"price_quotation,omitempty"`

				// ProductCode The identifier for the product.
				ProductCode *string `json:"product_code,omitempty"`

				// Sector The sector to which the product belongs.
				Sector *string `json:"sector,omitempty"`

				// SettlementCurrencyCode The currency in which this product settles.
				SettlementCurrencyCode *string `json:"settlement_currency_code,omitempty"`

				// SettlementMethod The method of settlement for this product (Financially Settled or Deliverable).
				SettlementMethod *string `json:"settlement_method,omitempty"`

				// SettlementType The type of settlement for this product.
				SettlementType *string `json:"settlement_type,omitempty"`

				// SubSector The sub-sector to which the product belongs.
				SubSector *string `json:"sub_sector,omitempty"`

				// TradeCurrencyCode The currency in which this product's contracts trade.
				TradeCurrencyCode *string `json:"trade_currency_code,omitempty"`

				// TradingVenue The trading venue (MIC) for the exchange on which this product's contracts trade.
				TradingVenue *string `json:"trading_venue,omitempty"`

				// Type The type of product, one of 'single' or 'combo'. Leaving this filter blank will query for both 'single' and 'combo' types.
				Type *string `json:"type,omitempty"`

				// UnitOfMeasure The unit of measure for this product.
				UnitOfMeasure *string `json:"unit_of_measure,omitempty"`

				// UnitOfMeasureQty The quantity of the unit of measure for this product.
				UnitOfMeasureQty *float64 `json:"unit_of_measure_qty,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXProducts200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXProducts400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXQuotesNewResponse parses an HTTP response from a GetFuturesVXQuotesNewWithResponse call
func ParseGetFuturesVXQuotesNewResponse(rsp *http.Response) (*GetFuturesVXQuotesNewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXQuotesNewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AskPrice The ask price.
				AskPrice *float64 `json:"ask_price,omitempty"`

				// AskSize The ask size.
				AskSize *int32 `json:"ask_size,omitempty"`

				// AskTimestamp The nanosecond accuracy Unix Timestamp when the ask price was submitted to the exchange.
				AskTimestamp *int64 `json:"ask_timestamp,omitempty"`

				// BidPrice The bid price.
				BidPrice *float64 `json:"bid_price,omitempty"`

				// BidSize The bid size.
				BidSize *int32 `json:"bid_size,omitempty"`

				// BidTimestamp The nanosecond accuracy Unix Timestamp when the bid price was submitted to the exchange.
				BidTimestamp *int64 `json:"bid_timestamp,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange *int32 `json:"exchange,omitempty"`

				// ReportSequence The report sequence number.
				ReportSequence int64 `json:"report_sequence"`

				// SequenceNumber The sequence number represents the order in which quote events occurred for this ticker.
				SequenceNumber int64 `json:"sequence_number"`

				// SessionEndDate The trade date representing the session end date for this quote. Used for partitioning and filtering quotes by trading session.
				SessionEndDate string `json:"session_end_date"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// Timestamp The nanosecond accuracy Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				Timestamp int64 `json:"timestamp"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXQuotesNew200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXQuotesNew400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesQuotesResponse parses an HTTP response from a GetFuturesQuotesWithResponse call
func ParseGetFuturesQuotesResponse(rsp *http.Response) (*GetFuturesQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`
			Results *[]struct {
				// AskPrice The ask price is expressed per unit of the underlying asset, and you apply the contract multiplier to get the full contract value.
				AskPrice *float64 `json:"ask_price,omitempty"`

				// AskSize The quote size represents the number of futures contracts available at the given ask price.
				AskSize *float64 `json:"ask_size,omitempty"`

				// AskTimestamp The time when the ask price was submitted to the exchange.
				AskTimestamp *int `json:"ask_timestamp,omitempty"`

				// BidPrice The bid price is expressed per unit of the underlying asset, and you apply the contract multiplier to get the full contract value.
				BidPrice *float64 `json:"bid_price,omitempty"`

				// BidSize The quote size represents the number of futures contracts available at the given bid price.
				BidSize *float64 `json:"bid_size,omitempty"`

				// BidTimestamp The time when the bid price was submitted to the exchange.
				BidTimestamp *int `json:"bid_timestamp,omitempty"`

				// ReportSequence The reporting sequence number.
				ReportSequence int `json:"report_sequence"`

				// SequenceNumber The unique sequence number assigned to this quote by the exchange.
				SequenceNumber int `json:"sequence_number"`

				// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
				SessionEndDate string `json:"session_end_date"`

				// Ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
				Ticker string `json:"ticker"`

				// Timestamp The time when the quote was generated at the exchange to nanosecond precision.
				Timestamp int `json:"timestamp"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXSchedulesResponse parses an HTTP response from a GetFuturesVXSchedulesWithResponse call
func ParseGetFuturesVXSchedulesResponse(rsp *http.Response) (*GetFuturesVXSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Event The type of session on the given trading date.
				Event *string `json:"event,omitempty"`

				// ProductCode The product code of the futures contract.
				ProductCode *string `json:"product_code,omitempty"`

				// ProductName The name of the futures product to which this schedule applies.
				ProductName *string `json:"product_name,omitempty"`

				// SessionEndDate The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to 'today' in Central Time. e.g. If a request is made from Pacific Time on '2025-01-01' at 11:00 pm with no 'session_end_date' a default value of `2025-01-02` will be used.
				SessionEndDate *string `json:"session_end_date,omitempty"`

				// Timestamp The timestamp for the given market event.
				Timestamp *string `json:"timestamp,omitempty"`

				// TradingVenue The trading venue (MIC) for the exchange on which this schedule's product trades.
				TradingVenue *string `json:"trading_venue,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXSchedules200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXSchedules400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXSnapshotResponse parses an HTTP response from a GetFuturesVXSnapshotWithResponse call
func ParseGetFuturesVXSnapshotResponse(rsp *http.Response) (*GetFuturesVXSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				Details *struct {
					ProductCode *string `json:"product_code,omitempty"`

					// SettlementDate The day that this contract is settled.
					SettlementDate *openapi_types.Date `json:"settlement_date,omitempty"`
					Ticker         *string             `json:"ticker,omitempty"`
				} `json:"details,omitempty"`
				LastMinute *struct {
					// Close The price at the end of the minute bar.
					Close *float64 `json:"close,omitempty"`

					// High The highest price reached in the minute bar.
					High *float64 `json:"high,omitempty"`

					// LastUpdated The timestamp indicating the most recent update to the minute bar.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Low The lowest price reached in the minute bar.
					Low *float64 `json:"low,omitempty"`

					// Open The opening price at the start of the minute bar.
					Open      *float64 `json:"open,omitempty"`
					Timeframe *string  `json:"timeframe,omitempty"`

					// Volume The number of contracts traded in the minute bar.
					Volume *float64 `json:"volume,omitempty"`
				} `json:"last_minute,omitempty"`
				LastQuote *struct {
					// Ask The lowest price a seller is willing to accept.
					Ask *float64 `json:"ask,omitempty"`

					// AskSize The number of contracts available at the ask price.
					AskSize *int32 `json:"ask_size,omitempty"`

					// AskTimestamp The time when the best ask price was last updated.
					AskTimestamp *int64 `json:"ask_timestamp,omitempty"`

					// Bid The highest price a buyer is willing to pay.
					Bid *float64 `json:"bid,omitempty"`

					// BidSize The number of contracts available at the bid price.
					BidSize *int32 `json:"bid_size,omitempty"`

					// BidTimestamp The time when the best bid price was last updated.
					BidTimestamp *int64 `json:"bid_timestamp,omitempty"`

					// LastUpdated The time when the quote was generated at the exchange to nanosecond precision.
					LastUpdated *int64  `json:"last_updated,omitempty"`
					Timeframe   *string `json:"timeframe,omitempty"`
				} `json:"last_quote,omitempty"`
				LastTrade *struct {
					// LastUpdated The time when the trade was generated at the exchange to nanosecond precision.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
					Price *float64 `json:"price,omitempty"`

					// Size The total number of contracts exchanged between buyers and sellers on a given trade.
					Size      *int64  `json:"size,omitempty"`
					Timeframe *string `json:"timeframe,omitempty"`
				} `json:"last_trade,omitempty"`
				Session *struct {
					// Change The change in price during this session.
					Change *float64 `json:"change,omitempty"`

					// ChangePercent The percentage change in price during this session.
					ChangePercent *float64 `json:"change_percent,omitempty"`

					// Close The price at the end of the session.
					Close *float64 `json:"close,omitempty"`

					// High The highest price reached in the session.
					High *float64 `json:"high,omitempty"`

					// Low The lowest price reached in the session.
					Low *float64 `json:"low,omitempty"`

					// Open The opening price at the start of the session.
					Open *float64 `json:"open,omitempty"`

					// PreviousSettlement The settlement price of the previous session.
					PreviousSettlement *float64 `json:"previous_settlement,omitempty"`

					// SettlementPrice The final settlement price at the end of the session.
					SettlementPrice *float64 `json:"settlement_price,omitempty"`

					// Volume The number of contracts traded in the session.
					Volume *float64 `json:"volume,omitempty"`
				} `json:"session,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXSnapshot200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXSnapshot400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXSnapshotNativeResponse parses an HTTP response from a GetFuturesVXSnapshotNativeWithResponse call
func ParseGetFuturesVXSnapshotNativeResponse(rsp *http.Response) (*GetFuturesVXSnapshotNativeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXSnapshotNativeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				Details *struct {
					ProductCode *string `json:"product_code,omitempty"`

					// SettlementDate The day that this contract is settled.
					SettlementDate *openapi_types.Date `json:"settlement_date,omitempty"`
					Ticker         *string             `json:"ticker,omitempty"`
				} `json:"details,omitempty"`
				LastMinute *struct {
					// Close The price at the end of the minute bar.
					Close *float64 `json:"close,omitempty"`

					// High The highest price reached in the minute bar.
					High *float64 `json:"high,omitempty"`

					// LastUpdated The timestamp indicating the most recent update to the minute bar.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Low The lowest price reached in the minute bar.
					Low *float64 `json:"low,omitempty"`

					// Open The opening price at the start of the minute bar.
					Open      *float64 `json:"open,omitempty"`
					Timeframe *string  `json:"timeframe,omitempty"`

					// Volume The number of contracts traded in the minute bar.
					Volume *float64 `json:"volume,omitempty"`
				} `json:"last_minute,omitempty"`
				LastQuote *struct {
					// Ask The lowest price a seller is willing to accept.
					Ask *float64 `json:"ask,omitempty"`

					// AskSize The number of contracts available at the ask price.
					AskSize *int32 `json:"ask_size,omitempty"`

					// AskTimestamp The time when the best ask price was last updated.
					AskTimestamp *int64 `json:"ask_timestamp,omitempty"`

					// Bid The highest price a buyer is willing to pay.
					Bid *float64 `json:"bid,omitempty"`

					// BidSize The number of contracts available at the bid price.
					BidSize *int32 `json:"bid_size,omitempty"`

					// BidTimestamp The time when the best bid price was last updated.
					BidTimestamp *int64 `json:"bid_timestamp,omitempty"`

					// LastUpdated The time when the quote was generated at the exchange to nanosecond precision.
					LastUpdated *int64  `json:"last_updated,omitempty"`
					Timeframe   *string `json:"timeframe,omitempty"`
				} `json:"last_quote,omitempty"`
				LastTrade *struct {
					// LastUpdated The time when the trade was generated at the exchange to nanosecond precision.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
					Price *float64 `json:"price,omitempty"`

					// Size The total number of contracts exchanged between buyers and sellers on a given trade.
					Size      *int64  `json:"size,omitempty"`
					Timeframe *string `json:"timeframe,omitempty"`
				} `json:"last_trade,omitempty"`
				Session *struct {
					// Change The change in price during this session.
					Change *float64 `json:"change,omitempty"`

					// ChangePercent The percentage change in price during this session.
					ChangePercent *float64 `json:"change_percent,omitempty"`

					// Close The price at the end of the session.
					Close *float64 `json:"close,omitempty"`

					// High The highest price reached in the session.
					High *float64 `json:"high,omitempty"`

					// Low The lowest price reached in the session.
					Low *float64 `json:"low,omitempty"`

					// Open The opening price at the start of the session.
					Open *float64 `json:"open,omitempty"`

					// PreviousSettlement The settlement price of the previous session.
					PreviousSettlement *float64 `json:"previous_settlement,omitempty"`

					// SettlementPrice The final settlement price at the end of the session.
					SettlementPrice *float64 `json:"settlement_price,omitempty"`

					// Volume The number of contracts traded in the session.
					Volume *float64 `json:"volume,omitempty"`
				} `json:"session,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXSnapshotNative200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXSnapshotNative400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesVXTradesNewResponse parses an HTTP response from a GetFuturesVXTradesNewWithResponse call
func ParseGetFuturesVXTradesNewResponse(rsp *http.Response) (*GetFuturesVXTradesNewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesVXTradesNewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Correction The trade correction indicator.
				Correction *int64 `json:"correction,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange *int32 `json:"exchange,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
				Price float64 `json:"price"`

				// ReportSequence The report sequence number.
				ReportSequence int64 `json:"report_sequence"`

				// SequenceNumber The sequence number represents the sequence in which trade events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
				SequenceNumber int64 `json:"sequence_number"`

				// SessionEndDate The trade date representing the session end date for this trade. Used for partitioning and filtering trades by trading session.
				SessionEndDate string `json:"session_end_date"`

				// Size The total number of contracts exchanged between buyers and sellers on a given trade.
				Size *int64 `json:"size,omitempty"`

				// Ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&P 500 E-mini contract).
				Ticker string `json:"ticker"`

				// Timestamp The time when the trade was generated at the exchange to nanosecond precision.
				Timestamp int64 `json:"timestamp"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetFuturesVXTradesNew200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetFuturesVXTradesNew400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFuturesTradesResponse parses an HTTP response from a GetFuturesTradesWithResponse call
func ParseGetFuturesTradesResponse(rsp *http.Response) (*GetFuturesTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFuturesTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`
			Results *[]struct {
				// Price The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
				Price float64 `json:"price"`

				// ReportSequence The reporting sequence number.
				ReportSequence int `json:"report_sequence"`

				// SequenceNumber The unique sequence number assigned to this trade.
				SequenceNumber int `json:"sequence_number"`

				// SessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
				SessionEndDate string `json:"session_end_date"`

				// Size The total number of contracts exchanged between buyers and sellers on a given trade.
				Size float64 `json:"size"`

				// Ticker ticker of the trade
				Ticker string `json:"ticker"`

				// Timestamp The time when the trade was generated at the exchange to nanosecond precision.
				Timestamp int `json:"timestamp"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionsV1ExchangesResponse parses an HTTP response from a GetOptionsV1ExchangesWithResponse call
func ParseGetOptionsV1ExchangesResponse(rsp *http.Response) (*GetOptionsV1ExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsV1ExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Acronym Exchange acronym or short name (e.g., 'ISE', 'GEMX') - may be null for some venues.
				Acronym *string `json:"acronym,omitempty"`

				// Id Numeric identifier for the options trading venue or exchange.
				Id string `json:"id"`

				// Locale Geographic location code.
				Locale *string `json:"locale,omitempty"`

				// Mic Market Identifier Code (MIC) - ISO 10383 standard four-character code identifying the specific options market.
				Mic *string `json:"mic,omitempty"`

				// Name Full official name of the options exchange or trading venue.
				Name string `json:"name"`

				// OperatingMic Operating Market Identifier Code - identifies the parent organization or operating entity.
				OperatingMic *string `json:"operating_mic,omitempty"`

				// ParticipantId Single-character participant identifier used in consolidator market data feeds and options trade reporting.
				ParticipantId *string `json:"participant_id,omitempty"`

				// Type Type of venue: 'exchange' for options exchanges, 'SIP' for Securities Information Processors like OPRA (Options Price Reporting Authority).
				Type string `json:"type"`

				// Url Official website URL of the organization operating the options exchange.
				Url *string `json:"url,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetOptionsV1Exchanges200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetOptionsV1Exchanges400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFilings10KVXSectionsResponse parses an HTTP response from a GetStocksFilings10KVXSectionsWithResponse call
func ParseGetStocksFilings10KVXSectionsResponse(rsp *http.Response) (*GetStocksFilings10KVXSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFilings10KVXSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Cik SEC Central Index Key (10 digits, zero-padded).
				Cik *string `json:"cik,omitempty"`

				// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
				FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

				// FilingUrl SEC URL source for the full filing.
				FilingUrl *string `json:"filing_url,omitempty"`

				// PeriodEnd Period end date that the filing relates to (formatted as YYYY-MM-DD).
				PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

				// Section Standardized section identifier from the filing (e.g. 'business', 'risk_factors', etc.).
				Section *string `json:"section,omitempty"`

				// Text Full raw text content of the section, including headers and formatting.
				Text *string `json:"text,omitempty"`

				// Ticker Stock ticker symbol for the company.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFilings10KVXSections200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFilings10KVXSections400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFilingsVXIndexResponse parses an HTTP response from a GetStocksFilingsVXIndexWithResponse call
func ParseGetStocksFilingsVXIndexResponse(rsp *http.Response) (*GetStocksFilingsVXIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFilingsVXIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AccessionNumber SEC accession number uniquely identifying the filing (e.g., '0000320193-24-000123').
				AccessionNumber *string `json:"accession_number,omitempty"`

				// Cik SEC Central Index Key (CIK) identifying the filing entity.
				Cik *string `json:"cik,omitempty"`

				// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
				FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

				// FilingUrl Direct URL to the filing on the SEC EDGAR website.
				FilingUrl *string `json:"filing_url,omitempty"`

				// FormType SEC form type (e.g., '10-K', '10-Q', '8-K', 'S-1', '4', etc.).
				FormType *string `json:"form_type,omitempty"`

				// IssuerName Name of the company or entity that submitted the filing.
				IssuerName *string `json:"issuer_name,omitempty"`

				// Ticker Stock ticker symbol for the filing entity, if available.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFilingsVXIndex200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFilingsVXIndex400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFilingsVXRiskFactorsResponse parses an HTTP response from a GetStocksFilingsVXRiskFactorsWithResponse call
func ParseGetStocksFilingsVXRiskFactorsResponse(rsp *http.Response) (*GetStocksFilingsVXRiskFactorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFilingsVXRiskFactorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Cik SEC Central Index Key (10 digits, zero-padded).
				Cik *string `json:"cik,omitempty"`

				// FilingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD).
				FilingDate *string `json:"filing_date,omitempty"`

				// PrimaryCategory Top-level risk category
				PrimaryCategory *string `json:"primary_category,omitempty"`

				// SecondaryCategory Mid-level risk category
				SecondaryCategory *string `json:"secondary_category,omitempty"`

				// SupportingText Snippet of text to support the given label
				SupportingText *string `json:"supporting_text,omitempty"`

				// TertiaryCategory Most specific risk classification
				TertiaryCategory *string `json:"tertiary_category,omitempty"`

				// Ticker Stock ticker symbol for the company.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFilingsVXRiskFactors200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFilingsVXRiskFactors400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFinancialsV1BalanceSheetsResponse parses an HTTP response from a GetStocksFinancialsV1BalanceSheetsWithResponse call
func ParseGetStocksFinancialsV1BalanceSheetsResponse(rsp *http.Response) (*GetStocksFinancialsV1BalanceSheetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFinancialsV1BalanceSheetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AccountsPayable Amounts owed to suppliers and vendors for goods and services purchased on credit.
				AccountsPayable *float64 `json:"accounts_payable,omitempty"`

				// AccruedAndOtherCurrentLiabilities Current liabilities not classified elsewhere, including accrued expenses, taxes payable, and other obligations due within one year.
				AccruedAndOtherCurrentLiabilities *float64 `json:"accrued_and_other_current_liabilities,omitempty"`

				// AccumulatedOtherComprehensiveIncome Cumulative gains and losses that bypass the income statement, including foreign currency translation adjustments and unrealized gains/losses on securities.
				AccumulatedOtherComprehensiveIncome *float64 `json:"accumulated_other_comprehensive_income,omitempty"`

				// AdditionalPaidInCapital Amount received from shareholders in excess of the par or stated value of shares issued.
				AdditionalPaidInCapital *float64 `json:"additional_paid_in_capital,omitempty"`

				// CashAndEquivalents Cash on hand and short-term, highly liquid investments that are readily convertible to known amounts of cash.
				CashAndEquivalents *float64 `json:"cash_and_equivalents,omitempty"`

				// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a company's CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
				Cik *string `json:"cik,omitempty"`

				// CommitmentsAndContingencies Disclosed amount related to contractual commitments and potential liabilities that may arise from uncertain future events.
				CommitmentsAndContingencies *float64 `json:"commitments_and_contingencies,omitempty"`

				// CommonStock Par or stated value of common shares outstanding representing basic ownership in the company.
				CommonStock *float64 `json:"common_stock,omitempty"`

				// DebtCurrent Short-term borrowings and the current portion of long-term debt due within one year.
				DebtCurrent *float64 `json:"debt_current,omitempty"`

				// DeferredRevenueCurrent Customer payments received in advance for goods or services to be delivered within one year.
				DeferredRevenueCurrent *float64 `json:"deferred_revenue_current,omitempty"`

				// FilingDate The date when the financial statement was filed with the SEC.
				FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

				// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
				FiscalQuarter *float64 `json:"fiscal_quarter,omitempty"`

				// FiscalYear The fiscal year for the reporting period.
				FiscalYear *float64 `json:"fiscal_year,omitempty"`

				// Goodwill Intangible asset representing the excess of purchase price over fair value of net assets acquired in business combinations.
				Goodwill *float64 `json:"goodwill,omitempty"`

				// IntangibleAssetsNet Intangible assets other than goodwill, including patents, trademarks, and customer relationships, net of accumulated amortization.
				IntangibleAssetsNet *float64 `json:"intangible_assets_net,omitempty"`

				// Inventories Raw materials, work-in-process, and finished goods held for sale in the ordinary course of business.
				Inventories *float64 `json:"inventories,omitempty"`

				// LongTermDebtAndCapitalLeaseObligations Long-term borrowings and capital lease obligations with maturities greater than one year.
				LongTermDebtAndCapitalLeaseObligations *float64 `json:"long_term_debt_and_capital_lease_obligations,omitempty"`

				// NoncontrollingInterest Equity in consolidated subsidiaries not owned by the parent company, representing minority shareholders' ownership.
				NoncontrollingInterest *float64 `json:"noncontrolling_interest,omitempty"`

				// OtherAssets Non-current assets not classified elsewhere, including long-term investments, deferred tax assets, and other long-term assets.
				OtherAssets *float64 `json:"other_assets,omitempty"`

				// OtherCurrentAssets Current assets not classified elsewhere, including prepaid expenses, taxes receivable, and other assets expected to be converted to cash within one year.
				OtherCurrentAssets *float64 `json:"other_current_assets,omitempty"`

				// OtherEquity Equity components not classified elsewhere in shareholders' equity.
				OtherEquity *float64 `json:"other_equity,omitempty"`

				// OtherNoncurrentLiabilities Non-current liabilities not classified elsewhere, including deferred tax liabilities, pension obligations, and other long-term liabilities.
				OtherNoncurrentLiabilities *float64 `json:"other_noncurrent_liabilities,omitempty"`

				// PeriodEnd The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken.
				PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

				// PreferredStock Par or stated value of preferred shares outstanding with preferential rights over common stock.
				PreferredStock *float64 `json:"preferred_stock,omitempty"`

				// PropertyPlantEquipmentNet Tangible fixed assets used in operations, reported net of accumulated depreciation.
				PropertyPlantEquipmentNet *float64 `json:"property_plant_equipment_net,omitempty"`

				// Receivables Amounts owed to the company by customers and other parties, primarily accounts receivable, net of allowances for doubtful accounts.
				Receivables *float64 `json:"receivables,omitempty"`

				// RetainedEarningsDeficit Cumulative net income earned by the company less dividends paid to shareholders since inception.
				RetainedEarningsDeficit *float64 `json:"retained_earnings_deficit,omitempty"`

				// ShortTermInvestments Marketable securities and other investments with maturities of one year or less that are not classified as cash equivalents.
				ShortTermInvestments *float64 `json:"short_term_investments,omitempty"`

				// Tickers A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
				Tickers *[]string `json:"tickers,omitempty"`

				// Timeframe The reporting period type. Possible values include: quarterly, annual.
				Timeframe string `json:"timeframe"`

				// TotalAssets Sum of all current and non-current assets representing everything the company owns or controls.
				TotalAssets *float64 `json:"total_assets,omitempty"`

				// TotalCurrentAssets Sum of all current assets expected to be converted to cash, sold, or consumed within one year.
				TotalCurrentAssets *float64 `json:"total_current_assets,omitempty"`

				// TotalCurrentLiabilities Sum of all liabilities expected to be settled within one year.
				TotalCurrentLiabilities *float64 `json:"total_current_liabilities,omitempty"`

				// TotalEquity Sum of all equity components representing shareholders' total ownership interest in the company.
				TotalEquity *float64 `json:"total_equity,omitempty"`

				// TotalEquityAttributableToParent Total shareholders' equity attributable to the parent company, excluding noncontrolling interests.
				TotalEquityAttributableToParent *float64 `json:"total_equity_attributable_to_parent,omitempty"`

				// TotalLiabilities Sum of all current and non-current liabilities representing everything the company owes.
				TotalLiabilities *float64 `json:"total_liabilities,omitempty"`

				// TotalLiabilitiesAndEquity Sum of total liabilities and total equity, which should equal total assets per the fundamental accounting equation.
				TotalLiabilitiesAndEquity *float64 `json:"total_liabilities_and_equity,omitempty"`

				// TreasuryStock Cost of the company's own shares that have been repurchased and are held in treasury, typically reported as a negative value.
				TreasuryStock *float64 `json:"treasury_stock,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1BalanceSheets200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1BalanceSheets400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFinancialsV1CashFlowStatementsResponse parses an HTTP response from a GetStocksFinancialsV1CashFlowStatementsWithResponse call
func ParseGetStocksFinancialsV1CashFlowStatementsResponse(rsp *http.Response) (*GetStocksFinancialsV1CashFlowStatementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFinancialsV1CashFlowStatementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// CashFromOperatingActivitiesContinuingOperations Cash generated from continuing business operations before discontinued operations.
				CashFromOperatingActivitiesContinuingOperations *float64 `json:"cash_from_operating_activities_continuing_operations,omitempty"`

				// ChangeInCashAndEquivalents Net change in cash and cash equivalents during the period, representing the sum of operating, investing, and financing cash flows plus currency effects.
				ChangeInCashAndEquivalents *float64 `json:"change_in_cash_and_equivalents,omitempty"`

				// ChangeInOtherOperatingAssetsAndLiabilitiesNet Net change in working capital components including accounts receivable, inventory, accounts payable, and other operating items.
				ChangeInOtherOperatingAssetsAndLiabilitiesNet *float64 `json:"change_in_other_operating_assets_and_liabilities_net,omitempty"`

				// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
				Cik *string `json:"cik,omitempty"`

				// DepreciationDepletionAndAmortization Non-cash charges for the reduction in value of tangible and intangible assets over time.
				DepreciationDepletionAndAmortization *float64 `json:"depreciation_depletion_and_amortization,omitempty"`

				// Dividends Cash payments to shareholders in the form of dividends, typically reported as negative values.
				Dividends *float64 `json:"dividends,omitempty"`

				// EffectOfCurrencyExchangeRate Impact of foreign exchange rate changes on cash and cash equivalents denominated in foreign currencies.
				EffectOfCurrencyExchangeRate *float64 `json:"effect_of_currency_exchange_rate,omitempty"`

				// FilingDate The date when the financial statement was filed with the SEC.
				FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

				// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
				FiscalQuarter *float64 `json:"fiscal_quarter,omitempty"`

				// FiscalYear The fiscal year for the reporting period.
				FiscalYear *float64 `json:"fiscal_year,omitempty"`

				// IncomeLossFromDiscontinuedOperations After-tax income or loss from business operations that have been discontinued.
				IncomeLossFromDiscontinuedOperations *float64 `json:"income_loss_from_discontinued_operations,omitempty"`

				// LongTermDebtIssuancesRepayments Net cash flows from issuing or repaying long-term debt obligations.
				LongTermDebtIssuancesRepayments *float64 `json:"long_term_debt_issuances_repayments,omitempty"`

				// NetCashFromFinancingActivities Total cash generated or used by financing activities, including debt issuance, debt repayment, dividends, and share transactions.
				NetCashFromFinancingActivities *float64 `json:"net_cash_from_financing_activities,omitempty"`

				// NetCashFromFinancingActivitiesContinuingOperations Cash flows from financing activities of continuing operations before discontinued operations.
				NetCashFromFinancingActivitiesContinuingOperations *float64 `json:"net_cash_from_financing_activities_continuing_operations,omitempty"`

				// NetCashFromFinancingActivitiesDiscontinuedOperations Cash flows from financing activities of discontinued business segments.
				NetCashFromFinancingActivitiesDiscontinuedOperations *float64 `json:"net_cash_from_financing_activities_discontinued_operations,omitempty"`

				// NetCashFromInvestingActivities Total cash generated or used by investing activities, including capital expenditures, acquisitions, and asset sales.
				NetCashFromInvestingActivities *float64 `json:"net_cash_from_investing_activities,omitempty"`

				// NetCashFromInvestingActivitiesContinuingOperations Cash flows from investing activities of continuing operations before discontinued operations.
				NetCashFromInvestingActivitiesContinuingOperations *float64 `json:"net_cash_from_investing_activities_continuing_operations,omitempty"`

				// NetCashFromInvestingActivitiesDiscontinuedOperations Cash flows from investing activities of discontinued business segments.
				NetCashFromInvestingActivitiesDiscontinuedOperations *float64 `json:"net_cash_from_investing_activities_discontinued_operations,omitempty"`

				// NetCashFromOperatingActivities Total cash generated or used by operating activities, representing cash flow from core business operations.
				NetCashFromOperatingActivities *float64 `json:"net_cash_from_operating_activities,omitempty"`

				// NetCashFromOperatingActivitiesDiscontinuedOperations Cash flows from operating activities of discontinued business segments.
				NetCashFromOperatingActivitiesDiscontinuedOperations *float64 `json:"net_cash_from_operating_activities_discontinued_operations,omitempty"`

				// NetIncome Net income used as the starting point for operating cash flow calculations.
				NetIncome *float64 `json:"net_income,omitempty"`

				// NoncontrollingInterests Cash flows related to minority shareholders in consolidated subsidiaries.
				NoncontrollingInterests *float64 `json:"noncontrolling_interests,omitempty"`

				// OtherCashAdjustments Other miscellaneous adjustments to cash flows not classified elsewhere.
				OtherCashAdjustments *float64 `json:"other_cash_adjustments,omitempty"`

				// OtherFinancingActivities Cash flows from financing activities not classified elsewhere, including share repurchases and other equity transactions.
				OtherFinancingActivities *float64 `json:"other_financing_activities,omitempty"`

				// OtherInvestingActivities Cash flows from investing activities not classified elsewhere, including acquisitions, divestitures, and investments.
				OtherInvestingActivities *float64 `json:"other_investing_activities,omitempty"`

				// OtherOperatingActivities Other adjustments to reconcile net income to operating cash flow not classified elsewhere.
				OtherOperatingActivities *float64 `json:"other_operating_activities,omitempty"`

				// PeriodEnd The last date of the reporting period (formatted as YYYY-MM-DD).
				PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

				// PurchaseOfPropertyPlantAndEquipment Cash outflows for capital expenditures on fixed assets, typically reported as negative values.
				PurchaseOfPropertyPlantAndEquipment *float64 `json:"purchase_of_property_plant_and_equipment,omitempty"`

				// SaleOfPropertyPlantAndEquipment Cash inflows from disposing of fixed assets, typically reported as positive values.
				SaleOfPropertyPlantAndEquipment *float64 `json:"sale_of_property_plant_and_equipment,omitempty"`

				// ShortTermDebtIssuancesRepayments Net cash flows from issuing or repaying short-term debt obligations.
				ShortTermDebtIssuancesRepayments *float64 `json:"short_term_debt_issuances_repayments,omitempty"`

				// Tickers A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
				Tickers *[]string `json:"tickers,omitempty"`

				// Timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
				Timeframe *string `json:"timeframe,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1CashFlowStatements200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1CashFlowStatements400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFinancialsV1IncomeStatementsResponse parses an HTTP response from a GetStocksFinancialsV1IncomeStatementsWithResponse call
func ParseGetStocksFinancialsV1IncomeStatementsResponse(rsp *http.Response) (*GetStocksFinancialsV1IncomeStatementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFinancialsV1IncomeStatementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// BasicEarningsPerShare Earnings per share calculated using the weighted average number of basic shares outstanding. For TTM records, recalculated as TTM net income divided by average basic shares outstanding over the four quarters.
				BasicEarningsPerShare *float64 `json:"basic_earnings_per_share,omitempty"`

				// BasicSharesOutstanding Weighted average number of common shares outstanding during the period, used in basic EPS calculation. For TTM records, represents the average over the four most recent quarters.
				BasicSharesOutstanding *float64 `json:"basic_shares_outstanding,omitempty"`

				// Cik The company's Central Index Key (CIK), a unique identifier assigned by the U.AskSize. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
				Cik *string `json:"cik,omitempty"`

				// ConsolidatedNetIncomeLoss Total net income or loss for the consolidated entity including all subsidiaries.
				ConsolidatedNetIncomeLoss *float64 `json:"consolidated_net_income_loss,omitempty"`

				// CostOfRevenue Direct costs attributable to the production of goods or services sold, also known as cost of goods sold (COGS).
				CostOfRevenue *float64 `json:"cost_of_revenue,omitempty"`

				// DepreciationDepletionAmortization Non-cash expenses representing the allocation of asset costs over their useful lives.
				DepreciationDepletionAmortization *float64 `json:"depreciation_depletion_amortization,omitempty"`

				// DilutedEarningsPerShare Earnings per share calculated using diluted shares outstanding, including the effect of potentially dilutive securities. For TTM records, recalculated as TTM net income divided by average diluted shares outstanding over the four quarters.
				DilutedEarningsPerShare *float64 `json:"diluted_earnings_per_share,omitempty"`

				// DilutedSharesOutstanding Weighted average number of shares outstanding including the dilutive effect of stock options, warrants, and convertible securities. For TTM records, represents the average over the four most recent quarters.
				DilutedSharesOutstanding *float64 `json:"diluted_shares_outstanding,omitempty"`

				// DiscontinuedOperations After-tax results from business segments that have been or will be disposed of.
				DiscontinuedOperations *float64 `json:"discontinued_operations,omitempty"`

				// Ebitda Earnings before interest, taxes, depreciation, and amortization, a measure of operating performance.
				Ebitda *float64 `json:"ebitda,omitempty"`

				// EquityInAffiliates The company's share of income or losses from equity method investments in affiliated companies.
				EquityInAffiliates *float64 `json:"equity_in_affiliates,omitempty"`

				// ExtraordinaryItems Unusual and infrequent gains or losses that are both unusual in nature and infrequent in occurrence.
				ExtraordinaryItems *float64 `json:"extraordinary_items,omitempty"`

				// FilingDate The date when the financial statement was filed with the SEC.
				FilingDate *openapi_types.Date `json:"filing_date,omitempty"`

				// FiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
				FiscalQuarter *float64 `json:"fiscal_quarter,omitempty"`

				// FiscalYear The fiscal year for the reporting period.
				FiscalYear *float64 `json:"fiscal_year,omitempty"`

				// GrossProfit Revenue minus cost of revenue, representing profit before operating expenses.
				GrossProfit *float64 `json:"gross_profit,omitempty"`

				// IncomeBeforeIncomeTaxes Pre-tax income calculated as operating income plus total other income/expense.
				IncomeBeforeIncomeTaxes *float64 `json:"income_before_income_taxes,omitempty"`

				// IncomeTaxes Income tax expense or benefit for the period.
				IncomeTaxes *float64 `json:"income_taxes,omitempty"`

				// InterestExpense Cost of borrowed funds, including interest on debt and other financing obligations.
				InterestExpense *float64 `json:"interest_expense,omitempty"`

				// InterestIncome Income earned from interest-bearing investments and cash equivalents.
				InterestIncome *float64 `json:"interest_income,omitempty"`

				// NetIncomeLossAttributableCommonShareholders Net income or loss available to common shareholders after preferred dividends and noncontrolling interests.
				NetIncomeLossAttributableCommonShareholders *float64 `json:"net_income_loss_attributable_common_shareholders,omitempty"`

				// NoncontrollingInterest The portion of net income attributable to minority shareholders in consolidated subsidiaries.
				NoncontrollingInterest *float64 `json:"noncontrolling_interest,omitempty"`

				// OperatingIncome Income from operations calculated as gross profit minus total operating expenses, excluding non-operating items.
				OperatingIncome *float64 `json:"operating_income,omitempty"`

				// OtherIncomeExpense Non-operating income and expenses not related to the company's core business operations.
				OtherIncomeExpense *float64 `json:"other_income_expense,omitempty"`

				// OtherOperatingExpenses Operating expenses not classified in the main expense categories.
				OtherOperatingExpenses *float64 `json:"other_operating_expenses,omitempty"`

				// PeriodEnd The last date of the reporting period (formatted as YYYY-MM-DD).
				PeriodEnd *openapi_types.Date `json:"period_end,omitempty"`

				// PreferredStockDividendsDeclared Dividends declared on preferred stock during the period.
				PreferredStockDividendsDeclared *float64 `json:"preferred_stock_dividends_declared,omitempty"`

				// ResearchDevelopment Expenses incurred for research and development activities to create new products or improve existing ones.
				ResearchDevelopment *float64 `json:"research_development,omitempty"`

				// Revenue Total revenue or net sales for the period, representing the company's gross income from operations.
				Revenue *float64 `json:"revenue,omitempty"`

				// SellingGeneralAdministrative Expenses related to selling products and general administrative costs not directly tied to production.
				SellingGeneralAdministrative *float64 `json:"selling_general_administrative,omitempty"`

				// Tickers A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
				Tickers *[]string `json:"tickers,omitempty"`

				// Timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
				Timeframe *string `json:"timeframe,omitempty"`

				// TotalOperatingExpenses Sum of all operating expenses including cost of revenue, SG&A, R&D, depreciation, and other operating expenses.
				TotalOperatingExpenses *float64 `json:"total_operating_expenses,omitempty"`

				// TotalOtherIncomeExpense Net total of all non-operating income and expenses including interest income, interest expense, and other items.
				TotalOtherIncomeExpense *float64 `json:"total_other_income_expense,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1IncomeStatements200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1IncomeStatements400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksFinancialsV1RatiosResponse parses an HTTP response from a GetStocksFinancialsV1RatiosWithResponse call
func ParseGetStocksFinancialsV1RatiosResponse(rsp *http.Response) (*GetStocksFinancialsV1RatiosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksFinancialsV1RatiosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AverageVolume Average trading volume over the last 30 trading days, providing context for liquidity.
				AverageVolume *float64 `json:"average_volume,omitempty"`

				// Cash Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage.
				Cash *float64 `json:"cash,omitempty"`

				// Cik Central Index Key (CIK) number assigned by the SEC to identify the company.
				Cik *string `json:"cik,omitempty"`

				// Current Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity.
				Current *float64 `json:"current,omitempty"`

				// Date Date for which the ratios are calculated, representing the trading date with available price data.
				Date string `json:"date"`

				// DebtToEquity Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders' equity, measuring financial leverage.
				DebtToEquity *float64 `json:"debt_to_equity,omitempty"`

				// DividendYield Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment.
				DividendYield *float64 `json:"dividend_yield,omitempty"`

				// EarningsPerShare Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding.
				EarningsPerShare *float64 `json:"earnings_per_share,omitempty"`

				// EnterpriseValue Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value.
				EnterpriseValue *float64 `json:"enterprise_value,omitempty"`

				// EvToEbitda Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization.
				EvToEbitda *float64 `json:"ev_to_ebitda,omitempty"`

				// EvToSales Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales.
				EvToSales *float64 `json:"ev_to_sales,omitempty"`

				// FreeCashFlow Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment).
				FreeCashFlow *float64 `json:"free_cash_flow,omitempty"`

				// MarketCap Market capitalization, calculated as stock price multiplied by total shares outstanding.
				MarketCap *float64 `json:"market_cap,omitempty"`

				// Price Stock price used in ratio calculations, typically the closing price for the given date.
				Price *float64 `json:"price,omitempty"`

				// PriceToBook Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value.
				PriceToBook *float64 `json:"price_to_book,omitempty"`

				// PriceToCashFlow Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive.
				PriceToCashFlow *float64 `json:"price_to_cash_flow,omitempty"`

				// PriceToEarnings Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive.
				PriceToEarnings *float64 `json:"price_to_earnings,omitempty"`

				// PriceToFreeCashFlow Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive.
				PriceToFreeCashFlow *float64 `json:"price_to_free_cash_flow,omitempty"`

				// PriceToSales Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales.
				PriceToSales *float64 `json:"price_to_sales,omitempty"`

				// Quick Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity.
				Quick *float64 `json:"quick,omitempty"`

				// ReturnOnAssets Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit.
				ReturnOnAssets *float64 `json:"return_on_assets,omitempty"`

				// ReturnOnEquity Return on equity ratio, calculated as net income divided by total shareholders' equity, measuring profitability relative to shareholders' equity.
				ReturnOnEquity *float64 `json:"return_on_equity,omitempty"`

				// Ticker Stock ticker symbol for the company.
				Ticker string `json:"ticker"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1Ratios200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksFinancialsV1Ratios400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksTaxonomiesVXRiskFactorsResponse parses an HTTP response from a GetStocksTaxonomiesVXRiskFactorsWithResponse call
func ParseGetStocksTaxonomiesVXRiskFactorsResponse(rsp *http.Response) (*GetStocksTaxonomiesVXRiskFactorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksTaxonomiesVXRiskFactorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Description Detailed explanation of what this risk category encompasses, including specific examples and potential impacts
				Description *string `json:"description,omitempty"`

				// PrimaryCategory Top-level risk category
				PrimaryCategory *string `json:"primary_category,omitempty"`

				// SecondaryCategory Mid-level risk category
				SecondaryCategory *string `json:"secondary_category,omitempty"`

				// Taxonomy Version identifier (e.g., '1.0', '1.1') for the taxonomy
				Taxonomy float64 `json:"taxonomy"`

				// TertiaryCategory Most specific risk classification
				TertiaryCategory *string `json:"tertiary_category,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksTaxonomiesVXRiskFactors200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksTaxonomiesVXRiskFactors400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksV1DividendsResponse parses an HTTP response from a GetStocksV1DividendsWithResponse call
func ParseGetStocksV1DividendsResponse(rsp *http.Response) (*GetStocksV1DividendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksV1DividendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// CashAmount Original dividend amount per share in the specified currency
				CashAmount *float64 `json:"cash_amount,omitempty"`

				// Currency Currency code for the dividend payment (e.g., USD, CAD)
				Currency *string `json:"currency,omitempty"`

				// DeclarationDate Date when the company officially announced the dividend
				DeclarationDate *openapi_types.Date `json:"declaration_date,omitempty"`

				// DistributionType Classification describing the nature of this dividend's recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
				DistributionType string `json:"distribution_type"`

				// ExDividendDate Date when the stock begins trading without the dividend value
				ExDividendDate *openapi_types.Date `json:"ex_dividend_date,omitempty"`

				// Frequency How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 52 (weekly), 104 (bi-weekly), and 365 (daily) depending on the issuer's declared or inferred payout cadence.
				Frequency *int64 `json:"frequency,omitempty"`

				// HistoricalAdjustmentFactor Cumulative adjustment factor used to offset dividend effects on historical prices. To adjust a historical price for dividends: for a price on date D, find the first dividend whose `ex_dividend_date` is after date D and multiply the price by that dividend's `historical_adjustment_factor`.
				HistoricalAdjustmentFactor *float64 `json:"historical_adjustment_factor,omitempty"`

				// Id Unique identifier for each dividend record
				Id *string `json:"id,omitempty"`

				// PayDate Date when the dividend payment is distributed to shareholders
				PayDate *openapi_types.Date `json:"pay_date,omitempty"`

				// RecordDate Date when shareholders must be on record to be eligible for the dividend payment
				RecordDate *openapi_types.Date `json:"record_date,omitempty"`

				// SplitAdjustedCashAmount Dividend amount adjusted for stock splits that occurred after the dividend was paid, expressed on a current share basis
				SplitAdjustedCashAmount *float64 `json:"split_adjusted_cash_amount,omitempty"`

				// Ticker Stock symbol for the company issuing the dividend
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksV1Dividends200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksV1Dividends400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksV1ExchangesResponse parses an HTTP response from a GetStocksV1ExchangesWithResponse call
func ParseGetStocksV1ExchangesResponse(rsp *http.Response) (*GetStocksV1ExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksV1ExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// Acronym Short acronym or abbreviation (may be null for some venues).
				Acronym *string `json:"acronym,omitempty"`

				// Id Numeric identifier for the trading venue or exchange.
				Id string `json:"id"`

				// Locale Geographic location code.
				Locale *string `json:"locale,omitempty"`

				// Mic Market Identifier Code (MIC) - ISO 10383 standard four-character code for the market (may be empty for some venues).
				Mic *string `json:"mic,omitempty"`

				// Name Full official name of the exchange, trading venue, or reporting facility.
				Name string `json:"name"`

				// OperatingMic Operating Market Identifier Code - identifies the specific operating entity or parent organization.
				OperatingMic *string `json:"operating_mic,omitempty"`

				// ParticipantId Single-character participant identifier used in market data feeds and trade reporting.
				ParticipantId *string `json:"participant_id,omitempty"`

				// Type Type of trading venue: 'exchange' for stock exchanges, 'TRF' for Trade Reporting Facilities, 'SIP' for Securities Information Processors, 'ORF' for OTC Reporting Facility.
				Type string `json:"type"`

				// Url Official website URL of the organization operating the venue.
				Url *string `json:"url,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksV1Exchanges200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksV1Exchanges400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksV1ShortInterestResponse parses an HTTP response from a GetStocksV1ShortInterestWithResponse call
func ParseGetStocksV1ShortInterestResponse(rsp *http.Response) (*GetStocksV1ShortInterestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksV1ShortInterestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AvgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
				AvgDailyVolume int64 `json:"avg_daily_volume"`

				// DaysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
				DaysToCover float64 `json:"days_to_cover"`

				// SettlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
				SettlementDate string `json:"settlement_date"`

				// ShortInterest The total number of shares that have been sold short but have not yet been covered or closed out.
				ShortInterest *int64 `json:"short_interest,omitempty"`

				// Ticker The primary ticker symbol for the stock.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksV1ShortInterest200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksV1ShortInterest400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksV1ShortVolumeResponse parses an HTTP response from a GetStocksV1ShortVolumeWithResponse call
func ParseGetStocksV1ShortVolumeResponse(rsp *http.Response) (*GetStocksV1ShortVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksV1ShortVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AdfShortVolume Short volume reported via the Alternative Display Facility (ADF), excluding exempt volume.
				AdfShortVolume *int64 `json:"adf_short_volume,omitempty"`

				// AdfShortVolumeExempt Short volume reported via ADF that was marked as exempt.
				AdfShortVolumeExempt *int64 `json:"adf_short_volume_exempt,omitempty"`

				// Date The date of trade activity reported in the format YYYY-MM-DD
				Date string `json:"date"`

				// ExemptVolume Portion of short volume that was marked as exempt from regulation SHO.
				ExemptVolume *int64 `json:"exempt_volume,omitempty"`

				// NasdaqCarteretShortVolume Short volume reported from Nasdaq's Carteret facility, excluding exempt volume.
				NasdaqCarteretShortVolume *int64 `json:"nasdaq_carteret_short_volume,omitempty"`

				// NasdaqCarteretShortVolumeExempt Short volume from Nasdaq Carteret that was marked as exempt.
				NasdaqCarteretShortVolumeExempt *int64 `json:"nasdaq_carteret_short_volume_exempt,omitempty"`

				// NasdaqChicagoShortVolume Short volume reported from Nasdaq's Chicago facility, excluding exempt volume.
				NasdaqChicagoShortVolume *int64 `json:"nasdaq_chicago_short_volume,omitempty"`

				// NasdaqChicagoShortVolumeExempt Short volume from Nasdaq Chicago that was marked as exempt.
				NasdaqChicagoShortVolumeExempt *int64 `json:"nasdaq_chicago_short_volume_exempt,omitempty"`

				// NonExemptVolume Portion of short volume that was not exempt from regulation SHO (i.e., short_volume - exempt_volume).
				NonExemptVolume *int64 `json:"non_exempt_volume,omitempty"`

				// NyseShortVolume Short volume reported from NYSE facilities, excluding exempt volume.
				NyseShortVolume *int64 `json:"nyse_short_volume,omitempty"`

				// NyseShortVolumeExempt Short volume from NYSE facilities that was marked as exempt.
				NyseShortVolumeExempt *int64 `json:"nyse_short_volume_exempt,omitempty"`

				// ShortVolume Total number of shares sold short across all venues for the ticker on the given date.
				ShortVolume *int64 `json:"short_volume,omitempty"`

				// ShortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
				ShortVolumeRatio *float32 `json:"short_volume_ratio,omitempty"`

				// Ticker The primary ticker symbol for the stock.
				Ticker *string `json:"ticker,omitempty"`

				// TotalVolume Total reported volume across all venues for the ticker on the given date.
				TotalVolume *int64 `json:"total_volume,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksV1ShortVolume200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksV1ShortVolume400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksV1SplitsResponse parses an HTTP response from a GetStocksV1SplitsWithResponse call
func ParseGetStocksV1SplitsResponse(rsp *http.Response) (*GetStocksV1SplitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksV1SplitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AdjustmentType Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
				AdjustmentType string `json:"adjustment_type"`

				// ExecutionDate Date when the stock split was applied and shares adjusted
				ExecutionDate *openapi_types.Date `json:"execution_date,omitempty"`

				// HistoricalAdjustmentFactor Cumulative adjustment factor used to offset split effects on historical prices. To adjust a historical price for splits: for a price on date D, find the first split whose `execution_date` is after date D and multiply the unadjusted price by the `historical_adjustment_factor`.
				HistoricalAdjustmentFactor *float64 `json:"historical_adjustment_factor,omitempty"`

				// Id Unique identifier for each stock split event
				Id *string `json:"id,omitempty"`

				// SplitFrom Denominator of the split ratio (old shares)
				SplitFrom *float64 `json:"split_from,omitempty"`

				// SplitTo Numerator of the split ratio (new shares)
				SplitTo *float64 `json:"split_to,omitempty"`

				// Ticker Stock symbol for the company that executed the split
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksV1Splits200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksV1Splits400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStocksVXFloatResponse parses an HTTP response from a GetStocksVXFloatWithResponse call
func ParseGetStocksVXFloatResponse(rsp *http.Response) (*GetStocksVXFloatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksVXFloatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// EffectiveDate The effective date of the free float measurement.
				EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

				// FreeFloat Number of shares freely tradable in the market. Free float shares represent the portion of a company's outstanding shares that is freely tradable in the market, excluding any holdings considered strategic, controlling, or long term. This excludes insiders, directors, founders, 5 percent plus shareholders, cross holdings, government stakes except pensions, restricted or locked up shares, employee plans, and any entities with board influence, leaving only shares that are genuinely available for public trading.
				FreeFloat *int64 `json:"free_float,omitempty"`

				// FreeFloatPercent Percentage of total shares outstanding that are available for public trading, rounded to two decimal places.
				FreeFloatPercent *float64 `json:"free_float_percent,omitempty"`

				// Ticker The primary ticker symbol for the stock.
				Ticker *string `json:"ticker,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetStocksVXFloat200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetStocksVXFloat400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetTmxV1CorporateEventsResponse parses an HTTP response from a GetTmxV1CorporateEventsWithResponse call
func ParseGetTmxV1CorporateEventsResponse(rsp *http.Response) (*GetTmxV1CorporateEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTmxV1CorporateEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// CompanyName Full name of the company.
				CompanyName *string `json:"company_name,omitempty"`

				// Date Scheduled date of the corporate event, formatted as YYYY-MM-DD.
				Date *string `json:"date,omitempty"`

				// Isin Standard international identifier for the company's common stock.
				Isin *string `json:"isin,omitempty"`

				// Name Name or title of the event.
				Name *string `json:"name,omitempty"`

				// Status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
				Status *string `json:"status,omitempty"`

				// Ticker The company's stock symbol.
				Ticker *string `json:"ticker,omitempty"`

				// TmxCompanyId Unique numeric identifier for the company used by TMX.
				TmxCompanyId *int64 `json:"tmx_company_id,omitempty"`

				// TmxRecordId The unique alphanumeric identifier for the event record used by TMX.
				TmxRecordId *string `json:"tmx_record_id,omitempty"`

				// TradingVenue MIC (Market Identifier Code) of the exchange where the company's stock is listed.
				TradingVenue *string `json:"trading_venue,omitempty"`

				// Type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
				Type *string `json:"type,omitempty"`

				// Url URL linking to the primary public source of the event announcement, if available.
				Url *string `json:"url,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetTmxV1CorporateEvents200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetTmxV1CorporateEvents400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetCurrencyConversionResponse parses an HTTP response from a GetCurrencyConversionWithResponse call
func ParseGetCurrencyConversionResponse(rsp *http.Response) (*GetCurrencyConversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrencyConversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Converted The result of the conversion.
			Converted float64 `json:"converted"`

			// From The "from" currency symbol.
			From string `json:"from"`

			// InitialAmount The amount to convert.
			InitialAmount float64 `json:"initialAmount"`

			// Last Contains the requested quote data for the specified forex currency pair.
			Last *struct {
				// Ask The ask price.
				Ask float64 `json:"ask"`

				// Bid The bid price.
				Bid float64 `json:"bid"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/forex/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// Timestamp The Unix millisecond timestamp.
				Timestamp int `json:"timestamp"`
			} `json:"last,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`

			// Symbol The symbol pair that was evaluated from the request.
			Symbol string `json:"symbol"`

			// To The "to" currency symbol.
			To string `json:"to"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseDeprecatedGetHistoricCryptoTradesResponse parses an HTTP response from a DeprecatedGetHistoricCryptoTradesWithResponse call
func ParseDeprecatedGetHistoricCryptoTradesResponse(rsp *http.Response) (*DeprecatedGetHistoricCryptoTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedGetHistoricCryptoTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			// Day The date that was evaluated from the request.
			Day openapi_types.Date `json:"day"`

			// Map A map for shortened result keys.
			Map map[string]interface{} `json:"map"`

			// MsLatency The milliseconds of latency for the query results.
			MsLatency int `json:"msLatency"`

			// Symbol The symbol pair that was evaluated from the request.
			Symbol string `json:"symbol"`
			Ticks  []struct {
				// C A list of condition codes.
				C []int `json:"c"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size of a trade (also known as volume).
				BidSize float64 `json:"s"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// X The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				BidExchange int `json:"x"`
			} `json:"ticks"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeprecatedGetHistoricForexQuotesResponse parses an HTTP response from a DeprecatedGetHistoricForexQuotesWithResponse call
func ParseDeprecatedGetHistoricForexQuotesResponse(rsp *http.Response) (*DeprecatedGetHistoricForexQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedGetHistoricForexQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Day The date that was evaluated from the request.
			Day openapi_types.Date `json:"day"`

			// Map A map for shortened result keys.
			Map map[string]interface{} `json:"map"`

			// MsLatency The milliseconds of latency for the query results.
			MsLatency int `json:"msLatency"`

			// Pair The currency pair that was evaluated from the request.
			Pair  string `json:"pair"`
			Ticks []struct {
				// A The ask price.
				A float64 `json:"a"`

				// B The bid price.
				B float64 `json:"b"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/forex/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`
			} `json:"ticks"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCryptoEMAResponse parses an HTTP response from a GetCryptoEMAWithResponse call
func ParseGetCryptoEMAResponse(rsp *http.Response) (*GetCryptoEMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoEMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the EMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexEMAResponse parses an HTTP response from a GetForexEMAWithResponse call
func ParseGetForexEMAResponse(rsp *http.Response) (*GetForexEMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexEMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the EMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetIndicesEMAResponse parses an HTTP response from a GetIndicesEMAWithResponse call
func ParseGetIndicesEMAResponse(rsp *http.Response) (*GetIndicesEMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesEMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the EMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionsEMAResponse parses an HTTP response from a GetOptionsEMAWithResponse call
func ParseGetOptionsEMAResponse(rsp *http.Response) (*GetOptionsEMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsEMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the EMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksEMAResponse parses an HTTP response from a GetStocksEMAWithResponse call
func ParseGetStocksEMAResponse(rsp *http.Response) (*GetStocksEMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksEMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the EMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoMACDResponse parses an HTTP response from a GetCryptoMACDWithResponse call
func ParseGetCryptoMACDResponse(rsp *http.Response) (*GetCryptoMACDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoMACDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the MACD indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
				Values *[]struct {
					// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
					Histogram *float32 `json:"histogram,omitempty"`

					// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
					Signal *float32 `json:"signal,omitempty"`

					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexMACDResponse parses an HTTP response from a GetForexMACDWithResponse call
func ParseGetForexMACDResponse(rsp *http.Response) (*GetForexMACDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexMACDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the MACD indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
				Values *[]struct {
					// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
					Histogram *float32 `json:"histogram,omitempty"`

					// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
					Signal *float32 `json:"signal,omitempty"`

					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetIndicesMACDResponse parses an HTTP response from a GetIndicesMACDWithResponse call
func ParseGetIndicesMACDResponse(rsp *http.Response) (*GetIndicesMACDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesMACDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the MACD indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
				Values *[]struct {
					// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
					Histogram *float32 `json:"histogram,omitempty"`

					// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
					Signal *float32 `json:"signal,omitempty"`

					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionsMACDResponse parses an HTTP response from a GetOptionsMACDWithResponse call
func ParseGetOptionsMACDResponse(rsp *http.Response) (*GetOptionsMACDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsMACDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the MACD indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
				Values *[]struct {
					// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
					Histogram *float32 `json:"histogram,omitempty"`

					// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
					Signal *float32 `json:"signal,omitempty"`

					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksMACDResponse parses an HTTP response from a GetStocksMACDWithResponse call
func ParseGetStocksMACDResponse(rsp *http.Response) (*GetStocksMACDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksMACDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the MACD indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
				Values *[]struct {
					// Histogram The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
					Histogram *float32 `json:"histogram,omitempty"`

					// Signal The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
					Signal *float32 `json:"signal,omitempty"`

					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoRSIResponse parses an HTTP response from a GetCryptoRSIWithResponse call
func ParseGetCryptoRSIResponse(rsp *http.Response) (*GetCryptoRSIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoRSIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the RSI indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexRSIResponse parses an HTTP response from a GetForexRSIWithResponse call
func ParseGetForexRSIResponse(rsp *http.Response) (*GetForexRSIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexRSIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the RSI indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetIndicesRSIResponse parses an HTTP response from a GetIndicesRSIWithResponse call
func ParseGetIndicesRSIResponse(rsp *http.Response) (*GetIndicesRSIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesRSIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the RSI indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionsRSIResponse parses an HTTP response from a GetOptionsRSIWithResponse call
func ParseGetOptionsRSIResponse(rsp *http.Response) (*GetOptionsRSIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsRSIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the RSI indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksRSIResponse parses an HTTP response from a GetStocksRSIWithResponse call
func ParseGetStocksRSIResponse(rsp *http.Response) (*GetStocksRSIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksRSIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the RSI indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoSMAResponse parses an HTTP response from a GetCryptoSMAWithResponse call
func ParseGetCryptoSMAResponse(rsp *http.Response) (*GetCryptoSMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoSMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the SMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexSMAResponse parses an HTTP response from a GetForexSMAWithResponse call
func ParseGetForexSMAResponse(rsp *http.Response) (*GetForexSMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexSMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the SMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetIndicesSMAResponse parses an HTTP response from a GetIndicesSMAWithResponse call
func ParseGetIndicesSMAResponse(rsp *http.Response) (*GetIndicesSMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesSMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the SMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionsSMAResponse parses an HTTP response from a GetOptionsSMAWithResponse call
func ParseGetOptionsSMAResponse(rsp *http.Response) (*GetOptionsSMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsSMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the SMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksSMAResponse parses an HTTP response from a GetStocksSMAWithResponse call
func ParseGetStocksSMAResponse(rsp *http.Response) (*GetStocksSMAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksSMAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results of the SMA indicator calculation.
			Results struct {
				// Underlying The underlying aggregates used.
				Underlying *struct {
					// Aggregates The array of aggregates used in the calculation of this indicator.
					Aggregates *[]struct {
						// C The close price for the symbol in the given time period.
						C float32 `json:"c"`

						// H The highest price for the symbol in the given time period.
						H float32 `json:"h"`

						// L The lowest price for the symbol in the given time period.
						L float32 `json:"l"`

						// N The number of transactions in the aggregate window.
						N int `json:"n"`

						// O The open price for the symbol in the given time period.
						O float32 `json:"o"`

						// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
						Otc *bool `json:"otc,omitempty"`

						// T The Unix Msec timestamp for the start of the aggregate window.
						Timestamp float32 `json:"t"`

						// V The trading volume of the symbol in the given time period.
						V float32 `json:"v"`

						// Vw The volume weighted average price.
						Vw float32 `json:"vw"`
					} `json:"aggregates,omitempty"`

					// Url The URL which can be used to request the underlying aggregates used in this request.
					Url *string `json:"url,omitempty"`
				} `json:"underlying,omitempty"`

				// Values Timestamp or indicator value.
				Values *[]struct {
					// Timestamp The Unix Msec timestamp from the last aggregate used in this calculation.
					Timestamp *int64 `json:"timestamp,omitempty"`

					// Value The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
					Value *float32 `json:"value,omitempty"`
				} `json:"values,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetLastCryptoTradeResponse parses an HTTP response from a GetLastCryptoTradeWithResponse call
func ParseGetLastCryptoTradeResponse(rsp *http.Response) (*GetLastCryptoTradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastCryptoTradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Last Contains the requested trade data for the specified cryptocurrency pair.
			Last *struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Exchange The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				Exchange int `json:"exchange"`

				// Price The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				Price float64 `json:"price"`

				// Size The size of a trade (also known as volume).
				Size float64 `json:"size"`

				// Timestamp The Unix millisecond timestamp.
				Timestamp int `json:"timestamp"`
			} `json:"last,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`

			// Symbol The symbol pair that was evaluated from the request.
			Symbol string `json:"symbol"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetLastCurrencyQuoteResponse parses an HTTP response from a GetLastCurrencyQuoteWithResponse call
func ParseGetLastCurrencyQuoteResponse(rsp *http.Response) (*GetLastCurrencyQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastCurrencyQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Last Contains the requested quote data for the specified forex currency pair.
			Last *struct {
				// Ask The ask price.
				Ask float64 `json:"ask"`

				// Bid The bid price.
				Bid float64 `json:"bid"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/forex/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// Timestamp The Unix millisecond timestamp.
				Timestamp int `json:"timestamp"`
			} `json:"last,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`

			// Symbol The symbol pair that was evaluated from the request.
			Symbol string `json:"symbol"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetMarketStatusResponse parses an HTTP response from a GetMarketStatusWithResponse call
func ParseGetMarketStatusResponse(rsp *http.Response) (*GetMarketStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AfterHours Whether or not the market is in post-market hours.
			AfterHours *bool `json:"afterHours,omitempty"`

			// Currencies Contains the status of various currency markets.
			Currencies *struct {
				// Crypto The status of the crypto market.
				Crypto *string `json:"crypto,omitempty"`

				// Fx The status of the forex market.
				Fx *string `json:"fx,omitempty"`
			} `json:"currencies,omitempty"`

			// EarlyHours Whether or not the market is in pre-market hours.
			EarlyHours *bool `json:"earlyHours,omitempty"`

			// Exchanges Contains the status of different US stock exchanges (e.g., Nasdaq, NYSE).
			Exchanges *struct {
				// Nasdaq The status of the Nasdaq market.
				Nasdaq *string `json:"nasdaq,omitempty"`

				// Nyse The status of the NYSE market.
				Nyse *string `json:"nyse,omitempty"`

				// Otc The status of the OTC market.
				Otc *string `json:"otc,omitempty"`
			} `json:"exchanges,omitempty"`

			// IndicesGroups Contains the status of various index groups (e.g., MSCI, FTSE Russell).
			IndicesGroups *struct {
				// Cccy The status of Cboe Streaming Market Indices Cryptocurrency ("CCCY") indices trading hours.
				Cccy *string `json:"cccy,omitempty"`

				// Cgi The status of Cboe Global Indices ("CGI") trading hours.
				Cgi *string `json:"cgi,omitempty"`

				// DowJones The status of Dow Jones indices trading hours
				DowJones *string `json:"dow_jones,omitempty"`

				// FtseRussell The status of Financial Times Stock Exchange Group ("FTSE") Russell indices trading hours.
				FtseRussell *string `json:"ftse_russell,omitempty"`

				// Msci The status of Morgan Stanley Capital International ("MSCI") indices trading hours.
				Msci *string `json:"msci,omitempty"`

				// Mstar The status of Morningstar ("MSTAR") indices trading hours.
				Mstar *string `json:"mstar,omitempty"`

				// Mstarc The status of Morningstar Customer ("MSTARC") indices trading hours.
				Mstarc *string `json:"mstarc,omitempty"`

				// Nasdaq The status of National Association of Securities Dealers Automated Quotations ("Nasdaq") indices trading hours.
				Nasdaq *string `json:"nasdaq,omitempty"`

				// SAndP The status of Standard & Poor's ("S&P") indices trading hours.
				SAndP *string `json:"s_and_p,omitempty"`

				// SocieteGenerale The status of Societe Generale indices trading hours.
				SocieteGenerale *string `json:"societe_generale,omitempty"`
			} `json:"indicesGroups,omitempty"`

			// Market The status of the market as a whole.
			Market *string `json:"market,omitempty"`

			// ServerTime The current time of the server, returned as a date-time in RFC3339 format.
			ServerTime *string `json:"serverTime,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMarketHolidaysResponse parses an HTTP response from a GetMarketHolidaysWithResponse call
func ParseGetMarketHolidaysResponse(rsp *http.Response) (*GetMarketHolidaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketHolidaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Close The market close time on the holiday (if it's not closed).
			Close *string `json:"close,omitempty"`

			// Date The date of the holiday.
			Date *string `json:"date,omitempty"`

			// Exchange Which market the record is for.
			Exchange *string `json:"exchange,omitempty"`

			// Name The name of the holiday.
			Name *string `json:"name,omitempty"`

			// Open The market open time on the holiday (if it's not closed).
			Open *string `json:"open,omitempty"`

			// Status The status of the market on the holiday.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCryptoOpenCloseResponse parses an HTTP response from a GetCryptoOpenCloseWithResponse call
func ParseGetCryptoOpenCloseResponse(rsp *http.Response) (*GetCryptoOpenCloseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoOpenCloseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Close The close price for the symbol in the given time period.
			Close float64 `json:"close"`

			// ClosingTrades An array of results containing the requested data.
			ClosingTrades []struct {
				// C A list of condition codes.
				C []int `json:"c"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size of a trade (also known as volume).
				BidSize float64 `json:"s"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// X The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				BidExchange int `json:"x"`
			} `json:"closingTrades"`

			// Day The date requested.
			Day openapi_types.Date `json:"day"`

			// IsUTC Whether or not the timestamps are in UTC timezone.
			IsUTC bool `json:"isUTC"`

			// Open The open price for the symbol in the given time period.
			Open float64 `json:"open"`

			// OpenTrades An array of results containing the requested data.
			OpenTrades []struct {
				// C A list of condition codes.
				C []int `json:"c"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// S The size of a trade (also known as volume).
				BidSize float64 `json:"s"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// X The exchange that this crypto trade happened on.
				// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
				BidExchange int `json:"x"`
			} `json:"openTrades"`

			// Symbol The symbol pair that was evaluated from the request.
			Symbol string `json:"symbol"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetIndicesOpenCloseResponse parses an HTTP response from a GetIndicesOpenCloseWithResponse call
func ParseGetIndicesOpenCloseResponse(rsp *http.Response) (*GetIndicesOpenCloseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesOpenCloseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AfterHours The close value of the ticker symbol in after hours trading.
			AfterHours *float64 `json:"afterHours,omitempty"`

			// Close The close value for the symbol in the given time period.
			Close float64 `json:"close"`

			// From The requested date.
			From openapi_types.Date `json:"from"`

			// High The highest value for the symbol in the given time period.
			High float64 `json:"high"`

			// Low The lowest value for the symbol in the given time period.
			Low float64 `json:"low"`

			// Open The open value for the symbol in the given time period.
			Open float64 `json:"open"`

			// PreMarket The open value of the ticker symbol in pre-market trading.
			PreMarket *int `json:"preMarket,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`

			// Symbol The exchange symbol that this item is traded under.
			Symbol string `json:"symbol"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetOptionsOpenCloseResponse parses an HTTP response from a GetOptionsOpenCloseWithResponse call
func ParseGetOptionsOpenCloseResponse(rsp *http.Response) (*GetOptionsOpenCloseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsOpenCloseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AfterHours The close price of the ticker symbol in after hours trading.
			AfterHours *float64 `json:"afterHours,omitempty"`

			// Close The close price for the symbol in the given time period.
			Close float64 `json:"close"`

			// From The requested date.
			From openapi_types.Date `json:"from"`

			// High The highest price for the symbol in the given time period.
			High float64 `json:"high"`

			// Low The lowest price for the symbol in the given time period.
			Low float64 `json:"low"`

			// Open The open price for the symbol in the given time period.
			Open float64 `json:"open"`

			// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
			Otc *bool `json:"otc,omitempty"`

			// PreMarket The open price of the ticker symbol in pre-market trading.
			PreMarket *int `json:"preMarket,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`

			// Symbol The exchange symbol that this item is traded under.
			Symbol string `json:"symbol"`

			// Volume The trading volume of the symbol in the given time period.
			Volume float64 `json:"volume"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksOpenCloseResponse parses an HTTP response from a GetStocksOpenCloseWithResponse call
func ParseGetStocksOpenCloseResponse(rsp *http.Response) (*GetStocksOpenCloseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksOpenCloseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AfterHours The close price of the ticker symbol in after hours trading.
			AfterHours *float64 `json:"afterHours,omitempty"`

			// Close The close price for the symbol in the given time period.
			Close float64 `json:"close"`

			// From The requested date.
			From openapi_types.Date `json:"from"`

			// High The highest price for the symbol in the given time period.
			High float64 `json:"high"`

			// Low The lowest price for the symbol in the given time period.
			Low float64 `json:"low"`

			// Open The open price for the symbol in the given time period.
			Open float64 `json:"open"`

			// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
			Otc *bool `json:"otc,omitempty"`

			// PreMarket The open price of the ticker symbol in pre-market trading.
			PreMarket *int `json:"preMarket,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`

			// Symbol The exchange symbol that this item is traded under.
			Symbol string `json:"symbol"`

			// Volume The trading volume of the symbol in the given time period.
			Volume float64 `json:"volume"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetV1ReferenceIposResponse parses an HTTP response from a GetV1ReferenceIposWithResponse call
func ParseGetV1ReferenceIposResponse(rsp *http.Response) (*GetV1ReferenceIposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV1ReferenceIposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results The results for this request.
			Results []struct {
				// AnnouncedDate The date when the IPO event was announced.
				AnnouncedDate *int64 `json:"announced_date,omitempty"`

				// CurrencyCode Underlying currency of the security.
				CurrencyCode *string `json:"currency_code,omitempty"`

				// FinalIssuePrice The price set by the company and its underwriters before the IPO goes live.
				FinalIssuePrice *float64 `json:"final_issue_price,omitempty"`

				// HighestOfferPrice The highest price within the IPO price range that the company might use to price the shares.
				HighestOfferPrice *float64 `json:"highest_offer_price,omitempty"`

				// IpoStatus The status of the IPO.
				IpoStatus *string `json:"ipo_status,omitempty"`

				// Isin International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
				Isin *string `json:"isin,omitempty"`

				// IssuerName Name of issuer.
				IssuerName *string `json:"issuer_name,omitempty"`

				// LastUpdated The date when the IPO event was last modified.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// ListingDate First trading date for the newly listed entity.
				ListingDate *int64 `json:"listing_date,omitempty"`

				// LotSize The minimum number of shares that an investor may apply for during an IPO.
				LotSize *int64 `json:"lot_size,omitempty"`

				// LowestOfferPrice The lowest price within the IPO price range that the company is willing to offer its shares to investors.
				LowestOfferPrice *float64 `json:"lowest_offer_price,omitempty"`

				// MaxSharesOffered The upper limit of the shares that the company is offering to investors.
				MaxSharesOffered *int64 `json:"max_shares_offered,omitempty"`

				// MinSharesOffered The lower limit of shares that the company is willing to sell in the IPO.
				MinSharesOffered *int64 `json:"min_shares_offered,omitempty"`

				// PrimaryExchange Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
				PrimaryExchange *string `json:"primary_exchange,omitempty"`

				// SecurityDescription A brief description of the security. e.g. Class A Shares
				SecurityDescription *string `json:"security_description,omitempty"`

				// SecurityType The classification of the stock. For example, CS stands for Common Stock.
				SecurityType *string `json:"security_type,omitempty"`

				// SharesOutstanding The total number of shares that the company has issued and are held by investors.
				SharesOutstanding *int64 `json:"shares_outstanding,omitempty"`

				// Ticker The ticker symbol of the IPO event.
				Ticker *string `json:"ticker,omitempty"`

				// TotalOfferSize The total amount raised by the company for IPO.
				TotalOfferSize *float64 `json:"total_offer_size,omitempty"`

				// UsCode Nine-character alphanumeric code that uniquely identifies a financial security in North America.
				UsCode *string `json:"us_code,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status GetV1ReferenceIpos200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error A message describing the source of the error.
			Error string `json:"error"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status GetV1ReferenceIpos400Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRelatedCompaniesResponse parses an HTTP response from a GetRelatedCompaniesWithResponse call
func ParseGetRelatedCompaniesResponse(rsp *http.Response) (*GetRelatedCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRelatedCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// Ticker A ticker related to the requested ticker.
				Ticker string `json:"ticker"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`

			// Ticker The ticker being queried.
			Ticker *string `json:"ticker,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSnapshotSummaryResponse parses an HTTP response from a GetSnapshotSummaryWithResponse call
func ParseGetSnapshotSummaryResponse(rsp *http.Response) (*GetSnapshotSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSnapshotSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				Branding *struct {
					// IconUrl A link to this ticker's company's icon. Icon's are generally smaller, square images that represent the company at a glance.
					// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
					IconUrl *string `json:"icon_url,omitempty"`

					// LogoUrl A link to this ticker's company's logo.
					// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
					LogoUrl *string `json:"logo_url,omitempty"`
				} `json:"branding,omitempty"`

				// Error The error while looking for this ticker.
				Error *string `json:"error,omitempty"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// MarketStatus The market status for the market that trades this ticker.
				MarketStatus *string `json:"market_status,omitempty"`

				// Message The error message while looking for this ticker.
				Message *string `json:"message,omitempty"`

				// Name Name of ticker, forex, or crypto asset.
				Name    *string `json:"name,omitempty"`
				Options *struct {
					// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
					ContractType GetSnapshotSummary200ResultsOptionsContractType `json:"contract_type"`

					// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
					ExerciseStyle GetSnapshotSummary200ResultsOptionsExerciseStyle `json:"exercise_style"`

					// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
					ExpirationDate openapi_types.Date `json:"expiration_date"`

					// SharesPerContract The number of shares per contract for this contract.
					SharesPerContract float64 `json:"shares_per_contract"`

					// StrikePrice The strike price of the option contract.
					StrikePrice float64 `json:"strike_price"`

					// UnderlyingTicker The ticker for the option contract.
					UnderlyingTicker string `json:"underlying_ticker"`
				} `json:"options,omitempty"`

				// Price The most up to date ticker price.
				Price *float64 `json:"price,omitempty"`

				// Session Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
				Session *struct {
					// Change The value of the price change for the asset from the previous trading day.
					Change float64 `json:"change"`

					// ChangePercent The percent of the price change for the asset from the previous trading day.
					ChangePercent float64 `json:"change_percent"`

					// Close The closing price of the asset for the day.
					Close float64 `json:"close"`

					// DecimalVolume The trading volume for the asset for the day with decimal precision. This field provides support for fractional shares, representing volume as a decimal string. This field is only returned for stocks snapshots.
					DecimalVolume *string `json:"decimal_volume,omitempty"`

					// EarlyTradingChange Today's early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
					EarlyTradingChange *float64 `json:"early_trading_change,omitempty"`

					// EarlyTradingChangePercent Today's early trading change as a percentage.
					EarlyTradingChangePercent *float64 `json:"early_trading_change_percent,omitempty"`

					// High The highest price of the asset for the day.
					High float64 `json:"high"`

					// LateTradingChange Today's late trading change amount, difference between price and today's close if in late trading hours, otherwise difference between last price during late trading and today's close.
					LateTradingChange *float64 `json:"late_trading_change,omitempty"`

					// LateTradingChangePercent Today's late trading change as a percentage.
					LateTradingChangePercent *float64 `json:"late_trading_change_percent,omitempty"`

					// Low The lowest price of the asset for the day.
					Low float64 `json:"low"`

					// Open The open price of the asset for the day.
					Open float64 `json:"open"`

					// PreviousClose The closing price of the asset for the previous trading day.
					PreviousClose float64 `json:"previous_close"`

					// Price The price of the most recent trade or bid price for this asset.
					Price *float64 `json:"price,omitempty"`

					// RegularTradingChange Today's change in regular trading hours, difference between current price and previous trading day's close, otherwise difference between today's close and previous day's close.
					RegularTradingChange *float64 `json:"regular_trading_change,omitempty"`

					// RegularTradingChangePercent Today's regular trading change as a percentage.
					RegularTradingChangePercent *float64 `json:"regular_trading_change_percent,omitempty"`

					// Volume The trading volume for the asset for the day.
					Volume *float64 `json:"volume,omitempty"`
				} `json:"session,omitempty"`

				// Ticker Ticker of asset queried.
				Ticker string `json:"ticker"`

				// Type The market for this ticker of stock, crypto, fx, option.
				Type *GetSnapshotSummary200ResultsType `json:"type,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGroupedCryptoAggregatesResponse parses an HTTP response from a GetGroupedCryptoAggregatesWithResponse call
func ParseGetGroupedCryptoAggregatesResponse(rsp *http.Response) (*GetGroupedCryptoAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupedCryptoAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the end of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetGroupedForexAggregatesResponse parses an HTTP response from a GetGroupedForexAggregatesWithResponse call
func ParseGetGroupedForexAggregatesResponse(rsp *http.Response) (*GetGroupedForexAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupedForexAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the end of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetGroupedStocksAggregatesResponse parses an HTTP response from a GetGroupedStocksAggregatesWithResponse call
func ParseGetGroupedStocksAggregatesResponse(rsp *http.Response) (*GetGroupedStocksAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupedStocksAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// T The Unix millisecond timestamp for the end of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetPreviousCryptoAggregatesResponse parses an HTTP response from a GetPreviousCryptoAggregatesWithResponse call
func ParseGetPreviousCryptoAggregatesResponse(rsp *http.Response) (*GetPreviousCryptoAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreviousCryptoAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the end of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoAggregatesResponse parses an HTTP response from a GetCryptoAggregatesWithResponse call
func ParseGetCryptoAggregatesResponse(rsp *http.Response) (*GetCryptoAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetPreviousForexAggregatesResponse parses an HTTP response from a GetPreviousForexAggregatesWithResponse call
func ParseGetPreviousForexAggregatesResponse(rsp *http.Response) (*GetPreviousForexAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreviousForexAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexAggregatesResponse parses an HTTP response from a GetForexAggregatesWithResponse call
func ParseGetForexAggregatesResponse(rsp *http.Response) (*GetForexAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetPreviousIndicesAggregatesResponse parses an HTTP response from a GetPreviousIndicesAggregatesWithResponse call
func ParseGetPreviousIndicesAggregatesResponse(rsp *http.Response) (*GetPreviousIndicesAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreviousIndicesAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close value for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest value for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest value for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open value for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetIndicesAggregatesResponse parses an HTTP response from a GetIndicesAggregatesWithResponse call
func ParseGetIndicesAggregatesResponse(rsp *http.Response) (*GetIndicesAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close value for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest value for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest value for the symbol in the given time period.
				L float64 `json:"l"`

				// O The open value for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetPreviousOptionsAggregatesResponse parses an HTTP response from a GetPreviousOptionsAggregatesWithResponse call
func ParseGetPreviousOptionsAggregatesResponse(rsp *http.Response) (*GetPreviousOptionsAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreviousOptionsAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetOptionsAggregatesResponse parses an HTTP response from a GetOptionsAggregatesWithResponse call
func ParseGetOptionsAggregatesResponse(rsp *http.Response) (*GetOptionsAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetPreviousStocksAggregatesResponse parses an HTTP response from a GetPreviousStocksAggregatesWithResponse call
func ParseGetPreviousStocksAggregatesResponse(rsp *http.Response) (*GetPreviousStocksAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreviousStocksAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksAggregatesResponse parses an HTTP response from a GetStocksAggregatesWithResponse call
func ParseGetStocksAggregatesResponse(rsp *http.Response) (*GetStocksAggregatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksAggregatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Ticker The exchange symbol that this item is traded under.
			Ticker string `json:"ticker"`
			// Embedded fields due to inline allOf schema
			// Adjusted Whether or not this response was adjusted for splits.
			Adjusted bool `json:"adjusted"`

			// QueryCount The number of aggregates (minute or day) used to generate the response.
			QueryCount int `json:"queryCount"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// ResultsCount The total number of results for this request.
			ResultsCount int `json:"resultsCount"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Results An array of results containing the requested data.
			Results *[]struct {
				// C The close price for the symbol in the given time period.
				C float64 `json:"c"`

				// H The highest price for the symbol in the given time period.
				H float64 `json:"h"`

				// L The lowest price for the symbol in the given time period.
				L float64 `json:"l"`

				// N The number of transactions in the aggregate window.
				N *int `json:"n,omitempty"`

				// O The open price for the symbol in the given time period.
				O float64 `json:"o"`

				// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
				Otc *bool `json:"otc,omitempty"`

				// T The Unix millisecond timestamp for the start of the aggregate window.
				Timestamp int `json:"t"`

				// V The trading volume of the symbol in the given time period.
				V float64 `json:"v"`

				// Vw The volume weighted average price.
				Vw *float64 `json:"vw,omitempty"`
			} `json:"results,omitempty"`
			// Embedded fields due to inline allOf schema
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetLastStocksQuoteResponse parses an HTTP response from a GetLastStocksQuoteWithResponse call
func ParseGetLastStocksQuoteResponse(rsp *http.Response) (*GetLastStocksQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastStocksQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`
			Results   *struct {
				// P The ask price.
				AskPrice *float64 `json:"P,omitempty"`

				// S The total number of shares available for sale at the current ask price.
				AskSize *int `json:"S,omitempty"`

				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				AskExchange *int `json:"X,omitempty"`

				// C A list of condition codes.
				C *[]int32 `json:"c,omitempty"`

				// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
				F *int `json:"f,omitempty"`

				// I A list of indicator codes.
				I *[]int32 `json:"i,omitempty"`

				// P The bid price.
				BidPrice *float64 `json:"p,omitempty"`

				// Q The sequence number represents the sequence in which message events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11).
				Q int64 `json:"q"`

				// S The total number of shares that buyers want to purchase at the current bid price.
				BidSize *int `json:"s,omitempty"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange *int `json:"x,omitempty"`

				// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				Y int `json:"y"`

				// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Z *int `json:"z,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetLastOptionsTradeResponse parses an HTTP response from a GetLastOptionsTradeWithResponse call
func ParseGetLastOptionsTradeResponse(rsp *http.Response) (*GetLastOptionsTradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastOptionsTradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`
			Results   *struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C A list of condition codes.
				C *[]int32 `json:"c,omitempty"`

				// E The trade correction indicator.
				E *int `json:"e,omitempty"`

				// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
				F *int `json:"f,omitempty"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// Q The sequence number represents the sequence in which message events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11).
				Q int64 `json:"q"`

				// R The ID for the Trade Reporting Facility where the trade took place.
				R *int `json:"r,omitempty"`

				// S The size of a trade (also known as volume).
				BidSize *float64 `json:"s,omitempty"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`

				// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				Y int `json:"y"`

				// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Z *int `json:"z,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetLastStocksTradeResponse parses an HTTP response from a GetLastStocksTradeWithResponse call
func ParseGetLastStocksTradeResponse(rsp *http.Response) (*GetLastStocksTradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastStocksTradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`
			Results   *struct {
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// C A list of condition codes.
				C *[]int32 `json:"c,omitempty"`

				// Ds The size of the trade including the fractional component. This is represented as a decimal string.
				Ds string `json:"ds"`

				// E The trade correction indicator.
				E *int `json:"e,omitempty"`

				// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
				F *int `json:"f,omitempty"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// Q The sequence number represents the sequence in which message events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11).
				Q int64 `json:"q"`

				// R The ID for the Trade Reporting Facility where the trade took place.
				R *int `json:"r,omitempty"`

				// S The size of a trade (also known as volume).
				BidSize *float64 `json:"s,omitempty"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`

				// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				Y int `json:"y"`

				// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Z *int `json:"z,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListNewsResponse parses an HTTP response from a ListNewsWithResponse call
func ParseListNewsResponse(rsp *http.Response) (*ListNewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AmpUrl The mobile friendly Accelerated Mobile Page (AMP) URL.
				AmpUrl *string `json:"amp_url,omitempty"`

				// ArticleUrl A link to the news article.
				ArticleUrl string `json:"article_url"`

				// Author The article's author.
				Author string `json:"author"`

				// Description A description of the article.
				Description *string `json:"description,omitempty"`

				// Id Unique identifier for the article.
				Id string `json:"id"`

				// ImageUrl The article's image URL.
				ImageUrl *string `json:"image_url,omitempty"`

				// Insights The insights related to the article.
				Insights *[]struct {
					// Sentiment The sentiment of the insight.
					Sentiment ListNews200ResultsInsightsSentiment `json:"sentiment"`

					// SentimentReasoning The reasoning behind the sentiment.
					SentimentReasoning string `json:"sentiment_reasoning"`

					// Ticker The ticker symbol associated with the insight.
					Ticker string `json:"ticker"`
				} `json:"insights,omitempty"`

				// Keywords The keywords associated with the article (which will vary depending on
				// the publishing source).
				Keywords *[]string `json:"keywords,omitempty"`

				// PublishedUtc The UTC date and time when the article was published, formatted in RFC3339 standard (e.g. YYYY-MM-DDTHH:MM:SSZ).
				PublishedUtc time.Time `json:"published_utc"`

				// Publisher Details the source of the news article, including the publisher's name, logo, and homepage URLs. This information helps users identify and access the original source of news content.
				Publisher struct {
					// FaviconUrl The publisher's homepage favicon URL.
					FaviconUrl *string `json:"favicon_url,omitempty"`

					// HomepageUrl The publisher's homepage URL.
					HomepageUrl string `json:"homepage_url"`

					// LogoUrl The publisher's logo URL.
					LogoUrl string `json:"logo_url"`

					// Name The publisher's name.
					Name string `json:"name"`
				} `json:"publisher"`

				// Tickers The ticker symbols associated with the article.
				Tickers []string `json:"tickers"`

				// Title The title of the news article.
				Title string `json:"title"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoSnapshotTickersResponse parses an HTTP response from a GetCryptoSnapshotTickersWithResponse call
func ParseGetCryptoSnapshotTickersResponse(rsp *http.Response) (*GetCryptoSnapshotTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoSnapshotTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Tickers An array of snapshot data for the specified tickers.
			Tickers *[]struct {
				// Day The most recent daily bar for this ticker.
				Day struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"day"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastTrade The most recent trade for this ticker.
				LastTrade struct {
					// C The trade conditions.
					C []int `json:"c"`

					// I The Trade ID which uniquely identifies a trade. These are unique per
					// combination of ticker, exchange, and TRF. For example: A trade for AAPL
					// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
					// have the same Trade ID.
					I string `json:"i"`

					// P The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					BidPrice float64 `json:"p"`

					// S The size (volume) of the trade.
					BidSize float32 `json:"s"`

					// T The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
					Timestamp int `json:"t"`

					// X The exchange that this crypto trade happened on.
					// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
					BidExchange int `json:"x"`
				} `json:"lastTrade"`

				// Min The most recent minute bar for this ticker.
				Min struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp int `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"min"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange float64 `json:"todaysChange"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc float64 `json:"todaysChangePerc"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"tickers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoSnapshotTickerResponse parses an HTTP response from a GetCryptoSnapshotTickerWithResponse call
func ParseGetCryptoSnapshotTickerResponse(rsp *http.Response) (*GetCryptoSnapshotTickerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoSnapshotTickerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`
			// Embedded fields due to inline allOf schema
			// Ticker Contains the requested snapshot data for the specified ticker.
			Ticker *struct {
				// Day The most recent daily bar for this ticker.
				Day struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"day"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastTrade The most recent trade for this ticker.
				LastTrade struct {
					// C The trade conditions.
					C []int `json:"c"`

					// I The Trade ID which uniquely identifies a trade. These are unique per
					// combination of ticker, exchange, and TRF. For example: A trade for AAPL
					// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
					// have the same Trade ID.
					I string `json:"i"`

					// P The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					BidPrice float64 `json:"p"`

					// S The size (volume) of the trade.
					BidSize float32 `json:"s"`

					// T The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
					Timestamp int `json:"t"`

					// X The exchange that this crypto trade happened on.
					// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
					BidExchange int `json:"x"`
				} `json:"lastTrade"`

				// Min The most recent minute bar for this ticker.
				Min struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp int `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"min"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange float64 `json:"todaysChange"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc float64 `json:"todaysChangePerc"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"ticker,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseDeprecatedGetCryptoSnapshotTickerBookResponse parses an HTTP response from a DeprecatedGetCryptoSnapshotTickerBookWithResponse call
func ParseDeprecatedGetCryptoSnapshotTickerBookResponse(rsp *http.Response) (*DeprecatedGetCryptoSnapshotTickerBookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedGetCryptoSnapshotTickerBookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			Data *struct {
				// AskCount The combined total number of asks in the book.
				AskCount float64 `json:"askCount"`
				Asks     []struct {
					// P The price of this book level.
					BidPrice float64 `json:"p"`

					// X A map of the exchange ID to number of shares at this price level.
					// <br />
					// <br />
					// **Example:**
					// <br />
					// `{
					//   "p": 16302.94,
					//   "x": {
					//     "1": 0.02859424,
					//     "6": 0.023455
					//   }
					// }`
					// <br />
					// <br />
					// In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94,
					// and exchange ID 6 has 0.023455 shares at the same price level.
					BidExchange map[string]interface{} `json:"x"`
				} `json:"asks"`

				// BidCount The combined total number of bids in the book.
				BidCount float64 `json:"bidCount"`
				Bids     []struct {
					// P The price of this book level.
					BidPrice float64 `json:"p"`

					// X A map of the exchange ID to number of shares at this price level.
					// <br />
					// <br />
					// **Example:**
					// <br />
					// `{
					//   "p": 16302.94,
					//   "x": {
					//     "1": 0.02859424,
					//     "6": 0.023455
					//   }
					// }`
					// <br />
					// <br />
					// In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94,
					// and exchange ID 6 has 0.023455 shares at the same price level.
					BidExchange map[string]interface{} `json:"x"`
				} `json:"bids"`

				// Spread The difference between the best bid and the best ask price across exchanges.
				Spread float64 `json:"spread"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoSnapshotDirectionResponse parses an HTTP response from a GetCryptoSnapshotDirectionWithResponse call
func ParseGetCryptoSnapshotDirectionResponse(rsp *http.Response) (*GetCryptoSnapshotDirectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoSnapshotDirectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			// Tickers An array of snapshot data for the specified tickers.
			Tickers *[]struct {
				// Day The most recent daily bar for this ticker.
				Day struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"day"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastTrade The most recent trade for this ticker.
				LastTrade struct {
					// C The trade conditions.
					C []int `json:"c"`

					// I The Trade ID which uniquely identifies a trade. These are unique per
					// combination of ticker, exchange, and TRF. For example: A trade for AAPL
					// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
					// have the same Trade ID.
					I string `json:"i"`

					// P The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					BidPrice float64 `json:"p"`

					// S The size (volume) of the trade.
					BidSize float32 `json:"s"`

					// T The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
					Timestamp int `json:"t"`

					// X The exchange that this crypto trade happened on.
					// See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges">Exchanges</a> for a mapping of exchanges to IDs.
					BidExchange int `json:"x"`
				} `json:"lastTrade"`

				// Min The most recent minute bar for this ticker.
				Min struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp int `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"min"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange float64 `json:"todaysChange"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc float64 `json:"todaysChangePerc"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"tickers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexSnapshotTickersResponse parses an HTTP response from a GetForexSnapshotTickersWithResponse call
func ParseGetForexSnapshotTickersResponse(rsp *http.Response) (*GetForexSnapshotTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexSnapshotTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Tickers An array of snapshot data for the specified tickers.
			Tickers *[]struct {
				// Day The most recent daily bar for this ticker.
				Day struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`
				} `json:"day"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastQuote The most recent quote for this ticker.
				LastQuote struct {
					// A The ask price.
					A float64 `json:"a"`

					// B The bid price.
					B float64 `json:"b"`

					// T The millisecond accuracy timestamp of the quote.
					Timestamp int `json:"t"`

					// X The exchange ID on which this quote happened.
					BidExchange int `json:"x"`
				} `json:"lastQuote"`

				// Min The most recent minute bar for this ticker.
				Min struct {
					// C The close price for the symbol in the given time period.
					C *float64 `json:"c,omitempty"`

					// H The highest price for the symbol in the given time period.
					H *float64 `json:"h,omitempty"`

					// L The lowest price for the symbol in the given time period.
					L *float64 `json:"l,omitempty"`

					// N The number of transactions in the aggregate window.
					N *int `json:"n,omitempty"`

					// O The open price for the symbol in the given time period.
					O *float64 `json:"o,omitempty"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp *int `json:"t,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V *float64 `json:"v,omitempty"`
				} `json:"min"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange float64 `json:"todaysChange"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc float64 `json:"todaysChangePerc"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"tickers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexSnapshotTickerResponse parses an HTTP response from a GetForexSnapshotTickerWithResponse call
func ParseGetForexSnapshotTickerResponse(rsp *http.Response) (*GetForexSnapshotTickerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexSnapshotTickerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`
			// Embedded fields due to inline allOf schema
			// Ticker Contains the requested snapshot data for the specified ticker.
			Ticker *struct {
				// Day The most recent daily bar for this ticker.
				Day struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`
				} `json:"day"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastQuote The most recent quote for this ticker.
				LastQuote struct {
					// A The ask price.
					A float64 `json:"a"`

					// B The bid price.
					B float64 `json:"b"`

					// T The millisecond accuracy timestamp of the quote.
					Timestamp int `json:"t"`

					// X The exchange ID on which this quote happened.
					BidExchange int `json:"x"`
				} `json:"lastQuote"`

				// Min The most recent minute bar for this ticker.
				Min struct {
					// C The close price for the symbol in the given time period.
					C *float64 `json:"c,omitempty"`

					// H The highest price for the symbol in the given time period.
					H *float64 `json:"h,omitempty"`

					// L The lowest price for the symbol in the given time period.
					L *float64 `json:"l,omitempty"`

					// N The number of transactions in the aggregate window.
					N *int `json:"n,omitempty"`

					// O The open price for the symbol in the given time period.
					O *float64 `json:"o,omitempty"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp *int `json:"t,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V *float64 `json:"v,omitempty"`
				} `json:"min"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange float64 `json:"todaysChange"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc float64 `json:"todaysChangePerc"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"ticker,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForexSnapshotDirectionResponse parses an HTTP response from a GetForexSnapshotDirectionWithResponse call
func ParseGetForexSnapshotDirectionResponse(rsp *http.Response) (*GetForexSnapshotDirectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexSnapshotDirectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Tickers An array of snapshot data for the specified tickers.
			Tickers *[]struct {
				// Day The most recent daily bar for this ticker.
				Day struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`
				} `json:"day"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastQuote The most recent quote for this ticker.
				LastQuote struct {
					// A The ask price.
					A float64 `json:"a"`

					// B The bid price.
					B float64 `json:"b"`

					// T The millisecond accuracy timestamp of the quote.
					Timestamp int `json:"t"`

					// X The exchange ID on which this quote happened.
					BidExchange int `json:"x"`
				} `json:"lastQuote"`

				// Min The most recent minute bar for this ticker.
				Min struct {
					// C The close price for the symbol in the given time period.
					C *float64 `json:"c,omitempty"`

					// H The highest price for the symbol in the given time period.
					H *float64 `json:"h,omitempty"`

					// L The lowest price for the symbol in the given time period.
					L *float64 `json:"l,omitempty"`

					// N The number of transactions in the aggregate window.
					N *int `json:"n,omitempty"`

					// O The open price for the symbol in the given time period.
					O *float64 `json:"o,omitempty"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp *int `json:"t,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V *float64 `json:"v,omitempty"`
				} `json:"min"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange float64 `json:"todaysChange"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc float64 `json:"todaysChangePerc"`

				// Updated The last updated timestamp.
				Updated int `json:"updated"`
			} `json:"tickers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksSnapshotTickersResponse parses an HTTP response from a GetStocksSnapshotTickersWithResponse call
func ParseGetStocksSnapshotTickersResponse(rsp *http.Response) (*GetStocksSnapshotTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksSnapshotTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Tickers An array of snapshot data for the specified tickers.
			Tickers *[]struct {
				// Day The most recent daily bar for this ticker.
				Day *struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// Dv The volume including fractional shares, respresented as a string.
					Dv *string `json:"dv,omitempty"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"day,omitempty"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastQuote The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
				LastQuote *struct {
					// P The ask price.
					AskPrice float64 `json:"P"`

					// S The ask size in lots.
					AskSize int `json:"S"`

					// P The bid price.
					BidPrice float64 `json:"p"`

					// S The bid size in lots.
					BidSize int `json:"s"`

					// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
					Timestamp int `json:"t"`
				} `json:"lastQuote,omitempty"`

				// LastTrade The most recent trade for this ticker.  This is only returned if your current plan includes trades.
				LastTrade *struct {
					// C The trade conditions.
					C []int `json:"c"`

					// Ds The size of the trade including fractional shares, respresented as a string.
					Ds string `json:"ds"`

					// I The Trade ID which uniquely identifies a trade. These are unique per
					// combination of ticker, exchange, and TRF. For example: A trade for AAPL
					// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
					// have the same Trade ID.
					I string `json:"i"`

					// P The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					BidPrice float64 `json:"p"`

					// S The size (volume) of the trade.
					BidSize int `json:"s"`

					// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
					Timestamp int `json:"t"`

					// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					BidExchange int `json:"x"`
				} `json:"lastTrade,omitempty"`

				// Min The most recent minute bar for this ticker.
				Min *struct {
					// Av The accumulated volume.
					Av int `json:"av"`

					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// Dav The accumulated volume including fractional shares, respresented as a string.
					Dav string `json:"dav"`

					// Dv The volume including fractional shares, respresented as a string.
					Dv *string `json:"dv,omitempty"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp int `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"min,omitempty"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay *struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay,omitempty"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker *string `json:"ticker,omitempty"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange *float64 `json:"todaysChange,omitempty"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc *float64 `json:"todaysChangePerc,omitempty"`

				// Updated The last updated timestamp.
				Updated *int `json:"updated,omitempty"`
			} `json:"tickers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksSnapshotTickerResponse parses an HTTP response from a GetStocksSnapshotTickerWithResponse call
func ParseGetStocksSnapshotTickerResponse(rsp *http.Response) (*GetStocksSnapshotTickerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksSnapshotTickerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`
			// Embedded fields due to inline allOf schema
			// Ticker Contains the requested snapshot data for the specified ticker.
			Ticker *struct {
				// Day The most recent daily bar for this ticker.
				Day *struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// Dv The volume including fractional shares, respresented as a string.
					Dv *string `json:"dv,omitempty"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"day,omitempty"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastQuote The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
				LastQuote *struct {
					// P The ask price.
					AskPrice float64 `json:"P"`

					// S The ask size in lots.
					AskSize int `json:"S"`

					// P The bid price.
					BidPrice float64 `json:"p"`

					// S The bid size in lots.
					BidSize int `json:"s"`

					// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
					Timestamp int `json:"t"`
				} `json:"lastQuote,omitempty"`

				// LastTrade The most recent trade for this ticker.  This is only returned if your current plan includes trades.
				LastTrade *struct {
					// C The trade conditions.
					C []int `json:"c"`

					// Ds The size of the trade including fractional shares, respresented as a string.
					Ds string `json:"ds"`

					// I The Trade ID which uniquely identifies a trade. These are unique per
					// combination of ticker, exchange, and TRF. For example: A trade for AAPL
					// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
					// have the same Trade ID.
					I string `json:"i"`

					// P The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					BidPrice float64 `json:"p"`

					// S The size (volume) of the trade.
					BidSize int `json:"s"`

					// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
					Timestamp int `json:"t"`

					// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					BidExchange int `json:"x"`
				} `json:"lastTrade,omitempty"`

				// Min The most recent minute bar for this ticker.
				Min *struct {
					// Av The accumulated volume.
					Av int `json:"av"`

					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// Dav The accumulated volume including fractional shares, respresented as a string.
					Dav string `json:"dav"`

					// Dv The volume including fractional shares, respresented as a string.
					Dv *string `json:"dv,omitempty"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp int `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"min,omitempty"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay *struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay,omitempty"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker *string `json:"ticker,omitempty"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange *float64 `json:"todaysChange,omitempty"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc *float64 `json:"todaysChangePerc,omitempty"`

				// Updated The last updated timestamp.
				Updated *int `json:"updated,omitempty"`
			} `json:"ticker,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksSnapshotDirectionResponse parses an HTTP response from a GetStocksSnapshotDirectionWithResponse call
func ParseGetStocksSnapshotDirectionResponse(rsp *http.Response) (*GetStocksSnapshotDirectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksSnapshotDirectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// Status The status of this request's response.
			Status string `json:"status"`
			// Embedded fields due to inline allOf schema
			// Tickers An array of snapshot data for the specified tickers.
			Tickers *[]struct {
				// Day The most recent daily bar for this ticker.
				Day *struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// Dv The volume including fractional shares, respresented as a string.
					Dv *string `json:"dv,omitempty"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"day,omitempty"`

				// Fmv Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float64 `json:"fmv,omitempty"`

				// LastQuote The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
				LastQuote *struct {
					// P The ask price.
					AskPrice float64 `json:"P"`

					// S The ask size in lots.
					AskSize int `json:"S"`

					// P The bid price.
					BidPrice float64 `json:"p"`

					// S The bid size in lots.
					BidSize int `json:"s"`

					// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
					Timestamp int `json:"t"`
				} `json:"lastQuote,omitempty"`

				// LastTrade The most recent trade for this ticker.  This is only returned if your current plan includes trades.
				LastTrade *struct {
					// C The trade conditions.
					C []int `json:"c"`

					// Ds The size of the trade including fractional shares, respresented as a string.
					Ds string `json:"ds"`

					// I The Trade ID which uniquely identifies a trade. These are unique per
					// combination of ticker, exchange, and TRF. For example: A trade for AAPL
					// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
					// have the same Trade ID.
					I string `json:"i"`

					// P The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					BidPrice float64 `json:"p"`

					// S The size (volume) of the trade.
					BidSize int `json:"s"`

					// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
					Timestamp int `json:"t"`

					// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					BidExchange int `json:"x"`
				} `json:"lastTrade,omitempty"`

				// Min The most recent minute bar for this ticker.
				Min *struct {
					// Av The accumulated volume.
					Av int `json:"av"`

					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// Dav The accumulated volume including fractional shares, respresented as a string.
					Dav string `json:"dav"`

					// Dv The volume including fractional shares, respresented as a string.
					Dv *string `json:"dv,omitempty"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// N The number of transactions in the aggregate window.
					N int `json:"n"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// T The Unix millisecond timestamp for the start of the aggregate window.
					Timestamp int `json:"t"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"min,omitempty"`

				// PrevDay The previous day's bar for this ticker.
				PrevDay *struct {
					// C The close price for the symbol in the given time period.
					C float64 `json:"c"`

					// H The highest price for the symbol in the given time period.
					H float64 `json:"h"`

					// L The lowest price for the symbol in the given time period.
					L float64 `json:"l"`

					// O The open price for the symbol in the given time period.
					O float64 `json:"o"`

					// Otc Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
					Otc *bool `json:"otc,omitempty"`

					// V The trading volume of the symbol in the given time period.
					V float64 `json:"v"`

					// Vw The volume weighted average price.
					Vw float64 `json:"vw"`
				} `json:"prevDay,omitempty"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker *string `json:"ticker,omitempty"`

				// TodaysChange The value of the change from the previous day.
				TodaysChange *float64 `json:"todaysChange,omitempty"`

				// TodaysChangePerc The percentage change since the previous day.
				TodaysChangePerc *float64 `json:"todaysChangePerc,omitempty"`

				// Updated The last updated timestamp.
				Updated *int `json:"updated,omitempty"`
			} `json:"tickers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseDeprecatedGetHistoricStocksQuotesResponse parses an HTTP response from a DeprecatedGetHistoricStocksQuotesWithResponse call
func ParseDeprecatedGetHistoricStocksQuotesResponse(rsp *http.Response) (*DeprecatedGetHistoricStocksQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedGetHistoricStocksQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// DbLatency Latency in milliseconds for the query results from the database.
			DbLatency *int `json:"db_latency,omitempty"`

			// ResultsCount The total number of results for this request.
			ResultsCount *int `json:"results_count,omitempty"`

			// Success Whether or not this query was executed successfully.
			Success *bool `json:"success,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker *string `json:"ticker,omitempty"`
			// Embedded fields due to inline allOf schema
			Results *[]struct {
				// Embedded fields due to inline allOf schema
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
				F int `json:"f"`

				// Q The sequence number represents the sequence in which message events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11).
				Q int64 `json:"q"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				Y int `json:"y"`
				// Embedded fields due to inline allOf schema
				// P The ask price.
				AskPrice float64 `json:"P"`

				// S The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
				AskSize int `json:"S"`

				// X The ask exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				AskExchange int `json:"X"`

				// C A list of condition codes.
				C []int `json:"c"`

				// I The indicators. For more information, see our glossary of [Conditions and
				// Indicators](https://massive.com/glossary/conditions-indicators).
				I []int `json:"i"`

				// P The bid price.
				BidPrice float64 `json:"p"`

				// S The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
				BidSize int `json:"s"`

				// X The bid exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`

				// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Z int `json:"z"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeprecatedGetHistoricStocksTradesResponse parses an HTTP response from a DeprecatedGetHistoricStocksTradesWithResponse call
func ParseDeprecatedGetHistoricStocksTradesResponse(rsp *http.Response) (*DeprecatedGetHistoricStocksTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedGetHistoricStocksTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema
			// DbLatency Latency in milliseconds for the query results from the database.
			DbLatency *int `json:"db_latency,omitempty"`

			// ResultsCount The total number of results for this request.
			ResultsCount *int `json:"results_count,omitempty"`

			// Success Whether or not this query was executed successfully.
			Success *bool `json:"success,omitempty"`

			// Ticker The exchange symbol that this item is traded under.
			Ticker *string `json:"ticker,omitempty"`
			// Embedded fields due to inline allOf schema
			Results *[]struct {
				// Embedded fields due to inline allOf schema
				// T The exchange symbol that this item is traded under.
				Ticker string `json:"T"`

				// F The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
				F int `json:"f"`

				// Q The sequence number represents the sequence in which message events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11).
				Q int64 `json:"q"`

				// T The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
				Timestamp int `json:"t"`

				// Y The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				Y int `json:"y"`
				// Embedded fields due to inline allOf schema
				// C A list of condition codes.
				C []int `json:"c"`

				// E The trade correction indicator.
				E int `json:"e"`

				// I The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				I string `json:"i"`

				// P The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				BidPrice float64 `json:"p"`

				// R The ID for the Trade Reporting Facility where the trade took place.
				R int `json:"r"`

				// S The size of a trade (also known as volume).
				BidSize float64 `json:"s"`

				// X The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				BidExchange int `json:"x"`

				// Z There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Z int `json:"z"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetForexQuotesResponse parses an HTTP response from a GetForexQuotesWithResponse call
func ParseGetForexQuotesResponse(rsp *http.Response) (*GetForexQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForexQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AskExchange The ask exchange ID
				AskExchange *int `json:"ask_exchange,omitempty"`

				// AskPrice The ask price.
				AskPrice *float64 `json:"ask_price,omitempty"`

				// BidExchange The bid exchange ID
				BidExchange *int `json:"bid_exchange,omitempty"`

				// BidPrice The bid price.
				BidPrice *float64 `json:"bid_price,omitempty"`

				// ParticipantTimestamp The nanosecond Exchange Unix Timestamp. This is the timestamp of when the quote was generated at the exchange.
				ParticipantTimestamp int64 `json:"participant_timestamp"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetOptionsQuotesResponse parses an HTTP response from a GetOptionsQuotesWithResponse call
func ParseGetOptionsQuotesResponse(rsp *http.Response) (*GetOptionsQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AskExchange The ask exchange ID
				AskExchange *int `json:"ask_exchange,omitempty"`

				// AskPrice The ask price.
				AskPrice *float64 `json:"ask_price,omitempty"`

				// AskSize The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
				AskSize *float64 `json:"ask_size,omitempty"`

				// BidExchange The bid exchange ID
				BidExchange *int `json:"bid_exchange,omitempty"`

				// BidPrice The bid price.
				BidPrice *float64 `json:"bid_price,omitempty"`

				// BidSize The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
				BidSize *float64 `json:"bid_size,omitempty"`

				// SequenceNumber The sequence number represents the sequence in which quote events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11).
				SequenceNumber int64 `json:"sequence_number"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
				SipTimestamp int64 `json:"sip_timestamp"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksQuotesResponse parses an HTTP response from a GetStocksQuotesWithResponse call
func ParseGetStocksQuotesResponse(rsp *http.Response) (*GetStocksQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AskExchange The ask exchange ID
				AskExchange *int `json:"ask_exchange,omitempty"`

				// AskPrice The ask price.
				AskPrice *float64 `json:"ask_price,omitempty"`

				// AskSize The total number of shares available for sale at the current ask price.
				AskSize *float64 `json:"ask_size,omitempty"`

				// BidExchange The bid exchange ID
				BidExchange *int `json:"bid_exchange,omitempty"`

				// BidPrice The bid price.
				BidPrice *float64 `json:"bid_price,omitempty"`

				// BidSize The total number of shares that buyers want to purchase at the current bid price.
				BidSize *float64 `json:"bid_size,omitempty"`

				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Indicators A list of indicator codes.
				Indicators *[]int32 `json:"indicators,omitempty"`

				// ParticipantTimestamp The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
				ParticipantTimestamp int64 `json:"participant_timestamp"`

				// SequenceNumber The sequence number represents the sequence in which quote events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
				SequenceNumber int64 `json:"sequence_number"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
				SipTimestamp int64 `json:"sip_timestamp"`

				// Tape There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Tape *int32 `json:"tape,omitempty"`

				// TrfTimestamp The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
				TrfTimestamp *int64 `json:"trf_timestamp,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListConditionsResponse parses an HTTP response from a ListConditionsWithResponse call
func ParseListConditionsResponse(rsp *http.Response) (*ListConditionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count int `json:"count"`

			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of conditions that match your query.
			Results []struct {
				// Abbreviation A commonly-used abbreviation for this condition.
				Abbreviation *string `json:"abbreviation,omitempty"`

				// AssetClass An identifier for a group of similar financial instruments.
				AssetClass ListConditions200ResultsAssetClass `json:"asset_class"`

				// DataTypes Data types that this condition applies to.
				DataTypes []ListConditions200ResultsDataTypes `json:"data_types"`

				// Description A short description of the semantics of this condition.
				Description *string `json:"description,omitempty"`

				// Exchange If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute.
				// In other words, data with this condition attached comes exclusively from the given exchange.
				Exchange *int `json:"exchange,omitempty"`

				// Id An identifier used by Massive for this condition. Unique per data type.
				Id int `json:"id"`

				// Legacy If true, this condition is from an old version of the SIPs' specs and no longer is used.
				// Other conditions may or may not reuse the same symbol as this one.
				Legacy *bool `json:"legacy,omitempty"`

				// Name The name of this condition.
				Name string `json:"name"`

				// SipMapping A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
				SipMapping struct {
					// CTA Condition code from the Consolidated Tape Association (CTA).
					CTA *string `json:"CTA,omitempty"`

					// OPRA Condition code from the Options Price Reporting Authority (OPRA).
					OPRA *string `json:"OPRA,omitempty"`

					// UTP Condition code from UTP Plan (UTP).
					UTP *string `json:"UTP,omitempty"`
				} `json:"sip_mapping"`

				// Type An identifier for a collection of related conditions.
				Type ListConditions200ResultsType `json:"type"`

				// UpdateRules A list of aggregation rules.
				UpdateRules *struct {
					// Consolidated Describes aggregation rules on a consolidated (all exchanges) basis.
					Consolidated struct {
						// UpdatesHighLow Whether or not trades with this condition update the high/low.
						UpdatesHighLow bool `json:"updates_high_low"`

						// UpdatesOpenClose Whether or not trades with this condition update the open/close.
						UpdatesOpenClose bool `json:"updates_open_close"`

						// UpdatesVolume Whether or not trades with this condition update the volume.
						UpdatesVolume bool `json:"updates_volume"`
					} `json:"consolidated"`

					// MarketCenter Describes aggregation rules on a per-market-center basis.
					MarketCenter struct {
						// UpdatesHighLow Whether or not trades with this condition update the high/low.
						UpdatesHighLow bool `json:"updates_high_low"`

						// UpdatesOpenClose Whether or not trades with this condition update the open/close.
						UpdatesOpenClose bool `json:"updates_open_close"`

						// UpdatesVolume Whether or not trades with this condition update the volume.
						UpdatesVolume bool `json:"updates_volume"`
					} `json:"market_center"`
				} `json:"update_rules,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Count The total number of results for this request.
			Count int `json:"count"`

			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of conditions that match your query.
			Results []struct {
				// Abbreviation A commonly-used abbreviation for this condition.
				Abbreviation *string `json:"abbreviation,omitempty"`

				// AssetClass An identifier for a group of similar financial instruments.
				AssetClass ListConditions400ResultsAssetClass `json:"asset_class"`

				// DataTypes Data types that this condition applies to.
				DataTypes []ListConditions400ResultsDataTypes `json:"data_types"`

				// Description A short description of the semantics of this condition.
				Description *string `json:"description,omitempty"`

				// Exchange If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute.
				// In other words, data with this condition attached comes exclusively from the given exchange.
				Exchange *int `json:"exchange,omitempty"`

				// Id An identifier used by Massive for this condition. Unique per data type.
				Id int `json:"id"`

				// Legacy If true, this condition is from an old version of the SIPs' specs and no longer is used.
				// Other conditions may or may not reuse the same symbol as this one.
				Legacy *bool `json:"legacy,omitempty"`

				// Name The name of this condition.
				Name string `json:"name"`

				// SipMapping A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
				SipMapping struct {
					// CTA Condition code from the Consolidated Tape Association (CTA).
					CTA *string `json:"CTA,omitempty"`

					// OPRA Condition code from the Options Price Reporting Authority (OPRA).
					OPRA *string `json:"OPRA,omitempty"`

					// UTP Condition code from UTP Plan (UTP).
					UTP *string `json:"UTP,omitempty"`
				} `json:"sip_mapping"`

				// Type An identifier for a collection of related conditions.
				Type ListConditions400ResultsType `json:"type"`

				// UpdateRules A list of aggregation rules.
				UpdateRules *struct {
					// Consolidated Describes aggregation rules on a consolidated (all exchanges) basis.
					Consolidated struct {
						// UpdatesHighLow Whether or not trades with this condition update the high/low.
						UpdatesHighLow bool `json:"updates_high_low"`

						// UpdatesOpenClose Whether or not trades with this condition update the open/close.
						UpdatesOpenClose bool `json:"updates_open_close"`

						// UpdatesVolume Whether or not trades with this condition update the volume.
						UpdatesVolume bool `json:"updates_volume"`
					} `json:"consolidated"`

					// MarketCenter Describes aggregation rules on a per-market-center basis.
					MarketCenter struct {
						// UpdatesHighLow Whether or not trades with this condition update the high/low.
						UpdatesHighLow bool `json:"updates_high_low"`

						// UpdatesOpenClose Whether or not trades with this condition update the open/close.
						UpdatesOpenClose bool `json:"updates_open_close"`

						// UpdatesVolume Whether or not trades with this condition update the volume.
						UpdatesVolume bool `json:"updates_volume"`
					} `json:"market_center"`
				} `json:"update_rules,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Count The total number of results for this request.
			Count int `json:"count"`

			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of conditions that match your query.
			Results []struct {
				// Abbreviation A commonly-used abbreviation for this condition.
				Abbreviation *string `json:"abbreviation,omitempty"`

				// AssetClass An identifier for a group of similar financial instruments.
				AssetClass ListConditionsDefaultResultsAssetClass `json:"asset_class"`

				// DataTypes Data types that this condition applies to.
				DataTypes []ListConditionsDefaultResultsDataTypes `json:"data_types"`

				// Description A short description of the semantics of this condition.
				Description *string `json:"description,omitempty"`

				// Exchange If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute.
				// In other words, data with this condition attached comes exclusively from the given exchange.
				Exchange *int `json:"exchange,omitempty"`

				// Id An identifier used by Massive for this condition. Unique per data type.
				Id int `json:"id"`

				// Legacy If true, this condition is from an old version of the SIPs' specs and no longer is used.
				// Other conditions may or may not reuse the same symbol as this one.
				Legacy *bool `json:"legacy,omitempty"`

				// Name The name of this condition.
				Name string `json:"name"`

				// SipMapping A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
				SipMapping struct {
					// CTA Condition code from the Consolidated Tape Association (CTA).
					CTA *string `json:"CTA,omitempty"`

					// OPRA Condition code from the Options Price Reporting Authority (OPRA).
					OPRA *string `json:"OPRA,omitempty"`

					// UTP Condition code from UTP Plan (UTP).
					UTP *string `json:"UTP,omitempty"`
				} `json:"sip_mapping"`

				// Type An identifier for a collection of related conditions.
				Type ListConditionsDefaultResultsType `json:"type"`

				// UpdateRules A list of aggregation rules.
				UpdateRules *struct {
					// Consolidated Describes aggregation rules on a consolidated (all exchanges) basis.
					Consolidated struct {
						// UpdatesHighLow Whether or not trades with this condition update the high/low.
						UpdatesHighLow bool `json:"updates_high_low"`

						// UpdatesOpenClose Whether or not trades with this condition update the open/close.
						UpdatesOpenClose bool `json:"updates_open_close"`

						// UpdatesVolume Whether or not trades with this condition update the volume.
						UpdatesVolume bool `json:"updates_volume"`
					} `json:"consolidated"`

					// MarketCenter Describes aggregation rules on a per-market-center basis.
					MarketCenter struct {
						// UpdatesHighLow Whether or not trades with this condition update the high/low.
						UpdatesHighLow bool `json:"updates_high_low"`

						// UpdatesOpenClose Whether or not trades with this condition update the open/close.
						UpdatesOpenClose bool `json:"updates_open_close"`

						// UpdatesVolume Whether or not trades with this condition update the volume.
						UpdatesVolume bool `json:"updates_volume"`
					} `json:"market_center"`
				} `json:"update_rules,omitempty"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListDividendsResponse parses an HTTP response from a ListDividendsWithResponse call
func ParseListDividendsResponse(rsp *http.Response) (*ListDividendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDividendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// CashAmount The cash amount of the dividend per share owned.
				CashAmount float32 `json:"cash_amount"`

				// Currency The currency in which the dividend is paid.
				Currency *string `json:"currency,omitempty"`

				// DeclarationDate The date that the dividend was announced.
				DeclarationDate *string `json:"declaration_date,omitempty"`

				// DividendType The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD.
				// Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
				// Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
				DividendType ListDividends200ResultsDividendType `json:"dividend_type"`

				// ExDividendDate The date that the stock first trades without the dividend, determined by the exchange.
				ExDividendDate string `json:"ex_dividend_date"`

				// Frequency The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
				Frequency int `json:"frequency"`

				// Id The unique identifier of the dividend.
				Id string `json:"id"`

				// PayDate The date that the dividend is paid out.
				PayDate *string `json:"pay_date,omitempty"`

				// RecordDate The date that the stock must be held to receive the dividend, set by the company.
				RecordDate *string `json:"record_date,omitempty"`

				// Ticker The ticker symbol of the dividend.
				Ticker string `json:"ticker"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListExchangesResponse parses an HTTP response from a ListExchangesWithResponse call
func ParseListExchangesResponse(rsp *http.Response) (*ListExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// Acronym A commonly used abbreviation for this exchange.
				Acronym *string `json:"acronym,omitempty"`

				// AssetClass An identifier for a group of similar financial instruments.
				AssetClass ListExchanges200ResultsAssetClass `json:"asset_class"`

				// Id A unique identifier used by Massive for this exchange.
				Id int `json:"id"`

				// Locale An identifier for a geographical location.
				Locale ListExchanges200ResultsLocale `json:"locale"`

				// Mic The Market Identifier Code of this exchange (see ISO 10383).
				Mic *string `json:"mic,omitempty"`

				// Name Name of this exchange.
				Name string `json:"name"`

				// OperatingMic The MIC of the entity that operates this exchange.
				OperatingMic *string `json:"operating_mic,omitempty"`

				// ParticipantId The ID used by SIP's to represent this exchange.
				ParticipantId *string `json:"participant_id,omitempty"`

				// Type Represents the type of exchange.
				Type ListExchanges200ResultsType `json:"type"`

				// Url A link to this exchange's website, if one exists.
				Url *string `json:"url,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListOptionsContractsResponse parses an HTTP response from a ListOptionsContractsWithResponse call
func ParseListOptionsContractsResponse(rsp *http.Response) (*ListOptionsContractsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOptionsContractsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AdditionalUnderlyings If an option contract has additional underlyings or deliverables associated with it, they will appear here.
				// See <a rel="noopener noreferrer nofollow" target="_blank" href="https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies">here</a> for some examples of what might cause a contract to have additional underlyings.
				AdditionalUnderlyings *[]struct {
					// Amount The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
					Amount *float32 `json:"amount,omitempty"`

					// Type The type of the additional underlying asset, either equity or currency.
					Type *string `json:"type,omitempty"`

					// Underlying The name of the additional underlying asset.
					Underlying *string `json:"underlying,omitempty"`
				} `json:"additional_underlyings,omitempty"`

				// Cfi The 6 letter CFI code of the contract (defined in <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/ISO_10962">ISO 10962</a>)
				Cfi *string `json:"cfi,omitempty"`

				// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
				ContractType *string `json:"contract_type,omitempty"`

				// Correction The correction number for this option contract.
				Correction *int `json:"correction,omitempty"`

				// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
				ExerciseStyle *ListOptionsContracts200ResultsExerciseStyle `json:"exercise_style,omitempty"`

				// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
				ExpirationDate *string `json:"expiration_date,omitempty"`

				// PrimaryExchange The MIC code of the primary exchange that this contract is listed on.
				PrimaryExchange *string `json:"primary_exchange,omitempty"`

				// SharesPerContract The number of shares per contract for this contract.
				SharesPerContract *float32 `json:"shares_per_contract,omitempty"`

				// StrikePrice The strike price of the option contract.
				StrikePrice *float32 `json:"strike_price,omitempty"`

				// Ticker The ticker for the option contract.
				Ticker *string `json:"ticker,omitempty"`

				// UnderlyingTicker The underlying ticker that the option contract relates to.
				UnderlyingTicker *string `json:"underlying_ticker,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetOptionsContractResponse parses an HTTP response from a GetOptionsContractWithResponse call
func ParseGetOptionsContractResponse(rsp *http.Response) (*GetOptionsContractResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsContractResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results Contains the requested data for the specified options contract.
			Results *struct {
				// AdditionalUnderlyings If an option contract has additional underlyings or deliverables associated with it, they will appear here.
				// See <a rel="noopener noreferrer nofollow" target="_blank" href="https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies">here</a> for some examples of what might cause a contract to have additional underlyings.
				AdditionalUnderlyings *[]struct {
					// Amount The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
					Amount *float32 `json:"amount,omitempty"`

					// Type The type of the additional underlying asset, either equity or currency.
					Type *string `json:"type,omitempty"`

					// Underlying The name of the additional underlying asset.
					Underlying *string `json:"underlying,omitempty"`
				} `json:"additional_underlyings,omitempty"`

				// Cfi The 6 letter CFI code of the contract (defined in <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/ISO_10962">ISO 10962</a>)
				Cfi *string `json:"cfi,omitempty"`

				// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
				ContractType *string `json:"contract_type,omitempty"`

				// Correction The correction number for this option contract.
				Correction *int `json:"correction,omitempty"`

				// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
				ExerciseStyle *GetOptionsContract200ResultsExerciseStyle `json:"exercise_style,omitempty"`

				// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
				ExpirationDate *string `json:"expiration_date,omitempty"`

				// PrimaryExchange The MIC code of the primary exchange that this contract is listed on.
				PrimaryExchange *string `json:"primary_exchange,omitempty"`

				// SharesPerContract The number of shares per contract for this contract.
				SharesPerContract *float32 `json:"shares_per_contract,omitempty"`

				// StrikePrice The strike price of the option contract.
				StrikePrice *float32 `json:"strike_price,omitempty"`

				// Ticker The ticker for the option contract.
				Ticker *string `json:"ticker,omitempty"`

				// UnderlyingTicker The underlying ticker that the option contract relates to.
				UnderlyingTicker *string `json:"underlying_ticker,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListStockSplitsResponse parses an HTTP response from a ListStockSplitsWithResponse call
func ParseListStockSplitsResponse(rsp *http.Response) (*ListStockSplitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStockSplitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// ExecutionDate The execution date of the stock split. On this date the stock split was applied.
				ExecutionDate string `json:"execution_date"`

				// Id The unique identifier for this stock split.
				Id string `json:"id"`

				// SplitFrom The second number in the split ratio.
				//
				// For example: In a 2-for-1 split, split_from would be 1.
				SplitFrom float32 `json:"split_from"`

				// SplitTo The first number in the split ratio.
				//
				// For example: In a 2-for-1 split, split_to would be 2.
				SplitTo float32 `json:"split_to"`

				// Ticker The ticker symbol of the stock split.
				Ticker string `json:"ticker"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListTickersResponse parses an HTTP response from a ListTickersWithResponse call
func ParseListTickersResponse(rsp *http.Response) (*ListTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of tickers that match your query.
			//
			// Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
			Results *[]struct {
				// Active Whether or not the asset is actively traded. False means the asset has been delisted.
				Active *bool `json:"active,omitempty"`

				// BaseCurrencyName The name of the currency that this asset is priced against.
				BaseCurrencyName *string `json:"base_currency_name,omitempty"`

				// BaseCurrencySymbol The ISO 4217 code of the currency that this asset is priced against.
				BaseCurrencySymbol *string `json:"base_currency_symbol,omitempty"`

				// Cik The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
				Cik *string `json:"cik,omitempty"`

				// CompositeFigi The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
				CompositeFigi *string `json:"composite_figi,omitempty"`

				// CurrencyName The name of the currency that this asset is traded with.
				CurrencyName *string `json:"currency_name,omitempty"`

				// CurrencySymbol The ISO 4217 code of the currency that this asset is traded with.
				CurrencySymbol *string `json:"currency_symbol,omitempty"`

				// DelistedUtc The last date that the asset was traded.
				DelistedUtc *time.Time `json:"delisted_utc,omitempty"`

				// LastUpdatedUtc The information is accurate up to this time.
				LastUpdatedUtc *time.Time `json:"last_updated_utc,omitempty"`

				// Locale The locale of the asset.
				Locale ListTickers200ResultsLocale `json:"locale"`

				// Market The market type of the asset.
				Market ListTickers200ResultsMarket `json:"market"`

				// Name The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
				Name string `json:"name"`

				// PrimaryExchange The ISO code of the primary listing exchange for this asset.
				PrimaryExchange *string `json:"primary_exchange,omitempty"`

				// ShareClassFigi The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
				ShareClassFigi *string `json:"share_class_figi,omitempty"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// Type The type of the asset. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
				Type *string `json:"type,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListTickerTypesResponse parses an HTTP response from a ListTickerTypesWithResponse call
func ParseListTickerTypesResponse(rsp *http.Response) (*ListTickerTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTickerTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AssetClass An identifier for a group of similar financial instruments.
				AssetClass ListTickerTypes200ResultsAssetClass `json:"asset_class"`

				// Code A code used by Massive to refer to this ticker type.
				Code string `json:"code"`

				// Description A short description of this ticker type.
				Description string `json:"description"`

				// Locale An identifier for a geographical location.
				Locale ListTickerTypes200ResultsLocale `json:"locale"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request ID assigned by the server.
			RequestId string `json:"request_id"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetTickerResponse parses an HTTP response from a GetTickerWithResponse call
func ParseGetTickerResponse(rsp *http.Response) (*GetTickerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTickerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count *int `json:"count,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results Ticker with details.
			Results *struct {
				// Active Whether or not the asset is actively traded. False means the asset has been delisted.
				Active bool `json:"active"`

				// Address Company headquarters address details.
				Address *struct {
					// Address1 The first line of the company's headquarters address.
					Address1 *string `json:"address1,omitempty"`

					// Address2 The second line of the company's headquarters address, if applicable.
					Address2 *string `json:"address2,omitempty"`

					// City The city of the company's headquarters address.
					City *string `json:"city,omitempty"`

					// PostalCode The postal code of the company's headquarters address.
					PostalCode *string `json:"postal_code,omitempty"`

					// State The state of the company's headquarters address.
					State *string `json:"state,omitempty"`
				} `json:"address,omitempty"`

				// Branding Provides URLs aiding in visual identification.
				Branding *struct {
					// IconUrl A link to this ticker's company's icon. Icon's are generally smaller, square images that represent the company at a glance.
					// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
					IconUrl *string `json:"icon_url,omitempty"`

					// LogoUrl A link to this ticker's company's logo.
					// Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
					LogoUrl *string `json:"logo_url,omitempty"`
				} `json:"branding,omitempty"`

				// Cik The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
				Cik *string `json:"cik,omitempty"`

				// CompositeFigi The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
				CompositeFigi *string `json:"composite_figi,omitempty"`

				// CurrencyName The name of the currency that this asset is traded with.
				CurrencyName string `json:"currency_name"`

				// DelistedUtc The last date that the asset was traded.
				DelistedUtc *time.Time `json:"delisted_utc,omitempty"`

				// Description A description of the company and what they do/offer.
				Description *string `json:"description,omitempty"`

				// HomepageUrl The URL of the company's website homepage.
				HomepageUrl *string `json:"homepage_url,omitempty"`

				// ListDate The date that the symbol was first publicly listed in the format YYYY-MM-DD.
				ListDate *string `json:"list_date,omitempty"`

				// Locale The locale of the asset.
				Locale GetTicker200ResultsLocale `json:"locale"`

				// Market The market type of the asset.
				Market GetTicker200ResultsMarket `json:"market"`

				// MarketCap The most recent close price of the ticker multiplied by weighted outstanding shares.
				MarketCap *float64 `json:"market_cap,omitempty"`

				// Name The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
				Name string `json:"name"`

				// PhoneNumber The phone number for the company behind this ticker.
				PhoneNumber *string `json:"phone_number,omitempty"`

				// PrimaryExchange The ISO code of the primary listing exchange for this asset.
				PrimaryExchange *string `json:"primary_exchange,omitempty"`

				// RoundLot Round lot size of this security.
				RoundLot *float64 `json:"round_lot,omitempty"`

				// ShareClassFigi The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
				ShareClassFigi *string `json:"share_class_figi,omitempty"`

				// ShareClassSharesOutstanding The recorded number of outstanding shares for this particular share class.
				ShareClassSharesOutstanding *float64 `json:"share_class_shares_outstanding,omitempty"`

				// SicCode The standard industrial classification code for this ticker.  For a list of SIC Codes, see the SEC's <a rel="nofollow" target="_blank" href="https://www.sec.gov/info/edgar/siccodes.htm">SIC Code List</a>.
				SicCode *string `json:"sic_code,omitempty"`

				// SicDescription A description of this ticker's SIC code.
				SicDescription *string `json:"sic_description,omitempty"`

				// Ticker The exchange symbol that this item is traded under.
				Ticker string `json:"ticker"`

				// TickerRoot The root of a specified ticker. For example, the root of BRK.A is BRK.
				TickerRoot *string `json:"ticker_root,omitempty"`

				// TickerSuffix The suffix of a specified ticker. For example, the suffix of BRK.A is A.
				TickerSuffix *string `json:"ticker_suffix,omitempty"`

				// TotalEmployees The approximate number of employees for the company.
				TotalEmployees *float32 `json:"total_employees,omitempty"`

				// Type The type of the asset. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
				Type *string `json:"type,omitempty"`

				// WeightedSharesOutstanding The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
				WeightedSharesOutstanding *float64 `json:"weighted_shares_outstanding,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetSnapshotsResponse parses an HTTP response from a GetSnapshotsWithResponse call
func ParseGetSnapshotsResponse(rsp *http.Response) (*GetSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// BreakEvenPrice The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
				BreakEvenPrice *float64 `json:"break_even_price,omitempty"`

				// Details The details for this contract.
				Details *struct {
					// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
					ContractType GetSnapshots200ResultsDetailsContractType `json:"contract_type"`

					// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
					ExerciseStyle GetSnapshots200ResultsDetailsExerciseStyle `json:"exercise_style"`

					// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
					ExpirationDate openapi_types.Date `json:"expiration_date"`

					// SharesPerContract The number of shares per contract for this contract.
					SharesPerContract float32 `json:"shares_per_contract"`

					// StrikePrice The strike price of the option contract.
					StrikePrice float64 `json:"strike_price"`
				} `json:"details,omitempty"`

				// Error The error while looking for this ticker.
				Error *string `json:"error,omitempty"`

				// Fmv Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security.
				// For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float32 `json:"fmv,omitempty"`

				// FmvLastUpdated If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
				FmvLastUpdated *int64 `json:"fmv_last_updated,omitempty"`

				// Greeks The greeks for this contract.
				// There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money.
				// See this <a href="https://massive.com/blog/greeks-and-implied-volatility/#testing"
				// alt="link">article</a> for more information.
				Greeks *struct {
					// Delta The change in the option's price per $0.01 increment in the price of the underlying asset.
					Delta float64 `json:"delta"`

					// Gamma The change in delta per $0.01 change in the price of the underlying asset.
					Gamma float64 `json:"gamma"`

					// Theta The change in the option's price per day.
					Theta float64 `json:"theta"`

					// Vega The change in the option's price per 1% increment in volatility.
					Vega float64 `json:"vega"`
				} `json:"greeks,omitempty"`

				// ImpliedVolatility The market's forecast for the volatility of the underlying asset, based on this option's current price.
				ImpliedVolatility *float64 `json:"implied_volatility,omitempty"`

				// LastMinute The most recent minute aggregate for this stock.
				LastMinute *struct {
					// Close The closing value for the minute aggreate.
					Close float64 `json:"close"`

					// DecimalVolume The trading volume for the minute aggregate with decimal precision. This field provides support for fractional shares, representing volume as a decimal string where the fractional part is expressed in millionths. This field is only returned for stocks snapshots.
					DecimalVolume *string `json:"decimal_volume,omitempty"`

					// High The highest value for the minute aggregate.
					High float64 `json:"high"`

					// Low The lowest value for the minute aggregate.
					Low float64 `json:"low"`

					// Open The open value for the minute aggregate.
					Open float64 `json:"open"`

					// Transactions The number of transactions that took place within the minute aggregate.
					Transactions int32 `json:"transactions"`

					// Volume The trading volume for the minute aggregate.
					Volume float64 `json:"volume"`

					// Vwap The trading volume weighted average price for the minute aggregate.
					Vwap float64 `json:"vwap"`
				} `json:"last_minute,omitempty"`

				// LastQuote The most recent quote for this contract. This is only returned if your current plan includes quotes.
				LastQuote *struct {
					// Ask The ask price.
					Ask float64 `json:"ask"`

					// AskExchange The ask side exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					AskExchange *int `json:"ask_exchange,omitempty"`

					// AskSize The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
					AskSize *float64 `json:"ask_size,omitempty"`

					// Bid The bid price.
					Bid float64 `json:"bid"`

					// BidExchange The bid side exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					BidExchange *int `json:"bid_exchange,omitempty"`

					// BidSize The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
					BidSize *float64 `json:"bid_size,omitempty"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated int64 `json:"last_updated"`

					// Midpoint The average of the bid and ask price.
					Midpoint *float64 `json:"midpoint,omitempty"`

					// Timeframe The time relevance of the data.
					Timeframe GetSnapshots200ResultsLastQuoteTimeframe `json:"timeframe"`
				} `json:"last_quote,omitempty"`

				// LastTrade The most recent quote for this contract. This is only returned if your current plan includes trades.
				LastTrade *struct {
					// Conditions A list of condition codes.
					Conditions *[]int32 `json:"conditions,omitempty"`

					// DecimalSize The size of a trade, including fractional shares, represented as a decimal string where the fractional part is expressed in millionths. This field is only returned for stocks snapshots.
					DecimalSize *string `json:"decimal_size,omitempty"`

					// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					Exchange *int `json:"exchange,omitempty"`

					// Id The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
					Id *string `json:"id,omitempty"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// ParticipantTimestamp The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
					ParticipantTimestamp *int64 `json:"participant_timestamp,omitempty"`

					// Price The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					Price float64 `json:"price"`

					// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
					SipTimestamp *int64 `json:"sip_timestamp,omitempty"`

					// Size The size of a trade (also known as volume).
					Size int32 `json:"size"`

					// Timeframe The time relevance of the data.
					Timeframe *GetSnapshots200ResultsLastTradeTimeframe `json:"timeframe,omitempty"`
				} `json:"last_trade,omitempty"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// MarketStatus The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading.
				// Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
				MarketStatus *string `json:"market_status,omitempty"`

				// Message The error message while looking for this ticker.
				Message *string `json:"message,omitempty"`

				// Name The name of this contract.
				Name *string `json:"name,omitempty"`

				// OpenInterest The quantity of this contract held at the end of the last trading day.
				OpenInterest *float64 `json:"open_interest,omitempty"`

				// Session Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
				Session *struct {
					// Change The value of the price change for the asset from the previous trading day.
					Change float64 `json:"change"`

					// ChangePercent The percent of the price change for the asset from the previous trading day.
					ChangePercent float64 `json:"change_percent"`

					// Close The closing price of the asset for the day.
					Close float64 `json:"close"`

					// DecimalVolume The trading volume for the asset for the day with decimal precision. This field provides support for fractional shares, representing volume as a decimal string. This field is only returned for stocks snapshots.
					DecimalVolume *string `json:"decimal_volume,omitempty"`

					// EarlyTradingChange Today's early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
					EarlyTradingChange *float64 `json:"early_trading_change,omitempty"`

					// EarlyTradingChangePercent Today's early trading change as a percentage.
					EarlyTradingChangePercent *float64 `json:"early_trading_change_percent,omitempty"`

					// High The highest price of the asset for the day.
					High float64 `json:"high"`

					// LateTradingChange Today's late trading change amount, difference between price and today's close if in late trading hours, otherwise difference between last price during late trading and today's close.
					LateTradingChange *float64 `json:"late_trading_change,omitempty"`

					// LateTradingChangePercent Today's late trading change as a percentage.
					LateTradingChangePercent *float64 `json:"late_trading_change_percent,omitempty"`

					// Low The lowest price of the asset for the day.
					Low float64 `json:"low"`

					// Open The open price of the asset for the day.
					Open float64 `json:"open"`

					// PreviousClose The closing price of the asset for the previous trading day.
					PreviousClose float64 `json:"previous_close"`

					// Price The price of the most recent trade or bid price for this asset.
					Price *float64 `json:"price,omitempty"`

					// RegularTradingChange Today's change in regular trading hours, difference between current price and previous trading day's close, otherwise difference between today's close and previous day's close.
					RegularTradingChange *float64 `json:"regular_trading_change,omitempty"`

					// RegularTradingChangePercent Today's regular trading change as a percentage.
					RegularTradingChangePercent *float64 `json:"regular_trading_change_percent,omitempty"`

					// Volume The trading volume for the asset for the day.
					Volume *float64 `json:"volume,omitempty"`
				} `json:"session,omitempty"`

				// Ticker The ticker symbol for the asset.
				Ticker string `json:"ticker"`

				// Timeframe The time relevance of the data.
				Timeframe *GetSnapshots200ResultsTimeframe `json:"timeframe,omitempty"`

				// Type The asset class for this ticker.
				Type *GetSnapshots200ResultsType `json:"type,omitempty"`

				// UnderlyingAsset Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
				UnderlyingAsset *struct {
					// ChangeToBreakEven The change in price for the contract to break even.
					ChangeToBreakEven float64 `json:"change_to_break_even"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Price The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
					Price *float64 `json:"price,omitempty"`

					// Ticker The ticker symbol for the contract's underlying asset.
					Ticker string `json:"ticker"`

					// Timeframe The time relevance of the data.
					Timeframe *GetSnapshots200ResultsUnderlyingAssetTimeframe `json:"timeframe,omitempty"`

					// Value The value of the underlying index.
					Value *float64 `json:"value,omitempty"`
				} `json:"underlying_asset,omitempty"`

				// Value Value of Index.
				Value *float32 `json:"value,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIndicesSnapshotResponse parses an HTTP response from a GetIndicesSnapshotWithResponse call
func ParseGetIndicesSnapshotResponse(rsp *http.Response) (*GetIndicesSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndicesSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// Error The error while looking for this ticker.
				Error *string `json:"error,omitempty"`

				// LastUpdated The nanosecond timestamp of when this information was updated.
				LastUpdated *int64 `json:"last_updated,omitempty"`

				// MarketStatus The market status for the market that trades this ticker.
				MarketStatus *string `json:"market_status,omitempty"`

				// Message The error message while looking for this ticker.
				Message *string `json:"message,omitempty"`

				// Name Name of Index.
				Name *string `json:"name,omitempty"`

				// Session Trading session metrics, detailing change percentages and key price points (open, close, high, low) for the asset within the current trading day.
				Session *struct {
					// Change The value of the change for the index from the previous trading day.
					Change *float64 `json:"change,omitempty"`

					// ChangePercent The percent of the change for the index from the previous trading day.
					ChangePercent *float64 `json:"change_percent,omitempty"`

					// Close The closing value for the index of the day.
					Close *float64 `json:"close,omitempty"`

					// High The highest value for the index of the day.
					High *float64 `json:"high,omitempty"`

					// Low The lowest value for the index of the day.
					Low *float64 `json:"low,omitempty"`

					// Open The open value for the index of the day.
					Open *float64 `json:"open,omitempty"`

					// PreviousClose The closing value for the index of previous trading day.
					PreviousClose *float64 `json:"previous_close,omitempty"`
				} `json:"session,omitempty"`

				// Ticker Ticker of asset queried.
				Ticker string `json:"ticker"`

				// Timeframe The time relevance of the data.
				Timeframe *GetIndicesSnapshot200ResultsTimeframe `json:"timeframe,omitempty"`

				// Type The indices market.
				Type *GetIndicesSnapshot200ResultsType `json:"type,omitempty"`

				// Value Value of Index.
				Value *float32 `json:"value,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionsChainResponse parses an HTTP response from a GetOptionsChainWithResponse call
func ParseGetOptionsChainResponse(rsp *http.Response) (*GetOptionsChainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsChainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// BreakEvenPrice The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
				BreakEvenPrice float64 `json:"break_even_price"`

				// Day The most recent daily bar for this contract.
				Day struct {
					// Change The value of the price change for the contract from the previous trading day.
					Change float64 `json:"change"`

					// ChangePercent The percent of the price change for the contract from the previous trading day.
					ChangePercent float64 `json:"change_percent"`

					// Close The closing price for the contract of the day.
					Close float64 `json:"close"`

					// High The highest price for the contract of the day.
					High float64 `json:"high"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Low The lowest price for the contract of the day.
					Low float64 `json:"low"`

					// Open The open price for the contract of the day.
					Open float64 `json:"open"`

					// PreviousClose The closing price for the contract of previous trading day.
					PreviousClose float64 `json:"previous_close"`

					// Volume The trading volume for the contract of the day.
					Volume float64 `json:"volume"`

					// Vwap The trading volume weighted average price for the contract of the day.
					Vwap float64 `json:"vwap"`
				} `json:"day"`

				// Details The details for this contract.
				Details struct {
					// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
					ContractType GetOptionsChain200ResultsDetailsContractType `json:"contract_type"`

					// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
					ExerciseStyle GetOptionsChain200ResultsDetailsExerciseStyle `json:"exercise_style"`

					// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
					ExpirationDate openapi_types.Date `json:"expiration_date"`

					// SharesPerContract The number of shares per contract for this contract.
					SharesPerContract float32 `json:"shares_per_contract"`

					// StrikePrice The strike price of the option contract.
					StrikePrice float64 `json:"strike_price"`

					// Ticker The ticker symbol for the asset.
					Ticker string `json:"ticker"`
				} `json:"details"`

				// Fmv Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security.
				// For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float32 `json:"fmv,omitempty"`

				// FmvLastUpdated If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
				FmvLastUpdated *int64 `json:"fmv_last_updated,omitempty"`

				// Greeks The greeks for this contract.
				// There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money.
				// See this <a href="https://massive.com/blog/greeks-and-implied-volatility/#testing"
				// alt="link">article</a> for more information.
				Greeks *struct {
					// Delta The change in the option's price per $0.01 increment in the price of the underlying asset.
					Delta float64 `json:"delta"`

					// Gamma The change in delta per $0.01 change in the price of the underlying asset.
					Gamma float64 `json:"gamma"`

					// Theta The change in the option's price per day.
					Theta float64 `json:"theta"`

					// Vega The change in the option's price per 1% increment in volatility.
					Vega float64 `json:"vega"`
				} `json:"greeks,omitempty"`

				// ImpliedVolatility The market's forecast for the volatility of the underlying asset, based on this option's current price.
				ImpliedVolatility *float64 `json:"implied_volatility,omitempty"`

				// LastQuote The most recent quote for this contract. This is only returned if your current plan includes quotes.
				LastQuote struct {
					// Ask The ask price.
					Ask float64 `json:"ask"`

					// AskExchange The ask side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					AskExchange *int32 `json:"ask_exchange,omitempty"`

					// AskSize The ask size.
					AskSize float64 `json:"ask_size"`

					// Bid The bid price.
					Bid float64 `json:"bid"`

					// BidExchange The bid side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					BidExchange *int32 `json:"bid_exchange,omitempty"`

					// BidSize The bid size.
					BidSize float64 `json:"bid_size"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Midpoint The average of the bid and ask price.
					Midpoint float64 `json:"midpoint"`

					// Timeframe The time relevance of the data.
					Timeframe *GetOptionsChain200ResultsLastQuoteTimeframe `json:"timeframe,omitempty"`
				} `json:"last_quote"`

				// LastTrade The most recent trade for this contract. This is only returned if your current plan includes trades.
				LastTrade *struct {
					// Conditions A list of condition codes.
					Conditions *[]int32 `json:"conditions,omitempty"`

					// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					Exchange int `json:"exchange"`

					// Price The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					Price float64 `json:"price"`

					// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
					SipTimestamp int64 `json:"sip_timestamp"`

					// Size The size of a trade (also known as volume).
					Size int32 `json:"size"`

					// Timeframe The time relevance of the data.
					Timeframe *GetOptionsChain200ResultsLastTradeTimeframe `json:"timeframe,omitempty"`
				} `json:"last_trade,omitempty"`

				// OpenInterest The quantity of this contract held at the end of the last trading day.
				OpenInterest float64 `json:"open_interest"`

				// UnderlyingAsset Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
				UnderlyingAsset struct {
					// ChangeToBreakEven The change in price for the contract to break even.
					ChangeToBreakEven float64 `json:"change_to_break_even"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Price The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
					Price *float64 `json:"price,omitempty"`

					// Ticker The ticker symbol for the contract's underlying asset.
					Ticker string `json:"ticker"`

					// Timeframe The time relevance of the data.
					Timeframe *GetOptionsChain200ResultsUnderlyingAssetTimeframe `json:"timeframe,omitempty"`

					// Value The value of the underlying index.
					Value *float64 `json:"value,omitempty"`
				} `json:"underlying_asset"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOptionContractResponse parses an HTTP response from a GetOptionContractWithResponse call
func ParseGetOptionContractResponse(rsp *http.Response) (*GetOptionContractResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionContractResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results Contains the requested snapshot data for the specified contract.
			Results *struct {
				// BreakEvenPrice The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
				BreakEvenPrice float64 `json:"break_even_price"`

				// Day The most recent daily bar for this contract.
				Day struct {
					// Change The value of the price change for the contract from the previous trading day.
					Change float64 `json:"change"`

					// ChangePercent The percent of the price change for the contract from the previous trading day.
					ChangePercent float64 `json:"change_percent"`

					// Close The closing price for the contract of the day.
					Close float64 `json:"close"`

					// High The highest price for the contract of the day.
					High float64 `json:"high"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Low The lowest price for the contract of the day.
					Low float64 `json:"low"`

					// Open The open price for the contract of the day.
					Open float64 `json:"open"`

					// PreviousClose The closing price for the contract of previous trading day.
					PreviousClose float64 `json:"previous_close"`

					// Volume The trading volume for the contract of the day.
					Volume float64 `json:"volume"`

					// Vwap The trading volume weighted average price for the contract of the day.
					Vwap float64 `json:"vwap"`
				} `json:"day"`

				// Details The details for this contract.
				Details struct {
					// ContractType The type of contract. Can be "put", "call", or in some rare cases, "other".
					ContractType GetOptionContract200ResultsDetailsContractType `json:"contract_type"`

					// ExerciseStyle The exercise style of this contract. See <a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Option_style">this link</a> for more details on exercise styles.
					ExerciseStyle GetOptionContract200ResultsDetailsExerciseStyle `json:"exercise_style"`

					// ExpirationDate The contract's expiration date in YYYY-MM-DD format.
					ExpirationDate openapi_types.Date `json:"expiration_date"`

					// SharesPerContract The number of shares per contract for this contract.
					SharesPerContract float32 `json:"shares_per_contract"`

					// StrikePrice The strike price of the option contract.
					StrikePrice float64 `json:"strike_price"`

					// Ticker The ticker symbol for the asset.
					Ticker string `json:"ticker"`
				} `json:"details"`

				// Fmv Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security.
				// For more information, <a rel="nofollow" target="_blank" href="https://massive.com/contact">contact us</a>.
				Fmv *float32 `json:"fmv,omitempty"`

				// FmvLastUpdated If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
				FmvLastUpdated *int64 `json:"fmv_last_updated,omitempty"`

				// Greeks The greeks for this contract.
				// There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money.
				// See this <a href="https://massive.com/blog/greeks-and-implied-volatility/#testing"
				// alt="link">article</a> for more information.
				Greeks *struct {
					// Delta The change in the option's price per $0.01 increment in the price of the underlying asset.
					Delta float64 `json:"delta"`

					// Gamma The change in delta per $0.01 change in the price of the underlying asset.
					Gamma float64 `json:"gamma"`

					// Theta The change in the option's price per day.
					Theta float64 `json:"theta"`

					// Vega The change in the option's price per 1% increment in volatility.
					Vega float64 `json:"vega"`
				} `json:"greeks,omitempty"`

				// ImpliedVolatility The market's forecast for the volatility of the underlying asset, based on this option's current price.
				ImpliedVolatility *float64 `json:"implied_volatility,omitempty"`

				// LastQuote The most recent quote for this contract. This is only returned if your current plan includes quotes.
				LastQuote struct {
					// Ask The ask price.
					Ask float64 `json:"ask"`

					// AskExchange The ask side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					AskExchange *int32 `json:"ask_exchange,omitempty"`

					// AskSize The ask size.
					AskSize float64 `json:"ask_size"`

					// Bid The bid price.
					Bid float64 `json:"bid"`

					// BidExchange The bid side exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					BidExchange *int32 `json:"bid_exchange,omitempty"`

					// BidSize The bid size.
					BidSize float64 `json:"bid_size"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Midpoint The average of the bid and ask price.
					Midpoint float64 `json:"midpoint"`

					// Timeframe The time relevance of the data.
					Timeframe *GetOptionContract200ResultsLastQuoteTimeframe `json:"timeframe,omitempty"`
				} `json:"last_quote"`

				// LastTrade The most recent trade for this contract. This is only returned if your current plan includes trades.
				LastTrade *struct {
					// Conditions A list of condition codes.
					Conditions *[]int32 `json:"conditions,omitempty"`

					// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
					Exchange int `json:"exchange"`

					// Price The price of the trade. This is the actual dollar value per whole share of
					// this trade. A trade of 100 shares with a price of $2.00 would be worth a
					// total dollar value of $200.00.
					Price float64 `json:"price"`

					// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
					SipTimestamp int64 `json:"sip_timestamp"`

					// Size The size of a trade (also known as volume).
					Size int32 `json:"size"`

					// Timeframe The time relevance of the data.
					Timeframe *GetOptionContract200ResultsLastTradeTimeframe `json:"timeframe,omitempty"`
				} `json:"last_trade,omitempty"`

				// OpenInterest The quantity of this contract held at the end of the last trading day.
				OpenInterest float64 `json:"open_interest"`

				// UnderlyingAsset Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
				UnderlyingAsset struct {
					// ChangeToBreakEven The change in price for the contract to break even.
					ChangeToBreakEven float64 `json:"change_to_break_even"`

					// LastUpdated The nanosecond timestamp of when this information was updated.
					LastUpdated *int64 `json:"last_updated,omitempty"`

					// Price The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
					Price *float64 `json:"price,omitempty"`

					// Ticker The ticker symbol for the contract's underlying asset.
					Ticker string `json:"ticker"`

					// Timeframe The time relevance of the data.
					Timeframe *GetOptionContract200ResultsUnderlyingAssetTimeframe `json:"timeframe,omitempty"`

					// Value The value of the underlying index.
					Value *float64 `json:"value,omitempty"`
				} `json:"underlying_asset"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCryptoTradesResponse parses an HTTP response from a GetCryptoTradesWithResponse call
func ParseGetCryptoTradesResponse(rsp *http.Response) (*GetCryptoTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/crypto/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// Id The Trade ID which uniquely identifies a trade on the exchange that the trade happened on.
				Id *string `json:"id,omitempty"`

				// ParticipantTimestamp The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
				ParticipantTimestamp *int64 `json:"participant_timestamp,omitempty"`

				// Price The price of the trade in the base currency of the crypto pair.
				Price float64 `json:"price"`

				// Size The size of a trade (also known as volume).
				Size float64 `json:"size"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetOptionsTradesResponse parses an HTTP response from a GetOptionsTradesWithResponse call
func ParseGetOptionsTradesResponse(rsp *http.Response) (*GetOptionsTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptionsTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Correction The trade correction indicator.
				Correction *int `json:"correction,omitempty"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/options/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// ParticipantTimestamp The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
				ParticipantTimestamp *int64 `json:"participant_timestamp,omitempty"`

				// Price The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				Price float64 `json:"price"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
				SipTimestamp int64 `json:"sip_timestamp"`

				// Size The size of a trade (also known as volume).
				Size float64 `json:"size"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetStocksTradesResponse parses an HTTP response from a GetStocksTradesWithResponse call
func ParseGetStocksTradesResponse(rsp *http.Response) (*GetStocksTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStocksTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// Conditions A list of condition codes.
				Conditions *[]int32 `json:"conditions,omitempty"`

				// Correction The trade correction indicator.
				Correction *int `json:"correction,omitempty"`

				// DecimalSize The size of the trade including the fractional component. This is represented as a decimal string.
				DecimalSize string `json:"decimal_size"`

				// Exchange The exchange ID. See <a href="https://massive.com/docs/rest/stocks/market-operations/exchanges" alt="Exchanges">Exchanges</a> for Massive's mapping of exchange IDs.
				Exchange int `json:"exchange"`

				// Id The Trade ID which uniquely identifies a trade. These are unique per
				// combination of ticker, exchange, and TRF. For example: A trade for AAPL
				// executed on NYSE and a trade for AAPL executed on NASDAQ could potentially
				// have the same Trade ID.
				Id string `json:"id"`

				// ParticipantTimestamp The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
				ParticipantTimestamp int64 `json:"participant_timestamp"`

				// Price The price of the trade. This is the actual dollar value per whole share of
				// this trade. A trade of 100 shares with a price of $2.00 would be worth a
				// total dollar value of $200.00.
				Price float64 `json:"price"`

				// SequenceNumber The sequence number represents the sequence in which trade events happened.
				// These are increasing and unique per ticker symbol, but will not always be
				// sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
				SequenceNumber int64 `json:"sequence_number"`

				// SipTimestamp The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
				SipTimestamp int64 `json:"sip_timestamp"`

				// Size The size of a trade (also known as volume).
				Size float64 `json:"size"`

				// Tape There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
				// * Tape A is NYSE listed securities
				// * Tape B is NYSE ARCA / NYSE American
				// * Tape C is NASDAQ
				Tape *int32 `json:"tape,omitempty"`

				// TrfId The ID for the Trade Reporting Facility where the trade took place.
				TrfId *int `json:"trf_id,omitempty"`

				// TrfTimestamp The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
				TrfTimestamp *int64 `json:"trf_timestamp,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListFinancialsResponse parses an HTTP response from a ListFinancialsWithResponse call
func ParseListFinancialsResponse(rsp *http.Response) (*ListFinancialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFinancialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results for this request.
			Count int `json:"count"`

			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId string `json:"request_id"`

			// Results An array of results containing the requested data.
			Results []struct {
				// AcceptanceDatetime The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
				AcceptanceDatetime *string `json:"acceptance_datetime,omitempty"`

				// Cik The CIK number for the company.
				Cik string `json:"cik"`

				// CompanyName The company name.
				CompanyName string `json:"company_name"`

				// EndDate The end date of the period that these financials cover in YYYYMMDD format.
				EndDate *string `json:"end_date,omitempty"`

				// FilingDate The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
				FilingDate *string `json:"filing_date,omitempty"`

				// Financials Structured financial statements with detailed data points and metadata.
				Financials struct {
					// BalanceSheet Balance sheet.
					// The keys in this object can be any of the fields listed in the Balance Sheet section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
					BalanceSheet *struct {
						// Asterisk An individual financial data point.
						Asterisk *struct {
							// DerivedFrom The list of report IDs (or errata) which were used to derive this data point.
							// This value is only returned for data points taken directly from XBRL when the `include_sources` query parameter is `true` and if source is SourceInterReportDerived.
							DerivedFrom *[]string `json:"derived_from,omitempty"`

							// Formula The name of the formula used to derive this data point from other financial data points.
							// Information about the formulas can be found <a rel="noopener noreferrer nofollow" target="_blank" href="http://xbrlsite.azurewebsites.net/2020/reporting-scheme/us-gaap/fac/documentation/ImputeRulesList.html">here</a>.
							// This value is only returned for data points that are not explicitly expressed within the XBRL source file when the `include_sources` query parameter is `true` and if source is SourceIntraReportImpute.
							Formula *string `json:"formula,omitempty"`

							// Label A human readable label for the financial data point.
							Label string `json:"label"`

							// Order An indicator of what order within the statement that you would find this data point.
							Order int `json:"order"`

							// Source The source where this data point came from. This will be one of: SourceDirectReport, SourceIntraReportImpute or SourceInterReportDerived.
							Source *string `json:"source,omitempty"`

							// Unit The unit of the financial data point.
							Unit string `json:"unit"`

							// Value The value of the financial data point.
							Value float32 `json:"value"`

							// Xpath The <a rel="noopener noreferrer nofollow" target="_blank" href="https://en.wikipedia.org/wiki/XPath">XPath 1.0</a> query that identifies the fact from within the XBRL source file.
							// This value is only returned for data points taken directly from XBRL when the `include_sources` query parameter is `true` and if source is SourceDirectReport.
							Xpath *string `json:"xpath,omitempty"`
						} `json:"*,omitempty"`
					} `json:"balance_sheet,omitempty"`

					// CashFlowStatement Cash flow statement.
					// The keys in this object can be any of the fields listed in the Cash Flow Statement section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
					// See the attributes of the objects within `balance_sheet` for more details.
					CashFlowStatement *map[string]interface{} `json:"cash_flow_statement,omitempty"`

					// ComprehensiveIncome Comprehensive income.
					// The keys in this object can be any of the fields listed in the Comprehensive Income section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
					// See the attributes of the objects within `balance_sheet` for more details.
					ComprehensiveIncome *map[string]interface{} `json:"comprehensive_income,omitempty"`

					// IncomeStatement Income statement.
					// The keys in this object can be any of the fields listed in the Income Statement section of the <a target="_blank" href="https://massive.com/blog/financials-api-glossary-of-fields">financials API glossary of terms</a>.
					// See the attributes of the objects within `balance_sheet` for more details.
					IncomeStatement *map[string]interface{} `json:"income_statement,omitempty"`
				} `json:"financials"`

				// FiscalPeriod Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
				FiscalPeriod string `json:"fiscal_period"`

				// FiscalYear Fiscal year of the report according to the company.
				FiscalYear *string `json:"fiscal_year,omitempty"`

				// Sic The Standard Industrial Classification (SIC) code for the company.
				Sic *string `json:"sic,omitempty"`

				// SourceFilingFileUrl The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
				SourceFilingFileUrl *string `json:"source_filing_file_url,omitempty"`

				// SourceFilingUrl The URL of the SEC filing that these financials were derived from.
				SourceFilingUrl *string `json:"source_filing_url,omitempty"`

				// StartDate The start date of the period that these financials cover in YYYYMMDD format.
				StartDate *string `json:"start_date,omitempty"`

				// Tickers The list of ticker symbols for the company.
				Tickers *[]string `json:"tickers,omitempty"`

				// Timeframe The timeframe of the report (quarterly, annual or ttm).
				Timeframe string `json:"timeframe"`
			} `json:"results"`

			// Status The status of this request's response.
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIPOsResponse parses an HTTP response from a ListIPOsWithResponse call
func ParseListIPOsResponse(rsp *http.Response) (*ListIPOsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIPOsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextUrl If present, this value can be used to fetch the next page of data.
			NextUrl *string `json:"next_url,omitempty"`

			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results An array of results containing the requested data.
			Results *[]struct {
				// AnnouncedDate The date when the IPO event was announced.
				AnnouncedDate *openapi_types.Date `json:"announced_date,omitempty"`

				// CurrencyCode Underlying currency of the security.
				CurrencyCode *string `json:"currency_code,omitempty"`

				// FinalIssuePrice The price set by the company and its underwriters before the IPO goes live.
				FinalIssuePrice *float32 `json:"final_issue_price,omitempty"`

				// HighestOfferPrice The highest price within the IPO price range that the company might use to price the shares.
				HighestOfferPrice *float32 `json:"highest_offer_price,omitempty"`

				// IpoStatus The status of the IPO event. IPO events start out as status "rumor" or "pending". On listing day, the status changes to "new". After the listing day, the status changes to "history".
				//
				// The status "direct_listing_process" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
				IpoStatus ListIPOs200ResultsIpoStatus `json:"ipo_status"`

				// Isin International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
				Isin *string `json:"isin,omitempty"`

				// IssuerName Name of issuer.
				IssuerName string `json:"issuer_name"`

				// LastUpdated The date when the IPO event was last modified.
				LastUpdated openapi_types.Date `json:"last_updated"`

				// ListingDate First trading date for the newly listed entity.
				ListingDate *openapi_types.Date `json:"listing_date,omitempty"`

				// LotSize The minimum number of shares that can be bought or sold in a single transaction.
				LotSize *float32 `json:"lot_size,omitempty"`

				// LowestOfferPrice The lowest price within the IPO price range that the company is willing to offer its shares to investors.
				LowestOfferPrice *float32 `json:"lowest_offer_price,omitempty"`

				// MaxSharesOffered The upper limit of the shares that the company is offering to investors.
				MaxSharesOffered *float32 `json:"max_shares_offered,omitempty"`

				// MinSharesOffered The lower limit of shares that the company is willing to sell in the IPO.
				MinSharesOffered *float32 `json:"min_shares_offered,omitempty"`

				// PrimaryExchange Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
				PrimaryExchange *string `json:"primary_exchange,omitempty"`

				// SecurityDescription Description of the security.
				SecurityDescription *string `json:"security_description,omitempty"`

				// SecurityType The classification of the stock. For example, "CS" stands for Common Stock.
				SecurityType string `json:"security_type"`

				// SharesOutstanding The total number of shares that the company has issued and are held by investors.
				SharesOutstanding *float32 `json:"shares_outstanding,omitempty"`

				// Ticker The ticker symbol of the IPO event.
				Ticker string `json:"ticker"`

				// TotalOfferSize The total amount raised by the company for IPO.
				TotalOfferSize *float32 `json:"total_offer_size,omitempty"`

				// UsCode This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
				UsCode *string `json:"us_code,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEventsResponse parses an HTTP response from a GetEventsWithResponse call
func ParseGetEventsResponse(rsp *http.Response) (*GetEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RequestId A request id assigned by the server.
			RequestId *string `json:"request_id,omitempty"`

			// Results Contains the requested event data for the specified ticker.
			Results *struct {
				// Events An array of event containing the requested data.
				Events *[]GetEvents_200_Results_Events_Item `json:"events,omitempty"`

				// Name The name of the asset.
				Name *string `json:"name,omitempty"`
			} `json:"results,omitempty"`

			// Status The status of this request's response.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
